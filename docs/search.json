[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HSMA - Web Apps with Streamlit",
    "section": "",
    "text": "Preface\nWelcome to this book accompanying the Streamlit sessions of module 7 of the HSMA programme.\nIn this module we introduce the Streamlit framework for web app development.\nStreamlit is a popular Python web framework that allows powerful and professional looking data apps to be created in hours instead of weeks.\nIn this book, we will introduce some of the key features of Streamlit and how to start putting them together to make more complex apps.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#stlite",
    "href": "index.html#stlite",
    "title": "HSMA - Web Apps with Streamlit",
    "section": "stlite",
    "text": "stlite\nMany examples throughout this book use the stlite framework and the stlite-quarto extension, which allows running of streamlit apps directly on the browser of the reader rather than hosting each app remotely.\nThis does mean that the app examples within each page do take a while to load, and you may not want to read this book cover-to-cover if you are on, say, a mobile network - each example will load several megabytes of data to be able to render.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "HSMA - Web Apps with Streamlit",
    "section": "Acknowledgements",
    "text": "Acknowledgements\n\nDatasets\n\nName Popularity\nThe name popularity dataset used in several examples was created by\n\n\nPalmer Penguins\nThe palmer penguins dataset is loaded via the palmerpenguins library available here. Credit goes to Muhammad Chenariyan Nakhaee for the Python port, and Allison Horst, Alison Hill, and Kristen Gorman for the original dataset and R package.\nHorst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer Archipelago (Antarctica) penguin data. R package version 0.1.0. https://allisonhorst.github.io/palmerpenguins/. doi: 10.5281/zenodo.3960218.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "hello_world_streamlit.html",
    "href": "hello_world_streamlit.html",
    "title": "1  Hello World (Wide Web)!",
    "section": "",
    "text": "1.1 Previewing your app\nWhen you are writing streamlit apps from within your IDE - such as vscode - you will need to run some extra code to preview your app.\nFirst, you must make sure you save your app!\nLet’s save our app as main.py.\nThen we need to open a terminal.\nIn the terminal, we then run the command streamlit run main.py\nThis will spin up a temporary server to run your app from.\nYour app will then automatically open in a browser window in your default browser.\nIf we change and save our source file, like so…\nOur running app will recognise that there has been a change and give us the option to rerun to incorporate the new change without having to close and restart our temporary server.\nThis is really handy as it allows us to rapdily tweak and iterate our Streamlit apps!\nYou can also just use the refresh button in your browser if you would prefer.\nThe ‘always rerun’ option will mean that changes made to your source file will automatically trigger a rerun/refresh without you having to do it manually - it’s up to you if that’s something you’d prefer.",
    "crumbs": [
      "An Introduction to Streamlit",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Hello World (Wide Web)!</span>"
    ]
  },
  {
    "objectID": "hello_world_streamlit.html#knowledge-check",
    "href": "hello_world_streamlit.html#knowledge-check",
    "title": "1  Hello World (Wide Web)!",
    "section": "1.2 Knowledge Check!",
    "text": "1.2 Knowledge Check!\nWhat command do you use to run a streamlit file called main.py on your computer? run streamlit serverrun streamlit main.pystreamlit run main.pystreamlit activate\nWhat’s the standard import for the streamlit library? import streamlitimport streamlit as stfrom streamlit import stimport st as streamlit\nHow do you create a title in streamlit? st.title(Welcome to my app!)streamlit_title(‘Welcome to my app!’)st.title(‘Welcome to my app!’)title(‘Welcome to my app!’)",
    "crumbs": [
      "An Introduction to Streamlit",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Hello World (Wide Web)!</span>"
    ]
  },
  {
    "objectID": "introduction_to_inputs.html",
    "href": "introduction_to_inputs.html",
    "title": "2  Basic Inputs",
    "section": "",
    "text": "2.1 Streamlit Running Order\nA key concept of Streamlit is that each time something changes, the app reruns from top to bottom.\nThis is a good thing for simple apps - but it can become problematic as your app becomes more complex and if you have things that take longer to rerun.\nLet’s make a new app that takes some different inputs.\nHere, despite the fact that the dataframe does not change between runs\nimport streamlit as st\nimport time\nimport pandas as pd\n\nst.write(\"Loading the name popularity lookup\")\ntime.sleep(3)\nst.write(\"Still Loading...\")\ntime.sleep(3)\n\nurl = 'https://www.dropbox.com/scl/fi/yxrc1ll9o3kpg5b1ekm5b/girl_boy_names_2022.csv?rlkey=eq3uv3ms5441gqxchnnom1h6b&st=d53l3q1q&dl=1'\nname_lookup = pd.read_csv(url)\nst.write(\"Done!\")\n\ninput_name = st.text_input(\"What is your name?\")\n\nboy_name_lookup = name_lookup[name_lookup[\"Boy Name\"] == input_name]\ngirl_name_lookup = name_lookup[name_lookup[\"Girl Name\"] == input_name]\n\nif len(boy_name_lookup) &gt; 0:\n    st.write(f\"{input_name} was in popularity position {boy_name_lookup[\"Rank\"].values[0]} for boys in 2022.\")\nelse:\n    st.write(f\"{input_name} was not in the most popular 1000 names for boys in 2022.\")\n\nif len(girl_name_lookup) &gt; 0:\n    st.write(f\"{input_name} was in popularity position {girl_name_lookup[\"Rank\"].values[0]} for girls in 2022.\")\nelse:\n    st.write(f\"{input_name} was not in the most popular 1000 names for girls in 2022.\")",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic Inputs</span>"
    ]
  },
  {
    "objectID": "introduction_to_inputs.html#streamlit-running-order",
    "href": "introduction_to_inputs.html#streamlit-running-order",
    "title": "2  Basic Inputs",
    "section": "",
    "text": "Note\n\n\n\nHere we artifically induce a wait for the loading phase so you can more clearly see the process by which the app reruns.\nYou don’t need to do this in your own apps! They will just run as fast as the code possibly can - but that can still not be fast enough if there are lots of things that need to be recalculated.\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThere are some more advanced features of Streamlit you can call upon when you want to minimize the number of code reruns that occur unnecessarily.\nWe’ll cover these - such as caching, partial reruns, activation buttons and session state - later in the book.\nFor now, it’s just important to be aware that a Streamlit app behaves a lot like a Python script - it’s almost like a frontend that reruns a script each time an input value is changed.\nThis design decision keeps the code as simple as possible - and it’s often not a big problem for simpler apps.\nStill, you will need to keep it in mind as your apps grow in complexity.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basic Inputs</span>"
    ]
  },
  {
    "objectID": "file_uploads.html",
    "href": "file_uploads.html",
    "title": "4  File Uploads",
    "section": "",
    "text": "4.1 A simple csv file upload\nLet’s start off by asking the user to upload any csv file of data.\nWe’ll then display some summary details about their dataframe and the first five values from each column.\nRight click on the following link and choose ‘save as’ to download a sample file you can use in the following app: file\nimport streamlit as st\nimport pandas as pd\n\nuploaded_file = st.file_uploader(\"Please upload a data file\")\n\nif uploaded_file is not None:\n    uploaded_df = pd.read_csv(uploaded_file)\n\n    st.write(f\"Your dataframe has {len(uploaded_df)} rows.\")\n\n    st.write(f\"Your dataframe has {len(uploaded_df.columns)} columns.\")\n\n    st.write(f\"The columns in your dataframe are {', '.join(uploaded_df.columns)}.\")\n\n    for col in uploaded_df.columns:\n        st.write(f\"The first 5 values in column {col} are {', '.join(uploaded_df[col].head().astype('str'))}\")",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>File Uploads</span>"
    ]
  },
  {
    "objectID": "file_uploads.html#a-simple-csv-file-upload",
    "href": "file_uploads.html#a-simple-csv-file-upload",
    "title": "4  File Uploads",
    "section": "",
    "text": "Note\n\n\n\nThe key thing to notice here is that we have two steps to getting a usable csv file for our next steps:\n\nsave the output of st.file_uploader() to a variable\nread this output using the pd.read_csv() method\n\n\n\n\n\n\n4.1.1 Limiting the file types\nBy default, we haven’t restricted the file types that can be uploaded.\nLet’s do that now!\n\nimport streamlit as st\nimport pandas as pd\n\nuploaded_file = st.file_uploader(\"Please upload a csv data file\", type=['csv'])\n\nif uploaded_file is not None:\n    uploaded_df = pd.read_csv(uploaded_file)\n\n    st.write(uploaded_df.head())\n\n\nThe app will try to prevent us from uploading the wrong type of file by only showing the correct type of file in our file explorer.\n\nIf we now try to upload a file with a different extension, we’ll receive a more user-friendly error message.\n\nIf we passed more possible extensions to the list, we would allow more extensions to be uploaded - but we’d also have to adapt our code to deal with each of the possible types that can be uploaded!",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>File Uploads</span>"
    ]
  },
  {
    "objectID": "file_uploads.html#uploading-image-files",
    "href": "file_uploads.html#uploading-image-files",
    "title": "4  File Uploads",
    "section": "4.2 Uploading image files",
    "text": "4.2 Uploading image files\nWe can easily upload image files too.\nLet’s try loading an image file and displaying it for the user.\n\nimport streamlit as st\n\nuploaded_image = st.file_uploader(\"Please upload an image file\", type=['png','jpg','jpeg','bmp', 'bitmap'])\n\nif uploaded_image is not None:\n\n    st.image(uploaded_image)\n\n\n\n4.2.1 Manipulating uploaded image files\nWe have to undertake a few extra steps to be able to manipulate image files people have uploaded.\nWe’ll be using the pillow library (referred to as PIL in code) - but it expects the image to be converted to a series of bytes first.\nOnce we’ve adjusted the image into the format pillow expects, we can use the library to run a range of edits and enhancements to our image.\n\n\n\n\n\n\nTip\n\n\n\nThe code below shows just a couple of the things pillow (PIL) can do - take a look at the documentation to find more!\n\n\nLet’s have a go at it here.\n\nimport streamlit as st\nimport io\nfrom PIL import Image, ImageEnhance\nimport PIL.ImageOps\n\nuploaded_image = st.file_uploader(\"Please upload an image file\", type=['png','jpg','jpeg','bmp', 'bitmap'])\n\nif uploaded_image is not None:\n\n    imagefile = io.BytesIO(uploaded_image.read())\n\n    im = Image.open(imagefile)\n\n    threshold = st.slider(\"Choose a threshold\", 1, 100, value=80, step=1)\n    contrast_factor = st.slider(\"Contrast Enhancement Strength\", 0.0, 2.0, value=1.0, step=0.05)\n    invert = st.checkbox(\"Invert Output Image?\")\n\n    enhancer = ImageEnhance.Contrast(im)\n    img_edited = enhancer.enhance(contrast_factor)\n\n    img_edited = img_edited.convert(\"L\").point(\n        lambda x: 255 if x &gt; threshold else 0\n    )\n\n    if invert:\n        img_edited = PIL.ImageOps.invert(img_edited)\n\n    st.write(\"Original Image\")\n    st.image(uploaded_image)\n\n    st.write(\"Edited Image\")\n    st.image(img_edited)\n\n\n\n\n\n\n\n\nBackground removal\n\n\n\nWe could take this even further with the rembg library, which removes the image’s background.\nWe can’t demonstrate this interactively on this page, but the code below would work for a standard streamlit app run or hosted locally, or on streamlit community cloud.\nIt doesn’t work with stlite/browser-based Python due to dependencies of the rembg library that are unavailable via that method.\n\nimport streamlit as st\nimport io\nfrom PIL import Image\nfrom rembg import remove\n\nuploaded_image = st.file_uploader(\"Please upload an image file\", type=['png','jpg','jpeg','bmp', 'bitmap'])\n\nif uploaded_image is not None:\n\n    imagefile = io.BytesIO(uploaded_image.read())\n\n    im = Image.open(imagefile)\n\n    img_edited = remove(im)\n\n    st.write(\"Original Image\")\n    st.image(uploaded_image)\n\n    st.write(\"Edited Image\")\n    st.image(img_edited)\n\n2024-08-15 09:04:34.622 \n  Warning: to view this Streamlit app on a browser, run it with the following\n  command:\n\n    streamlit run c:\\HSMA\\streamlit_book\\.venv\\Lib\\site-packages\\ipykernel_launcher.py [ARGUMENTS]",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>File Uploads</span>"
    ]
  },
  {
    "objectID": "file_downloads_tabular.html",
    "href": "file_downloads_tabular.html",
    "title": "12  Downloading tabular files",
    "section": "",
    "text": "12.1 Saving pandas dataframes\nFor now, we’ll assume the tabular data you want to save is in a pandas dataframe.\nThis will usually be the case - or it will be data you can easily transform into a pandas dataframe, like a numpy array.\nLet’s start with an app that has some data on the popularity of names.\nThis app currently just loads in a dataset, does some simple manipulations, then returns the names that appeared most frequently in the dataset.",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Downloading tabular files</span>"
    ]
  },
  {
    "objectID": "file_downloads_tabular.html#saving-pandas-dataframes",
    "href": "file_downloads_tabular.html#saving-pandas-dataframes",
    "title": "12  Downloading tabular files",
    "section": "",
    "text": "12.1.1 Saving as csv or excel file\nIf a dataframe is displayed using the standard st.dataframe() command or the st.write() command, a csv download option will become visible when hovering over the dataframe.\n\nimport streamlit as st\nimport pandas as pd\nimport plotly.express as px\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\nname_lookup_df = pd.read_csv(url).melt(id_vars=[\"Name\", \"Gender\"]).dropna().rename(\n    columns={\"variable\": \"Year\", \"value\": \"Rank\"}\n    )\n\nnames_appearing_most_years = pd.DataFrame(name_lookup_df['Name'].value_counts())\n\nst.dataframe(names_appearing_most_years)\n\n\n\n12.1.1.1 Adding download buttons\nHowever, often we may only be displaying a graph of the data rather than displaying the data as well, or we may want to provide downloads of data files slightly different to the ones we are displaying - for example, ones with more or less columns, or providing the raw data instad of the summarised data we are displaying.\nWhen this is the case, we can instead provide download buttons to allow any python dataframe in our app’s running environment to be downloaded.\nThis is also just a bit more visible than the default .csv download button in streamlit dataframes, which is easy for your end users to miss.\n\n12.1.1.1.1 CSV files\nCSV files are relatively simple to provide a download for.\nThe key steps are\n\nuse the .to_csv() method on the dataframe without providing an output filepath\nencode this object as utf-8 using the .encode() method\npass the output of this code to the download button as the data parameter\n(OPTIONAL) provide a default file name for the resulting csv - you may want to use an f-string to intelligently provide a filename if the data is reflecting options the user has chosen\n(OPTIONAL) Specify the MIME type of the data as \"text/csv\" - an automatic value will be inferred from the data type, but it is better practice to more explicitly specify it like this\n\n\nimport streamlit as st\nimport pandas as pd\nimport plotly.express as px\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\nname_lookup_df = pd.read_csv(url)\n\nname_lookup_df = name_lookup_df.melt(id_vars=[\"Name\", \"Gender\"]).dropna().rename(\n    columns={\"variable\": \"Year\", \"value\": \"Rank\"}\n    )\n\nname_lookup_df['Year'] = name_lookup_df['Year'].astype('int64')\nname_lookup_df['Rank'] = name_lookup_df['Rank'].astype('int64')\n\ninput_name = st.text_input(\"What name would you like to lookup?\", value=\"Daniel\")\n\nindividual_df = name_lookup_df[name_lookup_df['Name'] == input_name]\n\nif input_name is not None:\n\n    st.plotly_chart(\n        px.line(individual_df,\n                y=\"Rank\", x=\"Year\", color=\"Gender\",\n                range_y=[1000, 0], range_x=[1920, 2022],\n                markers=True)\n                )\n\nst.download_button(\n   \"Click here to download the dataframe as a csv file\",\n   individual_df.to_csv(index=False).encode('utf-8'),\n   f\"{input_name}_historical_popularity.csv\",\n   \"text/csv\")\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhen using plotly, users can hover over the plot and choose ‘Download plot as a png’.\n\n\n\n\n\n12.1.1.1.2 Excel Files\nIt is slightly more complex to set up the download of a dataframe as an Excel file.\nHowever, this does have the benefit of being something your end users will be more familiar with - and with advanced usage of the xlsxwriter library that we’ll make use of, it allows us to add in multiple worksheets to a single file.\n\nimport streamlit as st\nimport pandas as pd\nimport plotly.express as px\nimport xlsxwriter\nfrom io import BytesIO\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\nname_lookup_df = pd.read_csv(url)\n\nname_lookup_df = name_lookup_df.melt(id_vars=[\"Name\", \"Gender\"]).dropna().rename(\n    columns={\"variable\": \"Year\", \"value\": \"Rank\"}\n    )\n\nname_lookup_df['Year'] = name_lookup_df['Year'].astype('int64')\nname_lookup_df['Rank'] = name_lookup_df['Rank'].astype('int64')\n\ninput_name = st.text_input(\"What name would you like to lookup?\", value=\"Daniel\")\n\nindividual_df = name_lookup_df[name_lookup_df['Name'] == input_name]\n\nif input_name is not None:\n\n    st.plotly_chart(\n        px.line(individual_df,\n                y=\"Rank\", x=\"Year\", color=\"Gender\",\n                range_y=[1000, 0], range_x=[1920, 2022],\n                markers=True)\n                )\n\noutput = BytesIO()\n\nwriter = pd.ExcelWriter(output, engine='xlsxwriter')\n\nindividual_df.to_excel(writer, sheet_name=f\"{input_name} Data\", index=False)\nname_lookup_df.to_excel(writer, sheet_name=f\"Full Data\", index=False)\n\nwriter.close()\n\nst.download_button(\n   \"Click here to download the dataframe as an Excel file\",\n   data = output.getvalue(),\n   file_name=f\"{input_name}_historical_popularity.xlsx\",\n   mime=\"application/vnd.ms-excel\"\n)",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Downloading tabular files</span>"
    ]
  },
  {
    "objectID": "file_downloads_images_charts.html",
    "href": "file_downloads_images_charts.html",
    "title": "13  Downloading Images and Charts",
    "section": "",
    "text": "13.0.1 Matplotlib\nWe can provide two possible ways of downloading the output of a matplotlib plot.\nThe first involves saving the resulting plot to a file, then serving that file to the user.\n\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom palmerpenguins import load_penguins\n\npenguins = load_penguins()\n\nfig, ax = plt.subplots(figsize=(15,10))\nplt.scatter(x=penguins[\"body_mass_g\"], y=penguins[\"bill_length_mm\"])\nplt.title(\"Penguin Body Mass (g) versus Bill Length (mm)\")\nax.set_xlabel(\"Body Mass (g)\")\nax.set_ylabel(\"Bill Length (mm)\")\n\nst.pyplot(fig)\n\nfilename = 'penguins_scatter_method_1.png'\nplt.savefig(filename)\nwith open(filename, \"rb\") as img:\n    btn = st.download_button(\n        label=\"Download image\",\n        data=img,\n        file_name=filename,\n        mime=\"image/png\"\n    )\n\n\nThe second involves saving the image to tempory memory, then serving that instead.\n\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom palmerpenguins import load_penguins\nfrom io import BytesIO\n\npenguins = load_penguins()\n\nfig, ax = plt.subplots(figsize=(15,10))\nplt.scatter(x=penguins[\"body_mass_g\"], y=penguins[\"bill_length_mm\"])\nplt.title(\"Penguin Body Mass (g) versus Bill Length (mm)\")\nax.set_xlabel(\"Body Mass (g)\")\nax.set_ylabel(\"Bill Length (mm)\")\n\nst.pyplot(fig)\n\nimg = BytesIO()\nplt.savefig(img)\n\nbtn = st.download_button(\n    label=\"Download image\",\n    data=img,\n    file_name='penguins_scatter_method_2.png',\n    mime=\"image/png\"\n)\n\n\n\n13.0.1.1 Wordcloud Example\nThe popular wordcloud package is actually using matplotlib for its plotting!\nThis means that the same approach works for saving a wordcloud.\nHere, we are just showing the approach of saving and then serving the image - both to display it in the app and to offer it up to the end user for download.\n\nimport streamlit as st\nfrom wordcloud import WordCloud, STOPWORDS\nimport string\nimport matplotlib.pyplot as plt\n\nstopwords = set(STOPWORDS)\n\ndef make_wordcloud(text_input):\n    tokens = text_input.split()\n    punctuation_mapping_table = str.maketrans('', '', string.punctuation)\n    tokens_stripped_of_punctuation = [token.translate(punctuation_mapping_table)\n                                  for token in tokens]\n    lower_tokens = [token.lower() for token in tokens_stripped_of_punctuation]\n\n    joined_string = (\" \").join(lower_tokens)\n\n    wordcloud = WordCloud(width=1800,\n                      height=1800,\n                      background_color='white',\n                      stopwords=stopwords,\n                      min_font_size=20).generate(joined_string)\n\n    plt.figure(figsize=(30,40))\n    # Turn off axes\n    plt.axis(\"off\")\n    # Then use imshow to plot an image (here, our wordcloud)\n    plt.imshow(wordcloud)\n    # The easiest way to do this today is to save the image and reload it\n    # This works during local testing but would also work if we deployed this\n    plt.savefig(\"wordcloud.png\")\n\nsample_text = \"\"\"\nPenguins are a group of aquatic flightless birds from the family Spheniscidae of the order Sphenisciformes. They live almost exclusively in the Southern Hemisphere: only one species, the Galápagos penguin, is found north of the Equator. Highly adapted for life in the ocean water, penguins have countershaded dark and white plumage and flippers for swimming. Most penguins feed on krill, fish, squid and other forms of sea life which they catch with their bills and swallow whole while swimming. A penguin has a spiny tongue and powerful jaws to grip slippery prey.\n\nThey spend about half of their lives on land and the other half in the sea. The largest living species is the emperor penguin (Aptenodytes forsteri): on average, adults are about 1.1 m (3 ft 7 in) tall and weigh 35 kg (77 lb). The smallest penguin species is the little blue penguin (Eudyptula minor), also known as the fairy penguin, which stands around 30–33 cm (12–13 in) tall and weighs 1.2–1.3 kg (2.6–2.9 lb). Today, larger penguins generally inhabit colder regions, and smaller penguins inhabit regions with temperate or tropical climates. Some prehistoric penguin species were enormous: as tall or heavy as an adult human. There was a great diversity of species in subantarctic regions, and at least one giant species in a region around 2,000 km south of the equator 35 mya, during the Late Eocene, a climate decidedly warmer than today.\n\"\"\"\n\nyour_text = st.text_area(label=\"Enter your text here\", value=sample_text)\n\nmake_wordcloud(text_input=your_text)\n\nst.image(\"wordcloud.png\")\n\nwith open(\"wordcloud.png\", \"rb\") as file:\n    btn = st.download_button(\n        label=\"Click Here to Download Your Word Cloud!\",\n        data=file,\n        file_name=\"my_wordcloud.png\",\n        mime=\"image/png\",\n    )\n\n\n\n\n\n13.0.2 Seaborn\nSaving the file and then serving this is a good way to work with seaborn as well.\n\n\n\n\n13.0.3 Plotly\nPlotly is a bit different because the plots it produces are interactive.\n\n13.0.3.1 Built-in method for downloading static plots\nWhen using plotly, users can hover over the plot and choose ‘Download plot as a png’.\n\n\n\n13.0.3.2 Downloading the interactive plots\nWe can once again use StringIO to save the chart html temporarily to memory, then write that to a html file when the user clicks on a download button.\nThe resulting file is completely self-contained and can even be used offline. The file could be emailed or placed on a shared site like sharepoint or google drive and would work - though sometimes it requires the user to download the html file to their own machine for it to display correctly rather than just previewing the underlying html data, depending on the platform.\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\nfrom io import StringIO\n\npenguins = load_penguins()\n\naxis_options = ['bill_length_mm', 'bill_depth_mm',\n       'flipper_length_mm', 'body_mass_g']\n\ncol_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\naxis_options.remove(col_1)\n\ncol_2 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\ncolor_factor = st.selectbox(\"Select the column to colour the chart by\",\n[\"species\", \"sex\", \"island\"])\n\nfig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\ntitle=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\nst.plotly_chart(fig)\n\nbuffer = StringIO()\nfig.write_image(buffer)\n\nst.download_button(\n    label='Download This Plot as an Interactive HTML file',\n    data=buffer,\n    file_name=f'{col_1}_vs_{col_2}_by_{color_factor}.png',\n    mime='text/html'\n)\n\n\n\n\n13.0.3.3 Static outputs with a download button\nWith some additional libraries, it becomes possible to output static images when using plotly, which can give you additional control over things like the filetype and filename.\nIt requires an additional library called kaleido to be installed.\nMore about the process can be found in the Plotly documentation.\nLINK\nFor our purposes, it is perhaps quicker and more efficient to use the StringIO buffer again, so we will use to_image() instead of save_image().\nOur code would look like this.\n\n\n\n\n\n\nWarning\n\n\n\nThe kaleido library is not possible to use with stlite, so we cannot provide an interactive demo here.\n\n\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\nfrom io import StringIO\n# the kaleido package must also be installed in the environment for the saving of static plots\n# to work\npenguins = load_penguins()\n\naxis_options = ['bill_length_mm', 'bill_depth_mm',\n       'flipper_length_mm', 'body_mass_g']\n\ncol_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\naxis_options.remove(col_1)\n\ncol_2 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\ncolor_factor = st.selectbox(\"Select the column to colour the chart by\",\n[\"species\", \"sex\", \"island\"])\n\nfig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\ntitle=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\nfig.write_image(\"temp.png\", engine=\"kaleido\")\nst.plotly_chart(fig)\n\nwith open(\"temp.png\", \"rb\") as img:\n    btn = st.download_button(\n        label='Download This Plot as an Static Image File',\n        data=fig.to_image(engine='kaleido'),\n        file_name=f'{col_1}_vs_{col_2}_by_{color_factor}.png',\n        mime='img/png'\n    )\n\n\n\n\n\n\n\nImportant\n\n\n\nkaleido and streamlit seem to negatively interact sometimes, with the download button generating indefinitely.\nAt present, I’m not aware of a fix for this issue!",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Downloading Images and Charts</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps.html",
    "href": "file_downloads_maps.html",
    "title": "14  Downloading Static Maps",
    "section": "",
    "text": "14.1 Maps\nWhile there are various other libraries available for displaying maps in Python and Streamlit, we are going to focus on the two we used in module 3 of the HSMA course\nFor more of a reminder on how to work with geographic data and create maps, you can refer to the HSMA geographic modelling and visualisation book.",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Downloading Static Maps</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps.html#maps",
    "href": "file_downloads_maps.html#maps",
    "title": "14  Downloading Static Maps",
    "section": "",
    "text": "matplotlib (which creates static maps)\nfolium (which creates a leaflet.js interactive map)",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Downloading Static Maps</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps.html#downloading-static-maps-made-with-matplotlib",
    "href": "file_downloads_maps.html#downloading-static-maps-made-with-matplotlib",
    "title": "14  Downloading Static Maps",
    "section": "14.2 Downloading Static Maps Made With Matplotlib",
    "text": "14.2 Downloading Static Maps Made With Matplotlib\nLet’s just start by plotting a map.\n\n\n14.2.0.1 A map with subplots\nStatic maps with subplots are much the same - you are just interested in saving the fig object to a temporary .png image file before then serving that temporary file to the user.\n\n\n\n14.2.0.2 Multiple Separate Maps\nWhat if we want to create several different maps instead of using the subplot feature?\nWe could do this and then provide a download button for each.",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Downloading Static Maps</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps_interactive.html",
    "href": "file_downloads_maps_interactive.html",
    "title": "15  Downloading Interactive Maps",
    "section": "",
    "text": "15.0.1 Folium\nInteractive maps can be created using the Folium package.\nFolium maps cannot be displayed in Streamlit by default, but can be imported using the st-folium custom component.\nOne way to provide them as downloadable objects is to save the html object temporarily, then pass this to our download button, similar to some of the other downloads we have created.",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Downloading Interactive Maps</span>"
    ]
  }
]