[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HSMA - Web Apps with Streamlit",
    "section": "",
    "text": "Preface\nWelcome to this book accompanying the Streamlit sessions of module 7 of the HSMA programme.\nIn this module we introduce the Streamlit framework for web app development.\nStreamlit is a popular Python web framework that allows powerful and professional looking data apps to be created in hours instead of weeks.\nIn this book, we will introduce some of the key features of Streamlit and how to start putting them together to make more complex apps.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#stlite",
    "href": "index.html#stlite",
    "title": "HSMA - Web Apps with Streamlit",
    "section": "stlite",
    "text": "stlite\nMany examples throughout this book use the stlite framework and the stlite-quarto extension, which allows running of streamlit apps directly on the browser of the reader rather than hosting each app remotely.\nThis does mean that the app examples within each page do take a while to load, and you may not want to read this book cover-to-cover if you are on, say, a mobile network - each example will load several megabytes of data to be able to render.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "HSMA - Web Apps with Streamlit",
    "section": "Acknowledgements",
    "text": "Acknowledgements\n\nDatasets\n\nName Popularity\nThe name popularity dataset used in several examples was created by\n\n\nPalmer Penguins\nThe palmer penguins dataset is loaded via the palmerpenguins library available here. Credit goes to Muhammad Chenariyan Nakhaee for the Python port, and Allison Horst, Alison Hill, and Kristen Gorman for the original dataset and R package.\nHorst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer Archipelago (Antarctica) penguin data. R package version 0.1.0. https://allisonhorst.github.io/palmerpenguins/. doi: 10.5281/zenodo.3960218.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "hello_world_streamlit.html",
    "href": "hello_world_streamlit.html",
    "title": "1  Hello World (Wide Web)!",
    "section": "",
    "text": "1.1 Previewing your app\nWhen you are writing streamlit apps from within your IDE - such as vscode - you will need to run some extra code to preview your app.\nFirst, you must make sure you save your app!\nLet’s save our app as main.py.\nThen we need to open a terminal.\nIn the terminal, we then run the command streamlit run main.py\nThis will spin up a temporary server to run your app from.\nYour app will then automatically open in a browser window in your default browser.\nIf we change and save our source file, like so…\nOur running app will recognise that there has been a change and give us the option to rerun to incorporate the new change without having to close and restart our temporary server.\nThis is really handy as it allows us to rapdily tweak and iterate our Streamlit apps!\nYou can also just use the refresh button in your browser if you would prefer.\nThe ‘always rerun’ option will mean that changes made to your source file will automatically trigger a rerun/refresh without you having to do it manually - it’s up to you if that’s something you’d prefer.",
    "crumbs": [
      "An Introduction to Streamlit",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Hello World (Wide Web)!</span>"
    ]
  },
  {
    "objectID": "hello_world_streamlit.html#knowledge-check",
    "href": "hello_world_streamlit.html#knowledge-check",
    "title": "1  Hello World (Wide Web)!",
    "section": "1.2 Knowledge Check!",
    "text": "1.2 Knowledge Check!\nWhat command do you use to run a streamlit file called main.py on your computer? run streamlit serverrun streamlit main.pystreamlit run main.pystreamlit activate\nWhat’s the standard import for the streamlit library? import streamlitimport streamlit as stfrom streamlit import stimport st as streamlit\nHow do you create a title in streamlit? st.title(Welcome to my app!)streamlit_title(‘Welcome to my app!’)st.title(‘Welcome to my app!’)title(‘Welcome to my app!’)",
    "crumbs": [
      "An Introduction to Streamlit",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Hello World (Wide Web)!</span>"
    ]
  },
  {
    "objectID": "loading_data.html",
    "href": "loading_data.html",
    "title": "2  Loading Data",
    "section": "",
    "text": "Streamlit apps are just like standard Python scripts in a lot of ways.\nThis means that most of the standard methods we are used to for loading in data files will work!\nAs people working with data, much of what we want to load in is likely to be is data in a tabular format, like an Excel file or Google Sheet.\nLet’s start by loading in and displaying a simple csv dataset.\n\n\n\n\n\n\nTip\n\n\n\nst.write() is a handy command.\nWhen you pass a variable to it, it will automatically work out a good way to display it.\nOther functions that we talk about in later chapters give you more control over exactly how data or files are displayed - but st.write() can often be a useful starting point.\n\n\n\nimport pandas as pd\nimport streamlit as st\n\nst.title(\"Loading in a data file from a publically-accessible csv\")\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\ndataframe = pd.read_csv(url)\n\nst.write(dataframe)\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn later chapters, we will learn more about loading in data, including\n\nloading in other data types, like images and videos\nallowing users to upload their own data\n‘caching’ data to prevent it being reloaded unnecessarily\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe focus of this book is on giving you the tools to create simple Streamlit apps. For this, we will mainly focus on using csv files that are stored on the web or locally, or are uploaded by users. In other cases, we will look at data that is generated by simply running the app, as in the case of discrete event simulation apps where the act of running it produces the data for the graphs and tables that we want to analyse!\nHowever, in real-world usage, there may be some instances where connecting to a database may be required to allow automated access to data without requiring it to be passed to the app, rather than relying on intermediate exports to formats like csv from the database.\nConnecting directly to a production database is certainly possible and can be done safely and securely - but beyond the scope of this book.\nIf this is your first time working with streamlit, it is highly recommended to work through the book first to learn the core concepts of streamlit apps. Building a proof of concept version of your app with a .csv export or dummy dataset can be done before worrying about the task of connecting to a data source - and often a good proof of concept will provide the motivation within your organisation to unblock the things that may make connecting to data sources difficult!\nStreamlit does provide tools and guidance around connecting to data sources for apps that are going into production; to learn more about connecting to other data sources, like SQL databases, you can take a look at this page from the streamlit documentation.\nThis page gives an overview of how to connect to a range of different SQL database types, public and private google sheets, and more.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Loading Data</span>"
    ]
  },
  {
    "objectID": "dataframes.html",
    "href": "dataframes.html",
    "title": "3  Dataframes",
    "section": "",
    "text": "3.1 st.table()\nLet’s start with st.table.\nst.table gives a basic, non-interactive table.\nThis can be useful when we don’t want users to be able to do things like sort the dataframe columns.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dataframes</span>"
    ]
  },
  {
    "objectID": "dataframes.html#st.dataframe",
    "href": "dataframes.html#st.dataframe",
    "title": "3  Dataframes",
    "section": "3.2 st.dataframe()",
    "text": "3.2 st.dataframe()\nst.dataframe gives more interactivity.\n\nA simple search functionality is available when hovering over it, as well as the option to make the table take up the full screen.\n\n\n3.2.1 The column API\nThe column configuration API is a powerful way to enhance the display of data tables in Streamlit.\nThis allows you to change the displayed column name without having to rename it via Pandas commands, but it also gives more control over how columns display.\nFor example, you can set a numeric column to include a prefix or suffix, or to add a comma to break up long numbers.\nYou can set links to be clickable, images to preview, and add things like sparklines and progress bars.\nLet’s build up a simple dataset manually so we can explore the use of some of these values.\n\n\n\n\n\n\n\nNote\n\n\n\nFor editable dataframes (covered in a later chapter), checkboxes, select dropdowns, date/time pickers and more can be integrated into the table.\n\n\nThe full documentation can be found here and is well worth a read to understand the full range of powerful options available to you via the column configuration API.\n\n\n3.2.2 Pandas stylers\nPandas has a ‘styler’ API",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dataframes</span>"
    ]
  },
  {
    "objectID": "dataframes.html#other-kinds-of-tabular-data",
    "href": "dataframes.html#other-kinds-of-tabular-data",
    "title": "3  Dataframes",
    "section": "3.3 Other kinds of tabular data",
    "text": "3.3 Other kinds of tabular data\nst.dataframe works with Pandas, PyArrow, Snowpark, pySpark, Numpy arrays, lists, sets and dictionaries.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dataframes</span>"
    ]
  },
  {
    "objectID": "dataframes.html#additional-arguments",
    "href": "dataframes.html#additional-arguments",
    "title": "3  Dataframes",
    "section": "3.4 Additional arguments",
    "text": "3.4 Additional arguments\nYou can find out more about the available options in the documentation.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dataframes</span>"
    ]
  },
  {
    "objectID": "static_charts.html",
    "href": "static_charts.html",
    "title": "4  Static Charts",
    "section": "",
    "text": "4.1 Making use of the available space\nMany streamlit components have a parameter called use_container_width.\nWhen set to True in something like st.pyplot, it ensures the output is rescaled to use the maximum available width of the screen.\nThe parameter is set to False by default, which will result in outputs often not optimally using the available space.\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom palmerpenguins import load_penguins\n\npenguins = load_penguins()\n\nfig, ax = plt.subplots(figsize=(15,10))\nplt.scatter(x=penguins[\"body_mass_g\"], y=penguins[\"bill_length_mm\"])\nplt.title(\"Penguin Body Mass (g) versus Bill Length (mm)\")\nax.set_xlabel(\"Body Mass (g)\")\nax.set_ylabel(\"Bill Length (mm)\")\n\nst.subheader(\"use_container_width=False\")\n\nst.pyplot(fig)\n\nst.subheader(\"use_container_width=True\")\n\nst.pyplot(fig, use_container_width=True)",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Static Charts</span>"
    ]
  },
  {
    "objectID": "static_charts.html#making-use-of-the-available-space",
    "href": "static_charts.html#making-use-of-the-available-space",
    "title": "4  Static Charts",
    "section": "",
    "text": "Tip\n\n\n\nThis can become particularly valuable when we start to explore layout options like columns later in the book.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Static Charts</span>"
    ]
  },
  {
    "objectID": "interactive_charts.html",
    "href": "interactive_charts.html",
    "title": "5  Interactive Charts",
    "section": "",
    "text": "5.1 Making use of the available space\nMany streamlit components have a parameter called use_container_width.\nWhen set to True in something like st.pyplot, it ensures the output is rescaled to use the maximum available width of the screen.\nThe parameter is set to False by default, which will result in outputs often not optimally using the available space.\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\n\npenguins = load_penguins()\n\nfig = px.scatter(penguins, x='bill_length_mm', y='bill_depth_mm', color=\"sex\",\ntitle=f\"Penguins Dataset - Bill Length (mm) vs Bill Depth (mm), coloured by Sex\")\n\nst.subheader(\"use_container_width=False\")\n\nst.plotly_chart(fig)\n\nst.subheader(\"use_container_width=True\")\n\nst.plotly_chart(fig, use_container_width = True)",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Interactive Charts</span>"
    ]
  },
  {
    "objectID": "interactive_charts.html#making-use-of-the-available-space",
    "href": "interactive_charts.html#making-use-of-the-available-space",
    "title": "5  Interactive Charts",
    "section": "",
    "text": "Tip\n\n\n\nThis can become particularly valuable when we start to explore layout options like columns later in the book.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Interactive Charts</span>"
    ]
  },
  {
    "objectID": "interactive_charts.html#reacting-to-user-inputs",
    "href": "interactive_charts.html#reacting-to-user-inputs",
    "title": "5  Interactive Charts",
    "section": "5.2 Reacting to user inputs",
    "text": "5.2 Reacting to user inputs\nWhile we haven’t gone into detail about user inputs yet, here is an example of a plotly chart updating based on the options a user is selecting.\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\nfrom io import StringIO\n\npenguins = load_penguins()\n\naxis_options = ['bill_length_mm', 'bill_depth_mm',\n       'flipper_length_mm', 'body_mass_g']\n\ncol_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\naxis_options.remove(col_1)\n\ncol_2 = st.selectbox(\"Select the column to use for the y axis\", axis_options)\n\ncolor_factor = st.selectbox(\"Select the column to colour the chart by\",\n[\"species\", \"sex\", \"island\"])\n\nfig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\ntitle=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\nst.plotly_chart(fig)",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Interactive Charts</span>"
    ]
  },
  {
    "objectID": "metrics.html",
    "href": "metrics.html",
    "title": "6  Metrics and Dials",
    "section": "",
    "text": "6.1 Metrics",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Metrics and Dials</span>"
    ]
  },
  {
    "objectID": "metrics.html#metrics",
    "href": "metrics.html#metrics",
    "title": "6  Metrics and Dials",
    "section": "",
    "text": "6.1.1 Layout\nBy combining metrics with st.columns, we can make better use of the screen to start building up more of a dashboard layout.\n\nimport streamlit as st\nimport plotly.express as px\nimport pandas as pd\n\n1st.set_page_config(layout=\"wide\")\n\nst.title(\"Activity Dashboard\")\n\n2col1, col2, col3 = st.columns(3)\n\n3col1.metric(label=\"Total Number of Patients Seen this Week\", value=52)\n\ncol2.metric(label=\"Number of Patients Seen this Week - South\", value=30, delta=-5)\n\ncol2.metric(label=\"Number of Patients Seen this Week - North\", value=12, delta=-7)\n\ncol3.metric(label=\"Number of Patients Seen this Year\", value=1302)\n\n4patients_seen_df = pd.DataFrame(\n  {\n    'Week': ['2021-01-01', '2021-01-08', '2021-01-15', '2021-01-22', '2021-01-29', '2021-02-05'],\n    'Patients Seen': [24, 12, 43, 23, 32, 25]\n  }\n)\n\n5st.plotly_chart(\n  px.line(patients_seen_df, x='Week', y='Patients Seen', title=\"Total Patients Seen per Week\")\n  )\n\n\n1\n\nHere, we’ve started out by setting the page config to ‘wide’. This just means that the page will use the whole width of the viewer’s screen, rather than limiting itself to the middle third.\n\n2\n\nWe set up 3 columns using the st.columns feature, unpacking them on the left-hand side of our assign (the equals sign) into three separate variables called col1, col2, col3 for easy reference (though we could call them anything!). col1 will be the leftmost column and as we haven’t specified otherwise, they will be of equal width.\n\n3\n\nWe then create our metrics, but instead of using st.metric, we use col1.metric (and so on). This is an easy shorthand to assign the resulting metric to each of the columns we’ve just created.\n\n4\n\nNow we’re just going to quickly make a dummy dataframe so that we can see the impact of putting something underneath the column layout. We wouldn’t usually build the dataframe up like this - we’d load it in from a database or csv.\n\n5\n\nNow we’re just creating a plotly chart container and putting a plotly express line chart in it. Note how rather than being inside one of the columns, it takes up the full width of the screen. This is because we’ve gone back to using st.plotly_chart instead of col1.plotly_chart or similar.\n\n\n\n\n\n\n\n6.1.2 Styling Metric Cards\nThe Streamlit Extras package provides us with options to apply a style to our metric cards.\nYou will need to pip install streamlit-extras if it’s not already installed in your environment.\n\nimport streamlit as st\nimport plotly.express as px\nimport pandas as pd\n1from streamlit_extras.metric_cards import style_metric_cards\n\nst.set_page_config(layout=\"wide\")\n\nst.title(\"Activity Dashboard\")\n\ncol1, col2, col3 = st.columns(3)\n\ncol1.metric(label=\"Total Number of Patients\\nSeen this Week\", value=52)\n\ncol2.metric(label=\"Number of Patients\\nSeen this Week - South\", value=30, delta=-5)\n\ncol2.metric(label=\"Number of Patients\\nSeen this Week - North\", value=12, delta=-7)\n\ncol3.metric(label=\"Number of Patients Seen this Year\", value=1302)\n\n2style_metric_cards(background_color=\"#6434eb\", border_color= \"#eb9234\", border_size_px=3)\n\npatients_seen_df = pd.DataFrame(\n  {\n    'Week': ['2021-01-01', '2021-01-08', '2021-01-15', '2021-01-22', '2021-01-29', '2021-02-05'],\n    'Patients Seen': [24, 12, 43, 23, 32, 25]\n  }\n)\n\nst.plotly_chart(\n  px.line(patients_seen_df, x='Week', y='Patients Seen', title=\"Total Patients Seen per Week\")\n  )\n\n\n1\n\nWe import the function style_metric_cards from streamlit_extras.metric_cards\n\n2\n\nWe then use this function after we’ve created our metric cards, passing in the relevant arguments to change the background colour, border colour, border size and more.\n\n\n\n\nFull details of all the available parameters can be found in the streamlit extras documentation\n\n\n\n\n\n\nTip\n\n\n\nThe six-character alphanumeric codes we passed into the ‘background_color’ and ‘border_color’ arguments are called hex colours and are a common way of specifying colours on computers - particularly in web development.\nThere are lots of sites to help you look up hex colours to find the perfect one for you.\nThis page from w3 schools is a starting point.\nYou can also just go to google and seach ‘hex colour picker’ to bring up an interactive picker straight away!",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Metrics and Dials</span>"
    ]
  },
  {
    "objectID": "metrics.html#indicators",
    "href": "metrics.html#indicators",
    "title": "6  Metrics and Dials",
    "section": "6.2 Indicators",
    "text": "6.2 Indicators\nTo get other sorts of displays that we might be familiar with in other dashboarding software, we may need to instead move to plotly or another graphing library rather than using things built in to Streamlit.\n\nTake a look at this documentation from plotly to see how to enhance these charts further, such as\n\nadding a target\nadding segments/reference points to the arc\nchanging the colour of the bar\n\nThis page contains additional things you can do with the indicator graph object in Plotly, such as overlaying a metric card on a plotly chart.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Metrics and Dials</span>"
    ]
  },
  {
    "objectID": "static_maps.html",
    "href": "static_maps.html",
    "title": "7  Static Maps",
    "section": "",
    "text": "7.1 Static maps\nIn the HSMA course, we have generally used the geopandas plot method - which is using matplotlib behind the scenes - to produce static maps.\nThis means that maps are simple to display as we can just use the st.pyplot() function that we used for standard matplotlib charts.\nimport geopandas\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport streamlit as st\n\nst.title(\"Crime in Devon by Type\")\n\n#########################################################\n# Read the geopandas file and create a matplotlib figure\n#########################################################\n\nlsoa_2011_crime_figures_df = geopandas.read_file(\"https://files.catbox.moe/4o0go1.gpkg\")\n\nfig = lsoa_2011_crime_figures_df.plot(column=\"sw_5forces_street_by_lsoa_Other crime\",\n                                      legend=True)\n\nst.pyplot(fig)",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Static Maps</span>"
    ]
  },
  {
    "objectID": "interactive_maps.html",
    "href": "interactive_maps.html",
    "title": "8  Interactive Maps",
    "section": "",
    "text": "8.1 Interactive maps with Folium\nFolium is an easy way to make interactive maps.\nWhile they are not natively supported in streamlit, the st-folium component is a powerful custom component that is being actively supported and developed.\nimport geopandas\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport streamlit as st\nimport folium\nfrom streamlit_folium import st_folium\n\ngp_list_gdf_sw = geopandas.read_file(\"https://files.catbox.moe/atzk26.gpkg\")\n\n# Filter out instances with no geometry\ngp_list_gdf_sw = gp_list_gdf_sw[~gp_list_gdf_sw['geometry'].is_empty]\n\n# Create a geometry list from the GeoDataFrame\ngeo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gp_list_gdf_sw.geometry]\n\ngp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i],\n            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\nst_folium(gp_map_tooltip)",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Interactive Maps</span>"
    ]
  },
  {
    "objectID": "interactive_maps.html#interactive-maps-with-folium",
    "href": "interactive_maps.html#interactive-maps-with-folium",
    "title": "8  Interactive Maps",
    "section": "",
    "text": "8.1.1 Updating the map based on inputs\nLet’s use a simple text input to filter the dataframe we are passing to the map.\nWhat happens to the map when we do this?\n\nimport geopandas\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport streamlit as st\nimport folium\nfrom streamlit_folium import st_folium\nfrom io import StringIO\n\nsearch_string = st.text_input(\"Enter a string to search the practice name field by\")\n\ngp_list_gdf_sw = geopandas.read_file(\"https://files.catbox.moe/atzk26.gpkg\")\n\n# Filter out instances with no geometry\ngp_list_gdf_sw = gp_list_gdf_sw[~gp_list_gdf_sw['geometry'].is_empty]\n\n# Filter to just the practice of interest (if given)\nif search_string is not None:\n    gp_list_gdf_sw = gp_list_gdf_sw[gp_list_gdf_sw['name'].str.contains(search_string.upper())]\n\nst.dataframe(gp_list_gdf_sw[['name', 'address_1', 'postcode', 'Total List Size']])\n\n# Create a geometry list from the GeoDataFrame\ngeo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gp_list_gdf_sw.geometry]\n\ngp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i],\n            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\nst_folium(gp_map_tooltip)\n\n\n\n\n8.1.2 Updating the app based on the map zoom\nYou can do things like filter a dataframe down to only the subset of points that are on the screen within the Folium component.\nTo find out more about this, head to the chapter Bidirectional Inputs - Charts and Maps",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Interactive Maps</span>"
    ]
  },
  {
    "objectID": "custom_components.html",
    "href": "custom_components.html",
    "title": "9  Additional Output Components",
    "section": "",
    "text": "There are a large number of additional third-party components that have been created by the wider streamlit community, with more appearing all the time.\nYou can take a look at them here to see if what you are looking for is listed:\n\nYou may also have luck using a search engine like Google when looking for additional components to do something specific. If the result is a github repository, there will generally be details on the command to run to install it to your environment, and details on how to use it.\nJust exercise some level of caution whenever you are using a custom component - is it sending your data somewhere, for example? In addition, less popular components may eventually be abandoned by their creators,\n\n\n\n\n\n\nWarning\n\n\n\nOver time, as new features come to Streamlit, certain components may become obsolete as the feature they are adding becomes part of the core Streamlit features instead. At the time of writing, user authentication is on the horizon, session state has been integrated, and multipage apps have been around for quite some time - but components to do all of these things appear as very popular entries in the page embedded above.\nWhere a core streamlit implementation of a feature does what you need, stick with that - it will likely be better supported and more stable in the long run.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Additional Output Components</span>"
    ]
  },
  {
    "objectID": "introduction_to_inputs.html",
    "href": "introduction_to_inputs.html",
    "title": "10  Basic Inputs",
    "section": "",
    "text": "10.1 Streamlit Running Order\nA key concept of Streamlit is that each time something changes, the app reruns from top to bottom.\nThis is a good thing for simple apps - but it can become problematic as your app becomes more complex and if you have things that take longer to rerun.\nLet’s make a new app that takes some different inputs.\nHere, despite the fact that the dataframe does not change between runs\nimport streamlit as st\nimport time\nimport pandas as pd\n\nst.write(\"Loading the name popularity lookup\")\ntime.sleep(3)\nst.write(\"Still Loading...\")\ntime.sleep(3)\n\nurl = 'https://www.dropbox.com/scl/fi/yxrc1ll9o3kpg5b1ekm5b/girl_boy_names_2022.csv?rlkey=eq3uv3ms5441gqxchnnom1h6b&st=d53l3q1q&dl=1'\nname_lookup = pd.read_csv(url)\nst.write(\"Done!\")\n\ninput_name = st.text_input(\"What is your name?\")\n\nboy_name_lookup = name_lookup[name_lookup[\"Boy Name\"] == input_name]\ngirl_name_lookup = name_lookup[name_lookup[\"Girl Name\"] == input_name]\n\nif len(boy_name_lookup) &gt; 0:\n    st.write(f\"{input_name} was in popularity position {boy_name_lookup[\"Rank\"].values[0]} for boys in 2022.\")\nelse:\n    st.write(f\"{input_name} was not in the most popular 1000 names for boys in 2022.\")\n\nif len(girl_name_lookup) &gt; 0:\n    st.write(f\"{input_name} was in popularity position {girl_name_lookup[\"Rank\"].values[0]} for girls in 2022.\")\nelse:\n    st.write(f\"{input_name} was not in the most popular 1000 names for girls in 2022.\")",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Basic Inputs</span>"
    ]
  },
  {
    "objectID": "introduction_to_inputs.html#streamlit-running-order",
    "href": "introduction_to_inputs.html#streamlit-running-order",
    "title": "10  Basic Inputs",
    "section": "",
    "text": "Note\n\n\n\nHere we artifically induce a wait for the loading phase so you can more clearly see the process by which the app reruns.\nYou don’t need to do this in your own apps! They will just run as fast as the code possibly can - but that can still not be fast enough if there are lots of things that need to be recalculated.\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThere are some more advanced features of Streamlit you can call upon when you want to minimize the number of code reruns that occur unnecessarily.\nWe’ll cover these - such as caching, partial reruns, activation buttons and session state - later in the book.\nFor now, it’s just important to be aware that a Streamlit app behaves a lot like a Python script - it’s almost like a frontend that reruns a script each time an input value is changed.\nThis design decision keeps the code as simple as possible - and it’s often not a big problem for simpler apps.\nStill, you will need to keep it in mind as your apps grow in complexity.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Basic Inputs</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html",
    "href": "text_numeric_and_selection_inputs.html",
    "title": "11  An Overview of Available Input Types",
    "section": "",
    "text": "11.1 Using inputs in calculations\nIn addition to text, we often want to be able to get numeric inputs from users.\nNumber boxes and sliders are two good ways to do this.\nThe benefit of this is that the resulting output can be guaranteed to be a number - unlike using a text input, where the user could choose to enter a non-numeric value which may break later steps of your app.\nLet’s take a look at how we can use these two kinds of inputs.\nimport streamlit as st\n\nst.subheader(\"Numeric Input\")\n\nchosen_number = st.number_input(\"Pick a Number\")\n\nst.write(f\"The number you have chosen is {chosen_number}\")\n\nchosen_number_multiplied_by_5 = chosen_number * 5\n\nst.write(f\"Your number multiplied by 5 is {chosen_number_multiplied_by_5}\")\n\nst.write(f\"Your number plus 7 is {chosen_number + 7}\")\n\nst.subheader(\"Numeric Slider\")\n\nchosen_number_slider = st.slider(\"Pick a Number on the slider\")\n\nst.write(f\"The number you have chosen is {chosen_number_slider}\")\n\nchosen_number_slider_multiplied_by_8 = chosen_number * 8\n\nst.write(f\"Your number multiplied by 8 is {chosen_number_slider_multiplied_by_8}\")\n\nst.write(f\"Your number plus 3 is {chosen_number_slider + 3}\")",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#other-numeric-and-date-inputs",
    "href": "text_numeric_and_selection_inputs.html#other-numeric-and-date-inputs",
    "title": "11  An Overview of Available Input Types",
    "section": "11.2 Other numeric and date inputs",
    "text": "11.2 Other numeric and date inputs",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#other-useful-input-types",
    "href": "text_numeric_and_selection_inputs.html#other-useful-input-types",
    "title": "11  An Overview of Available Input Types",
    "section": "11.3 Other useful input types",
    "text": "11.3 Other useful input types\nLet’s have a very quick look at some of the other inputs available to us within Streamlit.\nThe desired type of the output will be inferred from the default value you pass into the slider.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#selection-inputs",
    "href": "text_numeric_and_selection_inputs.html#selection-inputs",
    "title": "11  An Overview of Available Input Types",
    "section": "11.4 Selection inputs",
    "text": "11.4 Selection inputs\nSelection inputs are a very useful class of inputs. They allow you to give users a distinct number of options to choose from.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#other-useful-inputs",
    "href": "text_numeric_and_selection_inputs.html#other-useful-inputs",
    "title": "11  An Overview of Available Input Types",
    "section": "11.5 Other useful inputs",
    "text": "11.5 Other useful inputs\nThe final inputs we’ll take a quick look at are checkbox and toggle inputs.\nThese are useful as they return boolean values - True or False.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#additional-input-types-not-covered-here",
    "href": "text_numeric_and_selection_inputs.html#additional-input-types-not-covered-here",
    "title": "11  An Overview of Available Input Types",
    "section": "11.6 Additional Input Types Not Covered Here",
    "text": "11.6 Additional Input Types Not Covered Here\nYou can always refer to the excellent Streamlit documentation to see what other input widgets are available.\nNew official ones are sometimes added, and there are additional ones made by the community that become available over time.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#next-steps-with-inputs",
    "href": "text_numeric_and_selection_inputs.html#next-steps-with-inputs",
    "title": "11  An Overview of Available Input Types",
    "section": "11.7 Next steps with inputs",
    "text": "11.7 Next steps with inputs\nIn the rest of this section, we’ll look at some of the parameters for inputs that will allow you to refine what your users will be allowed to enter, improving the usability of your app (and reducing the number of edge cases you need to account for in your programming!).",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "file_uploads.html",
    "href": "file_uploads.html",
    "title": "12  File Uploads",
    "section": "",
    "text": "12.1 A simple csv file upload\nLet’s start off by asking the user to upload any csv file of data.\nWe’ll then display some summary details about their dataframe and the first five values from each column.\nRight click on the following link and choose ‘save as’ to download a sample file you can use in the following app: file\nimport streamlit as st\nimport pandas as pd\n\nuploaded_file = st.file_uploader(\"Please upload a data file\")\n\nif uploaded_file is not None:\n    uploaded_df = pd.read_csv(uploaded_file)\n\n    st.write(f\"Your dataframe has {len(uploaded_df)} rows.\")\n\n    st.write(f\"Your dataframe has {len(uploaded_df.columns)} columns.\")\n\n    st.write(f\"The columns in your dataframe are {', '.join(uploaded_df.columns)}.\")\n\n    for col in uploaded_df.columns:\n        st.write(f\"The first 5 values in column {col} are {', '.join(uploaded_df[col].head().astype('str'))}\")",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>File Uploads</span>"
    ]
  },
  {
    "objectID": "file_uploads.html#a-simple-csv-file-upload",
    "href": "file_uploads.html#a-simple-csv-file-upload",
    "title": "12  File Uploads",
    "section": "",
    "text": "Note\n\n\n\nThe key thing to notice here is that we have two steps to getting a usable csv file for our next steps:\n\nsave the output of st.file_uploader() to a variable\nread this output using the pd.read_csv() method\n\n\n\n\n\n\n12.1.1 Limiting the file types\nBy default, we haven’t restricted the file types that can be uploaded.\nLet’s do that now!\n\nimport streamlit as st\nimport pandas as pd\n\nuploaded_file = st.file_uploader(\"Please upload a csv data file\", type=['csv'])\n\nif uploaded_file is not None:\n    uploaded_df = pd.read_csv(uploaded_file)\n\n    st.write(uploaded_df.head())\n\n\nThe app will try to prevent us from uploading the wrong type of file by only showing the correct type of file in our file explorer.\n\nIf we now try to upload a file with a different extension, we’ll receive a more user-friendly error message.\n\nIf we passed more possible extensions to the list, we would allow more extensions to be uploaded - but we’d also have to adapt our code to deal with each of the possible types that can be uploaded!",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>File Uploads</span>"
    ]
  },
  {
    "objectID": "file_uploads.html#uploading-image-files",
    "href": "file_uploads.html#uploading-image-files",
    "title": "12  File Uploads",
    "section": "12.2 Uploading image files",
    "text": "12.2 Uploading image files\nWe can easily upload image files too.\nLet’s try loading an image file and displaying it for the user.\n\nimport streamlit as st\n\nuploaded_image = st.file_uploader(\"Please upload an image file\", type=['png','jpg','jpeg','bmp', 'bitmap'])\n\nif uploaded_image is not None:\n\n    st.image(uploaded_image)\n\n\n\n12.2.1 Manipulating uploaded image files\nWe have to undertake a few extra steps to be able to manipulate image files people have uploaded.\nWe’ll be using the pillow library (referred to as PIL in code) - but it expects the image to be converted to a series of bytes first.\nOnce we’ve adjusted the image into the format pillow expects, we can use the library to run a range of edits and enhancements to our image.\n\n\n\n\n\n\nTip\n\n\n\nThe code below shows just a couple of the things pillow (PIL) can do - take a look at the documentation to find more!\n\n\nLet’s have a go at it here.\n\nimport streamlit as st\nimport io\nfrom PIL import Image, ImageEnhance\nimport PIL.ImageOps\n\nuploaded_image = st.file_uploader(\"Please upload an image file\", type=['png','jpg','jpeg','bmp', 'bitmap'])\n\nif uploaded_image is not None:\n\n    imagefile = io.BytesIO(uploaded_image.read())\n\n    im = Image.open(imagefile)\n\n    threshold = st.slider(\"Choose a threshold\", 1, 100, value=80, step=1)\n    contrast_factor = st.slider(\"Contrast Enhancement Strength\", 0.0, 2.0, value=1.0, step=0.05)\n    invert = st.checkbox(\"Invert Output Image?\")\n\n    enhancer = ImageEnhance.Contrast(im)\n    img_edited = enhancer.enhance(contrast_factor)\n\n    img_edited = img_edited.convert(\"L\").point(\n        lambda x: 255 if x &gt; threshold else 0\n    )\n\n    if invert:\n        img_edited = PIL.ImageOps.invert(img_edited)\n\n    st.write(\"Original Image\")\n    st.image(uploaded_image)\n\n    st.write(\"Edited Image\")\n    st.image(img_edited)\n\n\n\n\n\n\n\n\nBackground removal\n\n\n\nWe could take this even further with the rembg library, which removes the image’s background.\nWe can’t demonstrate this interactively on this page, but the code below would work for a standard streamlit app run or hosted locally, or on streamlit community cloud.\nIt doesn’t work with stlite/browser-based Python due to dependencies of the rembg library that are unavailable via that method.\n\nimport streamlit as st\nimport io\nfrom PIL import Image\nfrom rembg import remove\n\nuploaded_image = st.file_uploader(\"Please upload an image file\", type=['png','jpg','jpeg','bmp', 'bitmap'])\n\nif uploaded_image is not None:\n\n    imagefile = io.BytesIO(uploaded_image.read())\n\n    im = Image.open(imagefile)\n\n    img_edited = remove(im)\n\n    st.write(\"Original Image\")\n    st.image(uploaded_image)\n\n    st.write(\"Edited Image\")\n    st.image(img_edited)\n\n2024-09-16 22:54:41.863 \n  Warning: to view this Streamlit app on a browser, run it with the following\n  command:\n\n    streamlit run c:\\HSMA\\streamlit_book\\.venv\\Lib\\site-packages\\ipykernel_launcher.py [ARGUMENTS]",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>File Uploads</span>"
    ]
  },
  {
    "objectID": "bidirectional_plots_and_maps.html",
    "href": "bidirectional_plots_and_maps.html",
    "title": "14  Bidirectional Inputs - Dataframes, Charts and Maps",
    "section": "",
    "text": "14.1 Dataframes\nIn the case of dataframes, maybe we want to allow users to easily select a subset of rows to be plotted on a graph or map, or use this subset of rows to calculate some summary statistics.\nLet’s load in the penguins dataset.\nNotice that we have now saved the output of st.dataframe to a variable, and also added the parameter on_select=\"rerun\".\nBefore we start filtering by what is returned, let’s first just see what actually is returned and explore how this updates.\nWe can then use the selected row indices to restrict the rows we use for subsequent calculations.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bidirectional Inputs - Dataframes, Charts and Maps</span>"
    ]
  },
  {
    "objectID": "bidirectional_plots_and_maps.html#dataframes",
    "href": "bidirectional_plots_and_maps.html#dataframes",
    "title": "14  Bidirectional Inputs - Dataframes, Charts and Maps",
    "section": "",
    "text": "Tip\n\n\n\nNote that selecting a subset of cells like this is not sufficient.\n\nYou must select the full rows using the dataset column at the far left, to the left of the index column if displayed.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe selection_mode parameter can be passed to st.dataframe to allow selection of single or multiple rows, single or multiple columns, or some combination of the two.\nNote that enabling column selection disables column sorting.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bidirectional Inputs - Dataframes, Charts and Maps</span>"
    ]
  },
  {
    "objectID": "bidirectional_plots_and_maps.html#graphs",
    "href": "bidirectional_plots_and_maps.html#graphs",
    "title": "14  Bidirectional Inputs - Dataframes, Charts and Maps",
    "section": "14.2 Graphs",
    "text": "14.2 Graphs\nStreamlit also supports monitoring st.plotly_chart, st.altair_chart, and st.vega_lite_chart for point selections and using this as an input for further actions.\n\n\n\n\n\n\nNote\n\n\n\nIn this book we focus on the use of plotly; take a look at the Streamlit documentation to see how this could work with the Altair and Vega Lite plotting libraries instead.\n\n\nWhen hovering over the plot, users are given options such as ‘box select’ (to choose a box-shaped subset of points) or lasso select (to select an irregular set of points.)\n\nLet’s start by creating a scatterplot of the penguins dataset.\nNotice that we have now saved the output of st.plotly_chart to a variable, and also added the parameter on_select=\"rerun\".\n\nNow let’s see how we could use this to update some outputs.\n\n\n\n\n\n\n\nWarning\n\n\n\nHere, we’ve just chosen a very simple example where there is no colour applied to the points in the graph.\nIf the color parameter is passed to px.scatter then the resulting point indices are related to the rows for that colour only - e.g. if we coloured by the species, then a point_index parameter of 139 wouldn’t relate back to an index of 139 in the original dataset - it would be point 139 for that particular species.\nAlways explore and test the outputs of your filtering carefully to ensure it’s returning what you think it’s returning!\nAs of the time of writing (August 2024), this feature is quite new and there are not many examples of more advanced usage of it.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bidirectional Inputs - Dataframes, Charts and Maps</span>"
    ]
  },
  {
    "objectID": "bidirectional_plots_and_maps.html#sec-maps",
    "href": "bidirectional_plots_and_maps.html#sec-maps",
    "title": "14  Bidirectional Inputs - Dataframes, Charts and Maps",
    "section": "14.3 Maps",
    "text": "14.3 Maps\nFor maps, we need to use the external streamlit_folium library, which must be installed via pip before use - it doesn’t come bundled with Streamlit itself.\n\n14.3.1 Filtering with the bidirectional Folium Component\nWhen using this component, data is constantly being returned as the map is updated.\nLet’s take a look at what is being returned as the map is updated.\n\nimport geopandas\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport streamlit as st\nimport folium\nfrom streamlit_folium import st_folium\nfrom io import StringIO\n\ngp_list_gdf_sw = geopandas.read_file(\"https://files.catbox.moe/atzk26.gpkg\")\n\n# Filter out instances with no geometry\ngp_list_gdf_sw = gp_list_gdf_sw[~gp_list_gdf_sw['geometry'].is_empty]\n\n# Create a geometry list from the GeoDataFrame\ngeo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gp_list_gdf_sw.geometry]\n\ngp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i],\n            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\nreturned_map_data = st_folium(gp_map_tooltip)\n\nst.write(returned_map_data)\n\n\n\n14.3.1.1 Using the returned data\nLet’s get the bounds of the map to filter a dataframe to just contain the points within the area the user has zoomed to.\n\nimport geopandas\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport streamlit as st\nimport folium\nfrom streamlit_folium import st_folium\n\ngp_list_gdf_sw = geopandas.read_file(\"https://files.catbox.moe/atzk26.gpkg\")\n\n# Filter out instances with no geometry\ngp_list_gdf_sw = gp_list_gdf_sw[~gp_list_gdf_sw['geometry'].is_empty]\n\n# Create a geometry list from the GeoDataFrame\ngeo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gp_list_gdf_sw.geometry]\n\ngp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i],\n            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\nreturned_map_data = st_folium(gp_map_tooltip)\n\nxmin = returned_map_data['bounds']['_southWest']['lng']\nxmax = returned_map_data['bounds']['_northEast']['lng']\nymin = returned_map_data['bounds']['_southWest']['lat']\nymax =  returned_map_data['bounds']['_northEast']['lat']\ngp_list_gdf_filtered = gp_list_gdf_sw.cx[xmin:xmax, ymin:ymax]\n\nst.write(f\"Returning data for {len(gp_list_gdf_filtered)} practices\")\n\nst.dataframe(gp_list_gdf_filtered[['name', 'address_1', 'postcode', 'Total List Size']])",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bidirectional Inputs - Dataframes, Charts and Maps</span>"
    ]
  },
  {
    "objectID": "file_downloads_tabular.html",
    "href": "file_downloads_tabular.html",
    "title": "15  Downloading tabular files",
    "section": "",
    "text": "15.1 Saving pandas dataframes\nFor now, we’ll assume the tabular data you want to save is in a pandas dataframe.\nThis will usually be the case - or it will be data you can easily transform into a pandas dataframe, like a numpy array.\nLet’s start with an app that has some data on the popularity of names.\nThis app currently just loads in a dataset, does some simple manipulations, then returns the names that appeared most frequently in the dataset.",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Downloading tabular files</span>"
    ]
  },
  {
    "objectID": "file_downloads_tabular.html#saving-pandas-dataframes",
    "href": "file_downloads_tabular.html#saving-pandas-dataframes",
    "title": "15  Downloading tabular files",
    "section": "",
    "text": "15.1.1 Saving as csv or excel file\nIf a dataframe is displayed using the standard st.dataframe() command or the st.write() command, a csv download option will become visible when hovering over the dataframe.\n\nimport streamlit as st\nimport pandas as pd\nimport plotly.express as px\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\nname_lookup_df = pd.read_csv(url).melt(id_vars=[\"Name\", \"Gender\"]).dropna().rename(\n    columns={\"variable\": \"Year\", \"value\": \"Rank\"}\n    )\n\nnames_appearing_most_years = pd.DataFrame(name_lookup_df['Name'].value_counts())\n\nst.dataframe(names_appearing_most_years)\n\n\n\n15.1.1.1 Adding download buttons\nHowever, often we may only be displaying a graph of the data rather than displaying the data as well, or we may want to provide downloads of data files slightly different to the ones we are displaying - for example, ones with more or less columns, or providing the raw data instad of the summarised data we are displaying.\nWhen this is the case, we can instead provide download buttons to allow any python dataframe in our app’s running environment to be downloaded.\nThis is also just a bit more visible than the default .csv download button in streamlit dataframes, which is easy for your end users to miss.\n\n15.1.1.1.1 CSV files\nCSV files are relatively simple to provide a download for.\nThe key steps are\n\nuse the .to_csv() method on the dataframe without providing an output filepath\nencode this object as utf-8 using the .encode() method\npass the output of this code to the download button as the data parameter\n(OPTIONAL) provide a default file name for the resulting csv - you may want to use an f-string to intelligently provide a filename if the data is reflecting options the user has chosen\n(OPTIONAL) Specify the MIME type of the data as \"text/csv\" - an automatic value will be inferred from the data type, but it is better practice to more explicitly specify it like this\n\n\nimport streamlit as st\nimport pandas as pd\nimport plotly.express as px\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\nname_lookup_df = pd.read_csv(url)\n\nname_lookup_df = name_lookup_df.melt(id_vars=[\"Name\", \"Gender\"]).dropna().rename(\n    columns={\"variable\": \"Year\", \"value\": \"Rank\"}\n    )\n\nname_lookup_df['Year'] = name_lookup_df['Year'].astype('int64')\nname_lookup_df['Rank'] = name_lookup_df['Rank'].astype('int64')\n\ninput_name = st.text_input(\"What name would you like to lookup?\", value=\"Daniel\")\n\nindividual_df = name_lookup_df[name_lookup_df['Name'] == input_name]\n\nif input_name is not None:\n\n    st.plotly_chart(\n        px.line(individual_df,\n                y=\"Rank\", x=\"Year\", color=\"Gender\",\n                range_y=[1000, 0], range_x=[1920, 2022],\n                markers=True)\n                )\n\nst.download_button(\n   \"Click here to download the dataframe as a csv file\",\n   individual_df.to_csv(index=False).encode('utf-8'),\n   f\"{input_name}_historical_popularity.csv\",\n   \"text/csv\")\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhen using plotly, users can hover over the plot and choose ‘Download plot as a png’.\n\n\n\n\n\n15.1.1.1.2 Excel Files\nIt is slightly more complex to set up the download of a dataframe as an Excel file.\nHowever, this does have the benefit of being something your end users will be more familiar with - and with advanced usage of the xlsxwriter library that we’ll make use of, it allows us to add in multiple worksheets to a single file.\n\nimport streamlit as st\nimport pandas as pd\nimport plotly.express as px\nimport xlsxwriter\nfrom io import BytesIO\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\nname_lookup_df = pd.read_csv(url)\n\nname_lookup_df = name_lookup_df.melt(id_vars=[\"Name\", \"Gender\"]).dropna().rename(\n    columns={\"variable\": \"Year\", \"value\": \"Rank\"}\n    )\n\nname_lookup_df['Year'] = name_lookup_df['Year'].astype('int64')\nname_lookup_df['Rank'] = name_lookup_df['Rank'].astype('int64')\n\ninput_name = st.text_input(\"What name would you like to lookup?\", value=\"Daniel\")\n\nindividual_df = name_lookup_df[name_lookup_df['Name'] == input_name]\n\nif input_name is not None:\n\n    st.plotly_chart(\n        px.line(individual_df,\n                y=\"Rank\", x=\"Year\", color=\"Gender\",\n                range_y=[1000, 0], range_x=[1920, 2022],\n                markers=True)\n                )\n\noutput = BytesIO()\n\nwriter = pd.ExcelWriter(output, engine='xlsxwriter')\n\nindividual_df.to_excel(writer, sheet_name=f\"{input_name} Data\", index=False)\nname_lookup_df.to_excel(writer, sheet_name=f\"Full Data\", index=False)\n\nwriter.close()\n\nst.download_button(\n   \"Click here to download the dataframe as an Excel file\",\n   data = output.getvalue(),\n   file_name=f\"{input_name}_historical_popularity.xlsx\",\n   mime=\"application/vnd.ms-excel\"\n)",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Downloading tabular files</span>"
    ]
  },
  {
    "objectID": "file_downloads_images_charts.html",
    "href": "file_downloads_images_charts.html",
    "title": "16  Downloading Images and Charts",
    "section": "",
    "text": "16.0.1 Matplotlib\nWe can provide two possible ways of downloading the output of a matplotlib plot.\nThe first involves saving the resulting plot to a file, then serving that file to the user.\n\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom palmerpenguins import load_penguins\n\npenguins = load_penguins()\n\nfig, ax = plt.subplots(figsize=(15,10))\nplt.scatter(x=penguins[\"body_mass_g\"], y=penguins[\"bill_length_mm\"])\nplt.title(\"Penguin Body Mass (g) versus Bill Length (mm)\")\nax.set_xlabel(\"Body Mass (g)\")\nax.set_ylabel(\"Bill Length (mm)\")\n\nst.pyplot(fig)\n\nfilename = 'penguins_scatter_method_1.png'\nplt.savefig(filename)\nwith open(filename, \"rb\") as img:\n    btn = st.download_button(\n        label=\"Download image\",\n        data=img,\n        file_name=filename,\n        mime=\"image/png\"\n    )\n\n\nThe second involves saving the image to tempory memory, then serving that instead.\n\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom palmerpenguins import load_penguins\nfrom io import BytesIO\n\npenguins = load_penguins()\n\nfig, ax = plt.subplots(figsize=(15,10))\nplt.scatter(x=penguins[\"body_mass_g\"], y=penguins[\"bill_length_mm\"])\nplt.title(\"Penguin Body Mass (g) versus Bill Length (mm)\")\nax.set_xlabel(\"Body Mass (g)\")\nax.set_ylabel(\"Bill Length (mm)\")\n\nst.pyplot(fig)\n\nimg = BytesIO()\nplt.savefig(img)\n\nbtn = st.download_button(\n    label=\"Download image\",\n    data=img,\n    file_name='penguins_scatter_method_2.png',\n    mime=\"image/png\"\n)\n\n\n\n16.0.1.1 Wordcloud Example\nThe popular wordcloud package is actually using matplotlib for its plotting!\nThis means that the same approach works for saving a wordcloud.\nHere, we are just showing the approach of saving and then serving the image - both to display it in the app and to offer it up to the end user for download.\n\nimport streamlit as st\nfrom wordcloud import WordCloud, STOPWORDS\nimport string\nimport matplotlib.pyplot as plt\n\nstopwords = set(STOPWORDS)\n\ndef make_wordcloud(text_input):\n    tokens = text_input.split()\n    punctuation_mapping_table = str.maketrans('', '', string.punctuation)\n    tokens_stripped_of_punctuation = [token.translate(punctuation_mapping_table)\n                                  for token in tokens]\n    lower_tokens = [token.lower() for token in tokens_stripped_of_punctuation]\n\n    joined_string = (\" \").join(lower_tokens)\n\n    wordcloud = WordCloud(width=1800,\n                      height=1800,\n                      background_color='white',\n                      stopwords=stopwords,\n                      min_font_size=20).generate(joined_string)\n\n    plt.figure(figsize=(30,40))\n    # Turn off axes\n    plt.axis(\"off\")\n    # Then use imshow to plot an image (here, our wordcloud)\n    plt.imshow(wordcloud)\n    # The easiest way to do this today is to save the image and reload it\n    # This works during local testing but would also work if we deployed this\n    plt.savefig(\"wordcloud.png\")\n\nsample_text = \"\"\"\nPenguins are a group of aquatic flightless birds from the family Spheniscidae of the order Sphenisciformes. They live almost exclusively in the Southern Hemisphere: only one species, the Galápagos penguin, is found north of the Equator. Highly adapted for life in the ocean water, penguins have countershaded dark and white plumage and flippers for swimming. Most penguins feed on krill, fish, squid and other forms of sea life which they catch with their bills and swallow whole while swimming. A penguin has a spiny tongue and powerful jaws to grip slippery prey.\n\nThey spend about half of their lives on land and the other half in the sea. The largest living species is the emperor penguin (Aptenodytes forsteri): on average, adults are about 1.1 m (3 ft 7 in) tall and weigh 35 kg (77 lb). The smallest penguin species is the little blue penguin (Eudyptula minor), also known as the fairy penguin, which stands around 30–33 cm (12–13 in) tall and weighs 1.2–1.3 kg (2.6–2.9 lb). Today, larger penguins generally inhabit colder regions, and smaller penguins inhabit regions with temperate or tropical climates. Some prehistoric penguin species were enormous: as tall or heavy as an adult human. There was a great diversity of species in subantarctic regions, and at least one giant species in a region around 2,000 km south of the equator 35 mya, during the Late Eocene, a climate decidedly warmer than today.\n\"\"\"\n\nyour_text = st.text_area(label=\"Enter your text here\", value=sample_text)\n\nmake_wordcloud(text_input=your_text)\n\nst.image(\"wordcloud.png\")\n\nwith open(\"wordcloud.png\", \"rb\") as file:\n    btn = st.download_button(\n        label=\"Click Here to Download Your Word Cloud!\",\n        data=file,\n        file_name=\"my_wordcloud.png\",\n        mime=\"image/png\",\n    )\n\n\n\n\n\n16.0.2 Seaborn\nSaving the file and then serving this is a good way to work with seaborn as well.\n\n\n\n\n16.0.3 Plotly\nPlotly is a bit different because the plots it produces are interactive.\n\n16.0.3.1 Built-in method for downloading static plots\nWhen using plotly, users can hover over the plot and choose ‘Download plot as a png’.\n\n\n\n16.0.3.2 Downloading the interactive plots\nWe can once again use StringIO to save the chart html temporarily to memory, then write that to a html file when the user clicks on a download button.\nThe resulting file is completely self-contained and can even be used offline. The file could be emailed or placed on a shared site like sharepoint or google drive and would work - though sometimes it requires the user to download the html file to their own machine for it to display correctly rather than just previewing the underlying html data, depending on the platform.\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\nfrom io import StringIO\n\npenguins = load_penguins()\n\naxis_options = ['bill_length_mm', 'bill_depth_mm',\n       'flipper_length_mm', 'body_mass_g']\n\ncol_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\naxis_options.remove(col_1)\n\ncol_2 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\ncolor_factor = st.selectbox(\"Select the column to colour the chart by\",\n[\"species\", \"sex\", \"island\"])\n\nfig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\ntitle=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\nst.plotly_chart(fig)\n\nbuffer = StringIO()\nfig.write_html(buffer)\n\nst.download_button(\n    label='Download This Plot as an Interactive HTML file',\n    data=buffer,\n    file_name=f'{col_1}_vs_{col_2}_by_{color_factor}.html',\n    mime='text/html'\n)\n\n\n\n\n16.0.3.3 Static outputs with a download button\nWith some additional libraries, it becomes possible to output static images when using plotly, which can give you additional control over things like the filetype and filename.\nIt requires an additional library called kaleido to be installed.\nMore about the process can be found in the Plotly documentation.\nLINK\nFor our purposes, it is perhaps quicker and more efficient to use the StringIO buffer again, so we will use to_image() instead of save_image().\nOur code would look like this.\n\n\n\n\n\n\nWarning\n\n\n\nThe kaleido library is not possible to use with stlite, so we cannot provide an interactive demo here.\n\n\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\nfrom io import StringIO\n# the kaleido package must also be installed in the environment for the saving of static plots\n# to work\npenguins = load_penguins()\n\naxis_options = ['bill_length_mm', 'bill_depth_mm',\n       'flipper_length_mm', 'body_mass_g']\n\ncol_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\naxis_options.remove(col_1)\n\ncol_2 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\ncolor_factor = st.selectbox(\"Select the column to colour the chart by\",\n[\"species\", \"sex\", \"island\"])\n\nfig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\ntitle=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\nfig.write_image(\"temp.png\", engine=\"kaleido\")\nst.plotly_chart(fig)\n\nwith open(\"temp.png\", \"rb\") as img:\n    btn = st.download_button(\n        label='Download This Plot as an Static Image File',\n        data=fig.to_image(engine='kaleido'),\n        file_name=f'{col_1}_vs_{col_2}_by_{color_factor}.png',\n        mime='img/png'\n    )\n\n\n\n\n\n\n\nImportant\n\n\n\nkaleido and streamlit seem to negatively interact sometimes, with the download button generating indefinitely.\nAt present, I’m not aware of a fix for this issue!",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Downloading Images and Charts</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps_static.html",
    "href": "file_downloads_maps_static.html",
    "title": "17  Downloading Static Maps",
    "section": "",
    "text": "17.1 Maps\nWhile there are various other libraries available for displaying maps in Python and Streamlit, we are going to focus on the two we used in module 3 of the HSMA course\nFor more of a reminder on how to work with geographic data and create maps, you can refer to the HSMA geographic modelling and visualisation book.",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Downloading Static Maps</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps_static.html#maps",
    "href": "file_downloads_maps_static.html#maps",
    "title": "17  Downloading Static Maps",
    "section": "",
    "text": "matplotlib (which creates static maps)\nfolium (which creates a leaflet.js interactive map)",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Downloading Static Maps</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps_static.html#downloading-static-maps-made-with-matplotlib",
    "href": "file_downloads_maps_static.html#downloading-static-maps-made-with-matplotlib",
    "title": "17  Downloading Static Maps",
    "section": "17.2 Downloading Static Maps Made With Matplotlib",
    "text": "17.2 Downloading Static Maps Made With Matplotlib\nLet’s just start by plotting a map.\n\n\n17.2.0.1 A map with subplots\nStatic maps with subplots are much the same - you are just interested in saving the fig object to a temporary .png image file before then serving that temporary file to the user.\n\n\n\n17.2.0.2 Multiple Separate Maps\nWhat if we want to create several different maps instead of using the subplot feature?\nWe could do this and then provide a download button for each.",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Downloading Static Maps</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps_interactive.html",
    "href": "file_downloads_maps_interactive.html",
    "title": "18  Downloading Interactive Maps",
    "section": "",
    "text": "18.0.1 Folium\nInteractive maps can be created using the Folium package.\nFolium maps cannot be displayed in Streamlit by default, but can be imported using the st-folium custom component.\nOne way to provide them as downloadable objects is to save the html object temporarily, then pass this to our download button, similar to some of the other downloads we have created.\n\nimport geopandas\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport streamlit as st\nimport folium\nfrom streamlit_folium import st_folium\n\ngp_list_gdf_sw = geopandas.read_file(\"https://files.catbox.moe/atzk26.gpkg\")\n\n# Filter out instances with no geometry\ngp_list_gdf_sw = gp_list_gdf_sw[~gp_list_gdf_sw['geometry'].is_empty]\n\n# Create a geometry list from the GeoDataFrame\ngeo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gp_list_gdf_sw.geometry]\n\ngp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i],\n            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\nst_folium(gp_map_tooltip)\n\ngp_map_tooltip.save(\"gp_map_devon.html\")\n\nwith open(\"gp_map_devon.html\", \"rb\") as map_file_html:\n    st.download_button(\n        label='Download This Map as an Interactive HTML file',\n        data=map_file_html,\n        file_name=f'Devon GP Map.html',\n        mime='text/html'\n    )",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Downloading Interactive Maps</span>"
    ]
  },
  {
    "objectID": "layout_columns.html",
    "href": "layout_columns.html",
    "title": "19  Columns",
    "section": "",
    "text": "19.1 Creating Columns in Streamlit\nStreamlit has a very easy to use column interface for improving the layout of your apps.\nColumns look like this in a Streamlit app.\nimport streamlit as st\n\n1col1, col2, col3 = st.columns(3)\n\n2with col1:\n3  st.header(\"I'm Column 1\")\n  st.write(\"Here's the 'Back to the Future' poster. Images, videos, data tables and more can be displayed within columns.\")\n  st.image(\"https://upload.wikimedia.org/wikipedia/en/d/d2/Back_to_the_Future.jpg\")\n\n4with col2:\n  st.header(\"I'm Column 2\")\n  st.write(\"We can use inputs within columns too.\")\n  name = st.text_input(\"What's your name?\", value=None)\n  if name is not None:\n    st.write(f\"Nice to meet you, {name}!\")\n  else:\n    st.write(\"I can't greet you until you enter your name!\")\n\nwith col3:\n    if name is not None:\n      st.write(f\"Hello again, {name}!\")\n      st.write(\"Isn't it cool that variables persist across different columns? This can be really handy!\")\n      st.video(\"https://youtu.be/dQw4w9WgXcQ?feature=shared\")\n    else:\n      st.write(\"I can't greet you until you enter your name! Go back to column 2 and do that.\")\n\n\n1\n\nFirst, we pass the number of columns we want to create to the st.columns() function. We can then unpack the output of this to a number of variables separated by commas. For example, st.columns(2) produces two variables, while st.columns(4) would produce 4.\n\n2\n\nWe can then use the with statement and refer to the first column of interest. Columns work from left to right; in this case, that means the variable col1 will be the leftmost column, and as we didn’t specify the width of the columns, they will automatically take up a third of the screen in this case. With 2 columns each would take up half, and with 4 each would take up a quarter.\n\n3\n\nNote that everything we want to appear within the column, we indent.\n\n4\n\nWe can then move on to specifying what we want to appear in the next column, using the same structure of with, the variable relating to the column of interested, and an indented block of code.",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Columns</span>"
    ]
  },
  {
    "objectID": "layout_columns.html#the-two-main-syntax-options-for-streamlit-columns",
    "href": "layout_columns.html#the-two-main-syntax-options-for-streamlit-columns",
    "title": "19  Columns",
    "section": "19.2 The two main syntax options for Streamlit columns",
    "text": "19.2 The two main syntax options for Streamlit columns\nThere are two main ways to put content inside of columns.\n\nUsing a ‘with’ statement and indenting the code that should sit within the column, as we did above.\n\n\nimport streamlit as st\ncol_a, col_b = st.columns(2)\n\nwith col_a:\n    st.text(\"This is some content within column 1\")\n\nwith col_b:\n    st.text(\"This is some content within column 2\")\n\n\nReplacing the st in sections like st.text() with the variable name for the given column.\n\n\nimport streamlit as st\n\ncol_a, col_b = st.columns(2)\n\ncol_a.text(\"This is some content within column 1\")\n\ncol_b.text(\"This is some content within column 2\")\n\nThe outputs of both of these bits of code are identical!",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Columns</span>"
    ]
  },
  {
    "objectID": "layout_columns.html#adjusting-column-width",
    "href": "layout_columns.html#adjusting-column-width",
    "title": "19  Columns",
    "section": "19.3 Adjusting Column Width",
    "text": "19.3 Adjusting Column Width\nColumn width can be controlled by",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Columns</span>"
    ]
  },
  {
    "objectID": "layout_columns.html#advanced-column-layouts",
    "href": "layout_columns.html#advanced-column-layouts",
    "title": "19  Columns",
    "section": "19.4 Advanced Column Layouts",
    "text": "19.4 Advanced Column Layouts\nThe great thing about columns is that we can have multiple sets of columns, allowing you to build up fairly complex grid-like layouts.\nHere, we have an example of a top section with three equal-width columns, a central section that uses the full width of the screen, and a final section with two unequal-width columns.\nIt also demonstrates how you can mix and match the use of the with syntax and the col.command syntax within a single Streamlit app.\n\nimport streamlit as st\nimport micropip\nawait micropip.install(\"plotly\")\nawait micropip.install(\"streamlit-extras\")\nimport plotly.express as px\nimport pandas as pd\nfrom streamlit_extras.metric_cards import style_metric_cards\n\nst.set_page_config(layout=\"wide\")\n\nst.title(\"Activity Dashboard\")\n\ncol1, col2, col3 = st.columns(3)\n\ncol1.metric(label=\"Total Number of Patients Seen this Week\", value=52)\n\ncol2.metric(label=\"Number of Patients Seen this Week - South\", value=30, delta=-5)\n\ncol2.metric(label=\"Number of Patients Seen this Week - North\", value=12, delta=-7)\n\ncol3.metric(label=\"Number of Patients Seen this Year\", value=1302)\n\nstyle_metric_cards(background_color=\"#6434eb\", border_color= \"#eb9234\", border_size_px=3)\n\npatients_seen_df = pd.DataFrame(\n  {\n    'Week': ['2021-01-01', '2021-01-08', '2021-01-15', '2021-01-22', '2021-01-29', '2021-02-05'],\n    'Patients Seen': [24, 12, 43, 23, 32, 25]\n  }\n)\n\nst.plotly_chart(\n  px.line(patients_seen_df, x='Week', y='Patients Seen', title=\"Total Patients Seen per Week\"),\n  use_container_width=True\n  )\n\ncol4, col5 = st.columns([0.3, 0.7])\n\nwith col4:\n    st.write(\"Here's some text in this extra column. It's not a very wide column!\")\n\nwith col5:\n    st.video(\"https://youtu.be/dQw4w9WgXcQ?feature=shared\")",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Columns</span>"
    ]
  },
  {
    "objectID": "layout_sidebar.html",
    "href": "layout_sidebar.html",
    "title": "20  Sidebar",
    "section": "",
    "text": "20.1 Collapsible Sidebars\nThe Streamlit sidebar gives us a distinct area on the left-hand side of the screen to use.\nimport streamlit as st\n\n1with st.sidebar:\n2  st.header(\"I'm a sidebar\")\n  st.write(\"We can use inputs our sidebar too.\")\n  name = st.text_input(\"What's your name?\", value=None)\n\nst.title(\"Greeting App!\")\n\n3if name is not None:\n  st.write(f\"Nice to meet you, {name}!\")\nelse:\n  st.write(\"I can't greet you until you enter your name!\")\n\n\n1\n\nWe can use the with notation along with st.sidebar to create the sidebar\n\n2\n\nWe indent the code we want to exist within the sidebar\n\n3\n\nOnce we write a line of code that is not indented, this signals the beginning of code that will just appear in the main area of the streamlit app.",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Sidebar</span>"
    ]
  },
  {
    "objectID": "layout_sidebar.html#collapsible-sidebars",
    "href": "layout_sidebar.html#collapsible-sidebars",
    "title": "20  Sidebar",
    "section": "",
    "text": "20.1.1 Collapsing, expanding and resizing the sidebar\nWhen hovering over the sidebar, we can see this arrow appear.\n\nClicking on this collapses the sidebar, making the main body of the app take up the full width.\n\nThis can be very handy - but be aware that it may make for a non-intuitive experience for your end users.\nHovering over the point where the sidebar ends and the main part of the app begins, our cursor will change to indicate that the sidebar can be resized. Clicking and dragging will allow us to make the sidebar narrower and wider, within some predefined limits.",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Sidebar</span>"
    ]
  },
  {
    "objectID": "layout_sidebar.html#alternative-sidebar-syntax",
    "href": "layout_sidebar.html#alternative-sidebar-syntax",
    "title": "20  Sidebar",
    "section": "20.2 Alternative sidebar syntax",
    "text": "20.2 Alternative sidebar syntax\nLike a lot of other layout elements, such as columns and tabs, there are multiple ways to refer to the sidebar, and which is best may depend on precisely what you are trying to do with your app.\n\nUse the with notation, as above.\n\n\nimport streamlit as st\n\nwith st.sidebar:\n2  st.header(\"I'm a sidebar\")\n  st.write(\"We can use inputs our sidebar too.\")\n  name = st.text_input(\"What's your name?\", value=None)\n\nst.title(\"Greeting App!\")\n\nif name is not None:\n  st.write(f\"Nice to meet you, {name}!\")\nelse:\n  st.write(\"I can't greet you until you enter your name!\")\n\n\n2\n\nWherever you would use a component that begins with st. (e.g. st.text(), st.number_input()), replace this with st.sidebar() (e.g. st.sidebar.text(), st.sidebar.number_input())\n\n\n\n\nThe code below is completely equivalent to the code above.\n\nimport streamlit as st\n\nst.sidebar.header(\"I'm a sidebar\")\nst.sidebar.write(\"We can use inputs our sidebar too.\")\nname = st.sidebar.text_input(\"What's your name?\", value=None)\n\nst.title(\"Greeting App!\")\n\nif name is not None:\n  st.write(f\"Nice to meet you, {name}!\")\nelse:\n  st.write(\"I can't greet you until you enter your name!\")\n\n\n\n\n\n\n\nNote\n\n\n\nYou can often mix and match the approaches within an app too - though picking one approach may be easier for the next person who interacts with your code to follow. If it’s a good way of achieving what you need to, though, then you can go ahead and do this!",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Sidebar</span>"
    ]
  },
  {
    "objectID": "layout_sidebar.html#initial-sidebar-state",
    "href": "layout_sidebar.html#initial-sidebar-state",
    "title": "20  Sidebar",
    "section": "20.3 Initial sidebar state",
    "text": "20.3 Initial sidebar state\nWhile there are not many ways to customise your sidebar from within streamlit, you can adjust whether it displays as being visible or not by default using st.set_page_config().\n\n\n\n\n\n\nTip\n\n\n\nst.set_page_config() has to be the first streamlit command you run after importing streamlit.\nYou can run other general python commands between the import and setting the page config - but you cannot, for example, use st.header() before calling st.set_page_config().\n\n\n\nimport streamlit as st\n\nst.set_page_config(initial_sidebar_state='collapsed')\n\nwith st.sidebar:\n  st.header(\"I'm a sidebar\")\n\nst.title(\"Collapsed Sidebar Demo!\")\n\nst.write(\"The sidebar in this app is closed by default. Click on the arrow in the top left of the screen to open it.\")",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Sidebar</span>"
    ]
  },
  {
    "objectID": "layout_sidebar.html#multipage-app-navigation",
    "href": "layout_sidebar.html#multipage-app-navigation",
    "title": "20  Sidebar",
    "section": "20.4 Multipage app navigation",
    "text": "20.4 Multipage app navigation\nLater in the book we discuss multipage apps, which use the sidebar by default for page navigation.\nAny things you add to your app’s sidebar will just appear below the list of pages.",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Sidebar</span>"
    ]
  },
  {
    "objectID": "layout_sidebar.html#sidebar-styling",
    "href": "layout_sidebar.html#sidebar-styling",
    "title": "20  Sidebar",
    "section": "20.5 Sidebar styling",
    "text": "20.5 Sidebar styling\n\n20.5.1 Sidebar Colour\nThe sidebar colour can be updated using Streamlit’s theming feature.\nThe colour that needs changing is the secondaryBackgroundColor in the config.toml file.\nMore detail about theming with config.toml can be found in a later chapter.\n\n\n20.5.2 Making the sidebar expander more obvious\nWith custom CSS, we can make the sidebar expander button more obvious.\n\n\n\n20.5.3 Sidebar Font colour and size\nIf using multipage apps, you may need some futher customisations to make the sidebar look good with the colour changes you make. However, more advanced customisations require using CSS.\nHere is an example where we change the default font colour of the auto-generated navigation items.\n\n\n\n\n\n\nWarning\n\n\n\nAs the streamlit library evolves, the names of various elements on the page may change, meaning that these may not remain consistent over time.\n\n\n\n# Credit to Amy H in the PenCHORD team for this!\n# https://github.com/kailo-beewell/kailo_beewell_dashboard_package/blob/be249c515d5cfd7d168abf14f03927322b72322b/kailo_beewell_dashboard/css/style.css#L2\n\nst.markdown(\n  \"\"\"\n&lt;style&gt;\n/* Sidebar font color as default is to set non-selected to more transparent */\n[data-testid=stSidebarNavItems] &gt; li &gt; div &gt; a &gt; span\n{\n    color: #05291F;\n}\n\n/* Sidebar font size */\n    [data-testid=stSidebarNavItems]\n    {\n        font-size: 25px;\n    }\n\n&lt;/style&gt;\n  \"\"\",\n  unsafe_allow_html=True\n)",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Sidebar</span>"
    ]
  },
  {
    "objectID": "layout_tabs.html",
    "href": "layout_tabs.html",
    "title": "21  Tabs",
    "section": "",
    "text": "21.1 Tabs in Streamlit\nTabs are an extremely useful way to organise your page into something that is easier to navigate.\nTabs look like this in a Streamlit app.\nimport streamlit as st\n\ntab1, tab2, tab3 = st.tabs([\"This is Tab 1\", \"This is the Second Tab\", \"Tab 3 is Here!\"])\n\nwith tab1:\n  st.header(\"I'm Tab 1\")\n  st.write(\"Here's the 'Back to the Future' poster. Images, videos, data tables and more can be displayed within tabs.\")\n  st.image(\"https://upload.wikimedia.org/wikipedia/en/d/d2/Back_to_the_Future.jpg\")\n\nwith tab2:\n  st.header(\"I'm Tab 2\")\n  st.write(\"We can use inputs within tabs too.\")\n  name = st.text_input(\"What's your name?\", value=None)\n  if name is not None:\n    st.write(f\"Nice to meet you, {name}!\")\n  else:\n    st.write(\"I can't greet you until you enter your name!\")\n\nwith tab3:\n    if name is not None:\n      st.write(f\"Hello again, {name}!\")\n      st.write(\"Isn't it cool that variables persist across different tabs? This can be really handy!\")\n      st.video(\"https://youtu.be/dQw4w9WgXcQ?feature=shared\")\n    else:\n      st.write(\"I can't greet you until you enter your name! Go back to tab 2 and do that.\")",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Tabs</span>"
    ]
  },
  {
    "objectID": "layout_tabs.html#the-two-main-syntax-options-for-streamlit-tabs",
    "href": "layout_tabs.html#the-two-main-syntax-options-for-streamlit-tabs",
    "title": "21  Tabs",
    "section": "21.2 The two main syntax options for streamlit tabs",
    "text": "21.2 The two main syntax options for streamlit tabs\nThere are two main ways to put content inside of tabs.\n\nUsing a ‘with’ statement and indenting the code that should sit within the tab.\n\n\nimport streamlit as st\ntab_a, tab_b = st.tabs([\"A Tab\", \"Another Tab\"])\n\nwith tab_a:\n    st.text(\"This is some content within tab 1\")\n\nwith tab_b:\n    st.text(\"This is some content within tab 2\")\n\n\nReplacing the st in sections like st.text() with the variable name for the given tab.\n\n\nimport streamlit as st\n\ntab_a, tab_b = st.tabs([\"A Tab\", \"Another Tab\"])\n\ntab_a.text(\"This is some content within tab 1\")\n\ntab_b.text(\"This is some content within tab 2\")\n\nThe outputs of both of these bits of code are identical!\nIt’s up to you to choose which you prefer.",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Tabs</span>"
    ]
  },
  {
    "objectID": "layout_tabs.html#automatically-generating-variable-numbers-of-tabs",
    "href": "layout_tabs.html#automatically-generating-variable-numbers-of-tabs",
    "title": "21  Tabs",
    "section": "21.3 Automatically generating variable numbers of tabs",
    "text": "21.3 Automatically generating variable numbers of tabs\nIn some instances, you may wish to reactively create a different number of tabs.\nIn this example, notice what happens to the random numbers as you change the number of tabs being generated.\n\n21.3.1 Using the ‘tab.’ syntax\n\nimport streamlit as st\nimport random\n\nnumber_of_tabs_to_create = st.number_input(\"Enter the number of tabs you want to create\", 2, 5, 3)\n\ntab_list =  st.tabs([f\"Tab {i+1}\" for i in range(number_of_tabs_to_create)])\n\nfor idx, tab in enumerate(tab_list):\n  tab.header(f\"This is tab {idx+1}\")\n  tab.write(f\"Your random number for this tab is {random.randint(0, 10)}\")\n\n\n\n\n21.3.2 Using the ‘with’ syntax\nIt’s also possible to do this using the ‘with’ syntax.\nIn this example, in every separate tab, we pull back a random wikipedia page.\n(However, due to the way this works behind the scenes, we don’t get a new page on changing the number of tabs even though the app is rerunning each time)\n\nimport streamlit as st\nimport streamlit.components.v1 as components\n\nnumber_of_tabs_to_create = st.number_input(\"Enter the number of tabs you want to create\", 2, 5, 3)\n\ntab_list =  st.tabs([f\"Tab {i+1}\" for i in range(number_of_tabs_to_create)])\n\nfor idx, tab in enumerate(tab_list):\n  with tab:\n    st.header(f\"This is tab {idx+1}\")\n    components.iframe(\"https://commons.wikimedia.org/wiki/Special:Random/File\", height=500)",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Tabs</span>"
    ]
  },
  {
    "objectID": "layout_tabs.html#custom-styling-of-tabs",
    "href": "layout_tabs.html#custom-styling-of-tabs",
    "title": "21  Tabs",
    "section": "21.4 Custom Styling of Tabs",
    "text": "21.4 Custom Styling of Tabs\nHere is an example of how to change the tab formatting.\n\n\n\n\n\n\nWarning\n\n\n\nThis is not a supported part of Streamlit - the ways in which streamlit internally names these tabs may change over time, causing this code to no longer work.\n\n\n\n# Credit to user 'Dallas on https://discuss.streamlit.io/t/customizing-the-appearance-of-tabs/48913\n\nimport streamlit as st\n\ncustom_css = \"\"\"\n&lt;style&gt;\n    .stTabs [data-baseweb=\"tab-list\"] {\n        gap: 2px;\n    }\n\n    .stTabs [data-baseweb=\"tab\"] {\n        height: 50px;\n        white-space: pre-wrap;\n        background-color: #32a852;\n        border-radius: 4px 4px 0px 0px;\n        gap: 1px;\n        padding-top: 10px;\n        padding-bottom: 10px;\n    }\n\n    .stTabs [aria-selected=\"true\"] {\n        background-color: #912a90;\n    }\n\n&lt;/style&gt;\n\"\"\"\n\nst.markdown(custom_css, unsafe_allow_html=True)\n\ntab_a, tab_b = st.tabs([\"A Tab\", \"Another Tab\"])\n\nwith tab_a:\n    st.text(\"This is some content within tab 1\")\n\nwith tab_b:\n    st.text(\"This is some content within tab 2\")",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Tabs</span>"
    ]
  },
  {
    "objectID": "layout_expander.html",
    "href": "layout_expander.html",
    "title": "22  Expanders",
    "section": "",
    "text": "22.1 Nesting expanders in other layout elements\nExpanders can sit within other layout elements.\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\n\ntab1, tab2 = st.tabs([\"Penguin Graphs\", \"Penguin Facts\"])\n\npenguins = load_penguins()\n\nwith tab1:\n\n    col1, col2 = st.columns(2)\n\n    with col1:\n        fig = px.scatter(penguins, x='bill_length_mm', y='bill_depth_mm', color=\"sex\",\n        title=f\"Penguins Dataset - Bill Length (mm) vs Bill Depth (mm), coloured by Sex\")\n\n        st.plotly_chart(fig)\n\n        with st.expander(\"Click here to see the code for the graph\"):\n            st.code(\n              \"\"\"\n              fig = px.scatter(penguins, x='bill_length_mm', y='bill_depth_mm', color=\"sex\",\n                    title=f\"Penguins Dataset - Bill Length (mm) vs Bill Depth (mm), coloured by Sex\")\n              \"\"\"\n            )\n\n    with col2:\n        fig = px.scatter(penguins, x='flipper_length_mm', y='body_mass_g', color=\"species\",\n                    title=f\"Penguins Dataset - Flipper Length (mm) vs Body Weight(g), coloured by Species\")\n\n        st.plotly_chart(fig)\n\n        with st.expander(\"Click here to see the code for the graph\"):\n            st.code(\n              \"\"\"\n              fig = px.scatter(penguins, x='flipper_length_mm', y='body_mass_g', color=\"species\",\n                    title=f\"Penguins Dataset - Flipper Length (mm) vs Body Weight(g), coloured by Species\")\n              \"\"\"\n            )\n\n    with st.expander(\"Click here to see the underlying data\"):\n        st.dataframe(penguins)\n\nwith tab2:\n    st.header(\"Penguin Facts\")\n    st.subheader(\"Gentoo Penguins\")\n\n    st.write(\n      \"\"\"\n      The gentoo penguin (JEN-too) (Pygoscelis papua) is a penguin species (or possibly a species complex) in the genus Pygoscelis, most closely related to the Adélie penguin (P. adeliae) and the chinstrap penguin (P. antarcticus). The earliest scientific description was made in 1781 by Johann Reinhold Forster with a type locality in the Falkland Islands. The species calls in a variety of ways, but the most frequently heard is a loud trumpeting, which the bird emits with its head thrown back.\n      \"\"\"\n    )\n\n    expander_video = st.expander(\"Click here to watch a penguin video\")\n    expander_video.video(\"https://www.youtube.com/watch?v=nFAK8Vj62WM\")",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Expanders</span>"
    ]
  },
  {
    "objectID": "multipage.html",
    "href": "multipage.html",
    "title": "23  Multipage Apps",
    "section": "",
    "text": "23.1 Method 1: ‘st.Page’ and ‘st.navigation’\nLet’s first take a look at the multipage app itself and explore how a multipage app behaves.\nThe recommended method for multipage apps in Streamlit is to\nIn this example, we have a folder that looks like this\nWhen starting up the app, we will simply be running streamlit run app.py from within the\nLet’s take a look at the contents of app.py\nLet’s now look at the code for one of the other pages: Interactive_Data_Explorer.py, which appears as “Interactive Data Explorer” in the sidebar of the app.\nNote that it looks like a completely standard streamlit app - in fact, this particular page could run completely fine by itself!",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Multipage Apps</span>"
    ]
  },
  {
    "objectID": "multipage.html#method-1-st.page-and-st.navigation",
    "href": "multipage.html#method-1-st.page-and-st.navigation",
    "title": "23  Multipage Apps",
    "section": "",
    "text": "Tip\n\n\n\nThe key things to take away are that\n\nvariables are not shared across different app pages\nmoving to a different page will reset the value of any inputs\n\n\n\n\n\ncreate a page that is responsible for routing users to different pages\n\nin this file, we can do additional things like set up the displayed names of each page and add icons before the page names\n\ncreate your actual pages\n\n\n\n\n\nimport streamlit as st\n\npg = st.navigation(\n    [st.Page(\"Homepage.py\", title=\"Welcome!\", icon=\":material/add_circle:\"),\n     st.Page(\"Penguin_Information.py\"),\n     st.Page(\"Penguin_Trends.py\"),\n     st.Page(\"Interactive_Data_Explorer.py\"),\n     st.Page(\"Sidebar_Theming.py\"),\n     ]\n     )\n\npg.run()\n\n\n\n\n\n\n\n\nNote\n\n\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\n\nst.title(\"Interactive Data Explorer\")\n\nst.write(\"Here, let's explore what happens to values we've input when moving to a different page.\")\n\nst.write(\"If you enter your name on this page, the rest of the page will load.\")\n\nst.write(\"Try then moving to a different page using the navigation sidebar before returning to this page.\")\n\nst.write(\"What do you notice?\")\n\nuser_name = st.text_input(\"Enter Your Name\", None)\n\nif user_name is None:\n    st.write(f\"Please enter your name to load the rest of the page\")\nelse:\n    st.write(f\"Welcome to the interactive penguin data explorer, {user_name}!\")\n\n    penguins = load_penguins()\n\n    axis_options = ['bill_length_mm', 'bill_depth_mm',\n        'flipper_length_mm', 'body_mass_g']\n\n    col_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\n    axis_options.remove(col_1)\n\n    col_2 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\n    color_factor = st.selectbox(\"Select the column to colour the chart by\",\n    [\"species\", \"sex\", \"island\"])\n\n    fig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\n    title=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\n    st.plotly_chart(fig)\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe .streamlit folder contains config.toml, which is used to set the colourscheme of the app\nThe requirements.txt file contains the required packages for the app, which will then be installed automatically when we deploy the app to the streamlit community cloud.\n\n\n\n23.1.1 Nested Sidebars\nBy modifying our main page’s code, we can create subsections within our navigation bars, which can be very helpful for more complex apps.\nimport streamlit as st\n\n1homepage = st.Page(\"Homepage.py\", title=\"Welcome!\", icon=\":material/add_circle:\")\ninfo_page = st.Page(\"Penguin_Information.py\")\ntrends_page = st.Page(\"Penguin_Trends.py\")\nexplorer_page = st.Page(\"Interactive_Data_Explorer.py\")\ntheming_page = st.Page(\"Sidebar_Theming.py\")\n\n2pg = st.navigation(\n    {\n        \"Section 1\": [homepage],\n        \"Section 2\": [info_page, trends_page],\n        \"Section 3\": [explorer_page, theming_page]\n    }\n     )\n\npg.run()\n\n1\n\nInstead of passing the st.Page calls directly into st.navigation we have created a variable per page. This isn’t strictly necessary, but makes it a lot easier to keep track of what’s going on in our use of st.navigation.\n\n2\n\nWe can",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Multipage Apps</span>"
    ]
  },
  {
    "objectID": "multipage.html#method-2-pages-subfolder",
    "href": "multipage.html#method-2-pages-subfolder",
    "title": "23  Multipage Apps",
    "section": "23.2 Method 2: ‘pages’ subfolder",
    "text": "23.2 Method 2: ‘pages’ subfolder\nOne other common way to deal with multipage apps is to have a .py file that is designed to be your main homepage, with all other pages being stored within a ‘pages’ subfolder.\nAt the time of writing, this is still used in some examples in the Streamlit documentation, so it is useful to be aware of, and it does have the benefit of being an automated way\n\n\n\n\n\n\nWarning\n\n\n\nThe subfolder has to be called pages to be picked up! You cannot rename it to something else.\n\n\nWe would start this app by running streamlit run Homepage.py when we have navigated to the same folder level as Homepage.py in our terminal.\nLet’s look at an example multipage app with 5 pages.\n\nThe structure of our app in our filesystem looks like this; in Windows explorer, this is how the files and folders appear.\n\nThe ‘pages’ folder\n\nThe numbers at the beginning of the filenames indicate the order these will appear in the sidebar.\n\n\n\n\n\n\nClick here for the code for the homepage\n\n\n\n\n\nimport streamlit as st\n\nst.set_page_config(layout=\"wide\", page_title=\"Homepage\")\n\nst.title(\"Welcome to the penguin app!\")\n\nspecies_options = [\"Gentoo\", \"Chinstrap\", \"Adelie\"]\n\nchosen_species = st.selectbox(\"Which penguin species are you interested in finding out more about?\", species_options)\n\nif chosen_species == \"Gentoo\":\n    st.write(\n        \"\"\"\n        The gentoo penguin (JEN-too) (Pygoscelis papua) is a penguin species (or possibly a species complex) in the genus Pygoscelis, most closely related to the Adélie penguin (P. adeliae) and the chinstrap penguin (P. antarcticus). The earliest scientific description was made in 1781 by Johann Reinhold Forster with a type locality in the Falkland Islands. The species calls in a variety of ways, but the most frequently heard is a loud trumpeting, which the bird emits with its head thrown back.\n        \"\"\"\n    )\nelif chosen_species == \"Chinstrap\":\n    st.write(\n        \"\"\"\nThe chinstrap penguin (Pygoscelis antarcticus) is a species of penguin that inhabits a variety of islands and shores in the Southern Pacific and the Antarctic Oceans. Its name stems from the narrow black band under its head, which makes it appear as if it were wearing a black helmet, making it easy to identify.[2] Other common names include ringed penguin, bearded penguin, and stonecracker penguin, due to its loud, harsh call.[3]\n        \"\"\"\n    )\n\nelif chosen_species == \"Adelie\":\n    st.write(\n        \"\"\"\n        The Adélie penguin (Pygoscelis adeliae) is a species of penguin common along the entire coast of the Antarctic continent, which is the only place where it is found. It is the most widespread penguin species, and, along with the emperor penguin, is the most southerly distributed of all penguins. It is named after Adélie Land, in turn, named for Adèle Dumont d'Urville, who was married to French explorer Jules Dumont d'Urville, who first discovered this penguin in 1840. Adélie penguins obtain their food by both predation and foraging, with a diet of mainly krill and fish.\n        \"\"\"\n    )\n\nst.markdown(\"*All information from wikipedia*\")\n\n\n\n\n\n\n\n\n\nClick here for the code for the second page\n\n\n\n\n\nimport streamlit as st\n\nst.write(\"Let's try loading in a variable from the previous page.\")\n\nwith st.expander(\"Click here to see the code that made the homepage\"):\n    st.code(\"\"\"\n            import streamlit as st\n\nst.set_page_config(layout=\"wide\", page_title=\"Homepage\")\n\nst.title(\"Welcome to the penguin app!\")\n\nspecies_options = [\"Gentoo\", \"Chinstrap\", \"Adelie\"]\n\nchosen_species = st.selectbox(\"Which penguin species are you interested in finding out more about?\", species_options)\n\nif chosen_species == \"Gentoo\":\n    st.write(\n        '''\n        The gentoo penguin (JEN-too) (Pygoscelis papua) is a penguin species (or possibly a species complex) in the genus Pygoscelis, most closely related to the Adélie penguin (P. adeliae) and the chinstrap penguin (P. antarcticus). The earliest scientific description was made in 1781 by Johann Reinhold Forster with a type locality in the Falkland Islands. The species calls in a variety of ways, but the most frequently heard is a loud trumpeting, which the bird emits with its head thrown back.\n        '''\n    )\nelif chosen_species == \"Chinstrap\":\n    st.write(\n        '''\nThe chinstrap penguin (Pygoscelis antarcticus) is a species of penguin that inhabits a variety of islands and shores in the Southern Pacific and the Antarctic Oceans. Its name stems from the narrow black band under its head, which makes it appear as if it were wearing a black helmet, making it easy to identify.[2] Other common names include ringed penguin, bearded penguin, and stonecracker penguin, due to its loud, harsh call.[3]\n        '''\n    )\n\nelif chosen_species == \"Adelie\":\n    st.write(\n        '''\n        The Adélie penguin (Pygoscelis adeliae) is a species of penguin common along the entire coast of the Antarctic continent, which is the only place where it is found. It is the most widespread penguin species, and, along with the emperor penguin, is the most southerly distributed of all penguins. It is named after Adélie Land, in turn, named for Adèle Dumont d'Urville, who was married to French explorer Jules Dumont d'Urville, who first discovered this penguin in 1840. Adélie penguins obtain their food by both predation and foraging, with a diet of mainly krill and fish.\n        '''\n    )\n\nst.markdown(\"*All information from wikipedia*\")\n\"\"\")\n\nst.write(\"We're going to try loading the `species_options` list in, which just contains the strings 'Gentoo', 'Adelie' and 'Chinstrap'.\")\n\nst.write(\"What we'll see is that it doesn't work and instead returns an error. This is because the variables on the other pages are completely separate and can't be accessed on this page.\")\n\nst.write(\"This is a key thing to be aware of within multipage apps. Without using things like session state, we can't use information from other pages on this page, and vice-versa\")\n\nchosen_species = st.selectbox(\"Which penguin species are you interested in finding out more about?\", species_options)\n\n\n\n\n\n\n\n\n\nClick here for the code for the third page\n\n\n\n\n\nimport streamlit as st\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\n\nst.write(\"All of the things we've learned about so far can be used within a multipage app!\")\n\nst.write(\"Just remember that each page is effectively a self-contained app - without using things like session state, we can't use information from other pages on this page, and vice-versa.\")\n\ntab1, tab2 = st.tabs([\"Penguin Graphs\", \"Video\"])\n\npenguins = load_penguins()\n\nwith tab1:\n\n    col1, col2 = st.columns(2)\n\n    with col1:\n        fig = px.scatter(penguins, x='bill_length_mm', y='bill_depth_mm', color=\"sex\",\n        title=f\"Penguins Dataset - Bill Length (mm) vs Bill Depth (mm), coloured by Sex\")\n\n        st.plotly_chart(fig)\n\n        with st.expander(\"Click here to see the code for the graph\"):\n            st.code(\n              \"\"\"\n              fig = px.scatter(penguins, x='bill_length_mm', y='bill_depth_mm', color=\"sex\",\n                    title=f\"Penguins Dataset - Bill Length (mm) vs Bill Depth (mm), coloured by Sex\")\n              \"\"\"\n            )\n\n    with col2:\n        fig = px.scatter(penguins, x='flipper_length_mm', y='body_mass_g', color=\"species\",\n                    title=f\"Penguins Dataset - Flipper Length (mm) vs Body Weight(g), coloured by Species\")\n\n        st.plotly_chart(fig)\n\n        with st.expander(\"Click here to see the code for the graph\"):\n            st.code(\n              \"\"\"\n              fig = px.scatter(penguins, x='flipper_length_mm', y='body_mass_g', color=\"species\",\n                    title=f\"Penguins Dataset - Flipper Length (mm) vs Body Weight(g), coloured by Species\")\n              \"\"\"\n            )\n\n    with st.expander(\"Click here to see the underlying data\"):\n        st.dataframe(penguins)\n\nwith tab2:\n    st.header(\"Penguin Video\")\n\n    expander_video = st.expander(\"Click here to watch a penguin video\")\n    expander_video.video(\"https://www.youtube.com/watch?v=nFAK8Vj62WM\")\n\n\n\n\n\n\n\n\n\nClick here for the code for the fourth page\n\n\n\n\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\n\nst.title(\"Interactive Data Explorer\")\n\nst.write(\"Here, let's explore what happens to values we've input when moving to a different page.\")\n\nst.write(\"If you enter your name on this page, the rest of the page will load.\")\n\nst.write(\"Try then moving to a different page using the navigation sidebar before returning to this page.\")\n\nst.write(\"What do you notice?\")\n\nuser_name = st.text_input(\"Enter Your Name\", None)\n\nif user_name is None:\n    st.write(f\"Please enter your name to load the rest of the page\")\nelse:\n    st.write(f\"Welcome to the interactive penguin data explorer, {user_name}!\")\n\n    penguins = load_penguins()\n\n    axis_options = ['bill_length_mm', 'bill_depth_mm',\n        'flipper_length_mm', 'body_mass_g']\n\n    col_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\n    axis_options.remove(col_1)\n\n    col_2 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\n    color_factor = st.selectbox(\"Select the column to colour the chart by\",\n    [\"species\", \"sex\", \"island\"])\n\n    fig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\n    title=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\n    st.plotly_chart(fig)\n\n\n\n\n\n\n\n\n\nClick here for the code for the fifth page\n\n\n\n\n\nimport streamlit as st\nimport plotly.express as px\n\nst.markdown(\n  \"\"\"\n&lt;style&gt;\n/* Sidebar font color as default is to set non-selected to more transparent */\n[data-testid=stSidebarNavItems] &gt; li &gt; div &gt; a &gt; span\n{\n    color: #05291F;\n}\n\n/* Sidebar font size */\n    [data-testid=stSidebarNavItems]\n    {\n        font-size: 20px;\n    }\n\n&lt;/style&gt;\n  \"\"\",\n  unsafe_allow_html=True\n)\n\n\nst.title(\"Sidebar Theming and Additions\")\n\nst.write(\"Finally, let's look at the impact of some custom CSS on the sidebar.\")\n\nst.write(\"We've embedded some code when the page first loads that should increase the size of the page names in the sidebar, and also make the page names in the sidebar darker.\")\n\nwith st.expander(\"Click here to view the code\"):\n    st.code(\n    '''\n&lt;style&gt;\n/* Sidebar font color as default is to set non-selected to more transparent */\n[data-testid=stSidebarNavItems] &gt; li &gt; div &gt; a &gt; span\n{\n    color: #05291F;\n}\n\n/* Sidebar font size */\n    [data-testid=stSidebarNavItems]\n    {\n        font-size: 20px;\n    }\n\n&lt;/style&gt;\n    '''\n    )\n\n\nwith st.sidebar:\n    st.write(\"Let's also explore what happens when we add additional things to the sidebar\")\n\n    st.write(\"It looks like it automatically appears below the navigation\")\n\n    num_repeats = st.slider(\"Pick a number\", 1, 50, 2)\n\n    text_repeats = st.text_input(\"Enter some text\", None)\n\n\nif text_repeats is None:\n    st.write(\"Enter some text in the box in the sidebar\")\nelse:\n    st.write(\"Here is your text repeated that many times!\")\n\n    st.write(text_repeats * num_repeats)",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Multipage Apps</span>"
    ]
  },
  {
    "objectID": "app_colours.html",
    "href": "app_colours.html",
    "title": "24  App Colours",
    "section": "",
    "text": "There are a few parts of Streamlit’s theming that we can officially change using a configuration file.\nThis file needs to be called config.toml and lives inside a subfolder called .streamlit\n\nThe config.toml file contains a variable number of parameters.\nIt can determine whether the default colourscheme is light or dark, and whether the default streamlit colours are overridden.\nYou can create a template config.toml from within streamlit, then paste the output into a config.toml file you create yourself.\n\nLet’s look at an example app.\n\n24.0.1 config.toml\n[theme]\nbase=\"light\"\nprimaryColor=\"#005EB8\"\nsecondaryBackgroundColor=\"#00e0ff\"\n\n\n24.0.2 app.py\n\nimport streamlit as st\n\nst.title('Simple Calculator App')\n\nnum_1 = st.number_input(label=\"First Number\")\n\nnum_2 = st.number_input(label=\"Second Number\")\n\noperator = st.selectbox(label=\"Operation\", options=[\"Add\", \"Subtract\", \"Multiply\", \"Divide\"])\n\nif operator == \"Add\":\n    output = num_1 + num_2\nelif operator == \"Subtract\":\n    output = num_1 - num_2\nelif operator == \"Multiply\":\n    output = num_1 * num_2\nelif operator == \"Divide\":\n    output = num_1 / num_2\n\nst.text(f\"The answer is {output}\")",
    "crumbs": [
      "Styling",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>App Colours</span>"
    ]
  },
  {
    "objectID": "logos.html",
    "href": "logos.html",
    "title": "25  Logos",
    "section": "",
    "text": "25.1 Larger logos\nIt is possible to include larger logos through more advanced tricks, but they are fragile and prone to breaking as changes are made to the Streamlit library.\nThe approach requires using some markdown to inject some custom CSS (see the fonts chapter for more details on CSS).\nHere is a reusable function you could adapt to your own use:\ndef add_logo():\n    '''\n    Add a logo at the top of the page navigation sidebar\n\n    Approach written by blackary on\n    https://discuss.streamlit.io/t/put-logo-and-title-above-on-top-of-page-navigation-in-sidebar-of-multipage-app/28213/5\n\n    '''\n    st.markdown(\n        \"\"\"\n        &lt;style&gt;\n            [data-testid=\"stSidebarNav\"] {\n                background-image: url(https://raw.githubusercontent.com/hsma-programme/Teaching_DES_Concepts_Streamlit/main/resources/hsma_logo_transparent_background_small.png);\n                background-repeat: no-repeat;\n                padding-top: 175px;\n                background-position: 40px 30px;\n            }\n            [data-testid=\"stSidebarNav\"]::before {\n                content: \"The DES Playground\";\n                padding-left: 20px;\n                margin-top: 50px;\n                font-size: 30px;\n                position: relative;\n                top: 100px;\n            }\n\n        &lt;/style&gt;\n        \"\"\",\n        unsafe_allow_html=True,\n    )\nimport streamlit as st\n\ndef add_logo():\n    '''\n    Add a logo at the top of the page navigation sidebar\n\n    Approach written by blackary on\n    https://discuss.streamlit.io/t/put-logo-and-title-above-on-top-of-page-navigation-in-sidebar-of-multipage-app/28213/5\n\n    '''\n    st.markdown(\n        \"\"\"\n        &lt;style&gt;\n            [data-testid=\"stSidebarNav\"] {\n                background-image: url(https://raw.githubusercontent.com/hsma-programme/Teaching_DES_Concepts_Streamlit/main/resources/hsma_logo_transparent_background_small.png);\n                background-repeat: no-repeat;\n                padding-top: 175px;\n                background-position: 40px 30px;\n            }\n            [data-testid=\"stSidebarNav\"]::before {\n                content: \"The DES Playground\";\n                padding-left: 20px;\n                margin-top: 50px;\n                font-size: 30px;\n                position: relative;\n                top: 100px;\n            }\n\n        &lt;/style&gt;\n        \"\"\",\n        unsafe_allow_html=True,\n    )\n\nadd_logo()\n\nst.title('Simple Calculator App')\n\nwith st.sidebar:\n  num_1 = st.number_input(label=\"First Number\")\n\n  num_2 = st.number_input(label=\"Second Number\")\n\n  operator = st.selectbox(label=\"Operation\", options=[\"Add\", \"Subtract\", \"Multiply\", \"Divide\"])\n\nif operator == \"Add\":\n    output = num_1 + num_2\nelif operator == \"Subtract\":\n    output = num_1 - num_2\nelif operator == \"Multiply\":\n    output = num_1 * num_2\nelif operator == \"Divide\":\n    output = num_1 / num_2\n\nst.text(f\"The answer is {output}\")",
    "crumbs": [
      "Styling",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Logos</span>"
    ]
  },
  {
    "objectID": "fonts.html",
    "href": "fonts.html",
    "title": "26  Fonts",
    "section": "",
    "text": "To customise the look of your app much more than this, we need to turn to custom css.\nCSS stands for ‘cascading style sheets’ and is a language used for theming much of the web!\nWe can create our own .css file and force Streamlit to load it in.\n\nTo load the file into the app, we need to include the following command:\n\nwith open(\"style.css\") as css:\n    st.markdown(f'&lt;style&gt;{css.read()}&lt;/style&gt;', unsafe_allow_html=True)\n\nThis points towards the css file and wrapss it in some HTML tags that will ensure the css is recognised by the web browser.\nThe css file can contain any valid css, but we are interested in this chapter in targeting fonts specifically.\nTo begin with, we load in a font from the Google font families.\nWe then choose some areas of this app to apply it to.\nh1, h2, h3, h4, p will target all headers and the main body text in the app.\nMore advanced or Streamlit-specific elements may be harder to target.\n@import url('https://fonts.googleapis.com/css2?family=Lexend:wght@200&display=swap');\n\nhtml, body, st-emotion-cache [class*=\"css\"] {\n    font-family: 'Lexend', sans-serif;\n    font-size: 18px;\n    font-weight: 200;\n    color: #091747;\n}\n\nh1, h2, h3, h4, p {\n    font-family: \"Lexend\", sans-serif;\n}\n\n\n\n\n\n\nTip\n\n\n\nYou can right click when running your app and choose ‘inspect’ to get an idea of the possible tags to target with your custom CSS.\nThe streamlit forums and StackOverflow are also good ways to find examples of people applying custom theming to similar things to what you are looking to do.\n\n\nHere is an example of a Streamlit title with and without the custom theming applied.\n\n\n\n\n\n\n\nTip\n\n\n\nGoogle fonts provide a good option that is easy to load in via the method above.\nYou can explore the wide range of fonts offered here:\nhttps://fonts.google.com/\nIstok Web is often cited as being the closest Google Font equivalent to the standard NHS font Frutiger.\nTo apply this, you would use\n@import url('https://fonts.googleapis.com/css2?family=Istok+Web:wght@200&display=swap');\n\nhtml, body, st-emotion-cache [class*=\"css\"] {\n    font-family: 'Istok Web', sans-serif;\n    font-size: 18px;\n    font-weight: 200;\n    color: #091747;\n}\n\nh1, h2, h3, h4, p {\n    font-family: \"Istok Web\", sans-serif;\n}",
    "crumbs": [
      "Styling",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Fonts</span>"
    ]
  },
  {
    "objectID": "partial_reruns.html",
    "href": "partial_reruns.html",
    "title": "28  Partial Reruns",
    "section": "",
    "text": "28.1 The Partial Rerun Decorator\nNow let’s rewrite this using the fragment code.\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\nimport time\n\npenguins = load_penguins()\n\napp_column_1, app_column_2 = st.columns(2)\n\naxis_options = ['bill_length_mm', 'bill_depth_mm',\n       'flipper_length_mm', 'body_mass_g']\n\n1@st.fragment()\n2def penguin_barchart():\n    time.sleep(3)\n    species = st.selectbox(\"Select a penguin species to filter by\", [\"Adelie\", \"Gentoo\", \"Chinstrap\"])\n    filtered_df_species = penguins[penguins['species'] == species]\n    st.plotly_chart(px.bar(filtered_df_species['sex'].value_counts(), y='count'))\n\n\n3@st.fragment()\ndef penguin_scatterplot():\n    time.sleep(3)\n    col_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n    axis_options.remove(col_1)\n    col_2 = st.selectbox(\"Select the column to use for the y axis\", axis_options)\n\n    color_factor = st.selectbox(\"Select the column to colour the chart by\",\n    [\"species\", \"sex\", \"island\"])\n\n    fig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\n    title=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\n    st.plotly_chart(fig)\n\n\nwith app_column_1:\n4   penguin_barchart()\n\nwith app_column_2:\n5   penguin_scatterplot()\n\n\n1\n\nWe use the @st.fragment() decorator on its own line\n\n2\n\nInstead of just creating the inputs and outputs straight in the app, we need to wrap them in a function. This function doesn’t need to return anything, and we can call it whatever we like. Note that there is no blank line between the @st.fragment() decorator and the function definition. Here, we’ve counted the select dropdown for species, the pandas dataframe filter action, and the creation of the barplot figure as being a single thing we want to rerun when any element within those three changes in a way that would trigger a rerun usually.\n\n3\n\nWe then repeat this for our next function.\n\n4\n\nUsing the with notation with the first column we created, we then call our first function.\n\n5\n\nWe then repeat this for the second column and second function.\nNotice that now when we change the parameters in the drop-down select boxes, only half of the app fades out - indicating that only half of the app is updating at a time; each half of the page can now act independently of the other.",
    "crumbs": [
      "Controlling Application Flow",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Partial Reruns</span>"
    ]
  },
  {
    "objectID": "partial_reruns.html#the-partial-rerun-decorator",
    "href": "partial_reruns.html#the-partial-rerun-decorator",
    "title": "28  Partial Reruns",
    "section": "",
    "text": "Note\n\n\n\nAs the fragments feature is so new as of writing this book, it has not yet been integrated into the library we use for displaying the example apps.\nInstead, you can view the output of this code in the embedded webpage below.",
    "crumbs": [
      "Controlling Application Flow",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Partial Reruns</span>"
    ]
  },
  {
    "objectID": "cheat_sheet.html",
    "href": "cheat_sheet.html",
    "title": "45  Streamlit Cheat Sheet",
    "section": "",
    "text": "The fantastic Streamlit Cheat Sheet is well worth bookmarking!\nhttps://cheat-sheet.streamlit.app/",
    "crumbs": [
      "Additional Resources",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Streamlit Cheat Sheet</span>"
    ]
  }
]