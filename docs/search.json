[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HSMA - Web Apps with Streamlit",
    "section": "",
    "text": "Preface\nWelcome to this book accompanying the Streamlit sessions of module 7 of the HSMA programme.\nIn this module we introduce the Streamlit framework for web app development.\nStreamlit is a popular Python web framework that allows powerful and professional looking data apps to be created in hours instead of weeks.\nIn this book, we will introduce some of the key features of Streamlit and how to start putting them together to make more complex apps.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#stlite",
    "href": "index.html#stlite",
    "title": "HSMA - Web Apps with Streamlit",
    "section": "stlite",
    "text": "stlite\nMany examples throughout this book use the stlite framework and the stlite-quarto extension, which allows running of streamlit apps directly on the browser of the reader rather than hosting each app remotely.\nThis does mean that the app examples within each page do take a while to load, and you may not want to read this book cover-to-cover if you are on, say, a mobile network - each example will load several megabytes of data to be able to render.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "HSMA - Web Apps with Streamlit",
    "section": "Acknowledgements",
    "text": "Acknowledgements\n\nDatasets\n\nName Popularity\nThe name popularity dataset used in several examples was created by\n\n\nPalmer Penguins\nThe palmer penguins dataset is loaded via the palmerpenguins library available here. Credit goes to Muhammad Chenariyan Nakhaee for the Python port, and Allison Horst, Alison Hill, and Kristen Gorman for the original dataset and R package.\nHorst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer Archipelago (Antarctica) penguin data. R package version 0.1.0. https://allisonhorst.github.io/palmerpenguins/. doi: 10.5281/zenodo.3960218.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "hello_world_streamlit.html",
    "href": "hello_world_streamlit.html",
    "title": "1  Hello World (Wide Web)!",
    "section": "",
    "text": "1.1 Previewing your app\nWhen you are writing streamlit apps from within your IDE - such as vscode - you will need to run some extra code to preview your app.\nFirst, you must make sure you save your app!\nLet’s save our app as main.py.\nThen we need to open a terminal.\nIn the terminal, we then run the command streamlit run main.py\nThis will spin up a temporary server to run your app from.\nYour app will then automatically open in a browser window in your default browser.\nIf we change and save our source file, like so…\nOur running app will recognise that there has been a change and give us the option to rerun to incorporate the new change without having to close and restart our temporary server.\nThis is really handy as it allows us to rapdily tweak and iterate our Streamlit apps!\nYou can also just use the refresh button in your browser if you would prefer.\nThe ‘always rerun’ option will mean that changes made to your source file will automatically trigger a rerun/refresh without you having to do it manually - it’s up to you if that’s something you’d prefer.",
    "crumbs": [
      "An Introduction to Streamlit",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Hello World (Wide Web)!</span>"
    ]
  },
  {
    "objectID": "hello_world_streamlit.html#knowledge-check",
    "href": "hello_world_streamlit.html#knowledge-check",
    "title": "1  Hello World (Wide Web)!",
    "section": "1.2 Knowledge Check!",
    "text": "1.2 Knowledge Check!\nWhat command do you use to run a streamlit file called main.py on your computer? run streamlit serverrun streamlit main.pystreamlit run main.pystreamlit activate\nWhat’s the standard import for the streamlit library? import streamlitimport streamlit as stfrom streamlit import stimport st as streamlit\nHow do you create a title in streamlit? st.title(Welcome to my app!)streamlit_title(‘Welcome to my app!’)st.title(‘Welcome to my app!’)title(‘Welcome to my app!’)",
    "crumbs": [
      "An Introduction to Streamlit",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Hello World (Wide Web)!</span>"
    ]
  },
  {
    "objectID": "loading_data.html",
    "href": "loading_data.html",
    "title": "2  Loading Data",
    "section": "",
    "text": "Streamlit apps are just like standard Python scripts in a lot of ways.\nThis means that most of the standard methods we are used to for loading in data files will work!\nAs people working with data, much of what we want to load in is likely to be is data in a tabular format, like an Excel file or Google Sheet.\nLet’s start by loading in and displaying a simple csv dataset.\n\n\n\n\n\n\nTip\n\n\n\nst.write() is a handy command.\nWhen you pass a variable to it, it will automatically work out a good way to display it.\nOther functions that we talk about in later chapters give you more control over exactly how data or files are displayed - but st.write() can often be a useful starting point.\n\n\n\nimport pandas as pd\nimport streamlit as st\n\nst.title(\"Loading in a data file from a publically-accessible csv\")\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\ndataframe = pd.read_csv(url)\n\nst.write(dataframe)\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn later chapters, we will learn more about loading in data, including\n\nloading in other data types, like images and videos\nallowing users to upload their own data\n‘caching’ data to prevent it being reloaded unnecessarily\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe focus of this book is on giving you the tools to create simple Streamlit apps. For this, we will mainly focus on using csv files that are stored on the web or locally, or are uploaded by users. In other cases, we will look at data that is generated by simply running the app, as in the case of discrete event simulation apps where the act of running it produces the data for the graphs and tables that we want to analyse!\nHowever, in real-world usage, there may be some instances where connecting to a database may be required to allow automated access to data without requiring it to be passed to the app, rather than relying on intermediate exports to formats like csv from the database.\nConnecting directly to a production database is certainly possible and can be done safely and securely - but beyond the scope of this book.\nIf this is your first time working with streamlit, it is highly recommended to work through the book first to learn the core concepts of streamlit apps. Building a proof of concept version of your app with a .csv export or dummy dataset can be done before worrying about the task of connecting to a data source - and often a good proof of concept will provide the motivation within your organisation to unblock the things that may make connecting to data sources difficult!\nStreamlit does provide tools and guidance around connecting to data sources for apps that are going into production; to learn more about connecting to other data sources, like SQL databases, you can take a look at this page from the streamlit documentation.\nThis page gives an overview of how to connect to a range of different SQL database types, public and private google sheets, and more.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Loading Data</span>"
    ]
  },
  {
    "objectID": "dataframes.html",
    "href": "dataframes.html",
    "title": "3  Dataframes",
    "section": "",
    "text": "3.1 st.table()\nLet’s start with st.table.\nst.table gives a basic, non-interactive table.\nThis can be useful when we don’t want users to be able to do things like sort the dataframe columns.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dataframes</span>"
    ]
  },
  {
    "objectID": "dataframes.html#st.dataframe",
    "href": "dataframes.html#st.dataframe",
    "title": "3  Dataframes",
    "section": "3.2 st.dataframe()",
    "text": "3.2 st.dataframe()\nst.dataframe gives more interactivity.\n\nA simple search functionality is available when hovering over it, as well as the option to make the table take up the full screen.\n\n\n3.2.1 The column API\nThe column configuration API is a powerful way to enhance the display of data tables in Streamlit.\nThis allows you to change the displayed column name without having to rename it via Pandas commands, but it also gives more control over how columns display.\nFor example, you can set a numeric column to include a prefix or suffix, or to add a comma to break up long numbers.\nYou can set links to be clickable, images to preview, and add things like sparklines and progress bars.\nLet’s build up a simple dataset manually so we can explore the use of some of these values.\n\n\n\n\n\n\n\nNote\n\n\n\nFor editable dataframes (covered in a later chapter), checkboxes, select dropdowns, date/time pickers and more can be integrated into the table.\n\n\nThe full documentation can be found here and is well worth a read to understand the full range of powerful options available to you via the column configuration API.\n\n\n3.2.2 Pandas stylers\nPandas has a ‘styler’ API",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dataframes</span>"
    ]
  },
  {
    "objectID": "dataframes.html#other-kinds-of-tabular-data",
    "href": "dataframes.html#other-kinds-of-tabular-data",
    "title": "3  Dataframes",
    "section": "3.3 Other kinds of tabular data",
    "text": "3.3 Other kinds of tabular data\nst.dataframe works with Pandas, PyArrow, Snowpark, pySpark, Numpy arrays, lists, sets and dictionaries.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dataframes</span>"
    ]
  },
  {
    "objectID": "dataframes.html#additional-arguments",
    "href": "dataframes.html#additional-arguments",
    "title": "3  Dataframes",
    "section": "3.4 Additional arguments",
    "text": "3.4 Additional arguments\nYou can find out more about the available options in the documentation.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Dataframes</span>"
    ]
  },
  {
    "objectID": "static_charts.html",
    "href": "static_charts.html",
    "title": "4  Static Charts",
    "section": "",
    "text": "4.1 Making use of the available space\nMany streamlit components have a parameter called use_container_width.\nWhen set to True in something like st.pyplot, it ensures the output is rescaled to use the maximum available width of the screen.\nThe parameter is set to False by default, which will result in outputs often not optimally using the available space.\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom palmerpenguins import load_penguins\n\npenguins = load_penguins()\n\nfig, ax = plt.subplots(figsize=(15,10))\nplt.scatter(x=penguins[\"body_mass_g\"], y=penguins[\"bill_length_mm\"])\nplt.title(\"Penguin Body Mass (g) versus Bill Length (mm)\")\nax.set_xlabel(\"Body Mass (g)\")\nax.set_ylabel(\"Bill Length (mm)\")\n\nst.subheader(\"use_container_width=False\")\n\nst.pyplot(fig)\n\nst.subheader(\"use_container_width=True\")\n\nst.pyplot(fig, use_container_width=True)",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Static Charts</span>"
    ]
  },
  {
    "objectID": "static_charts.html#making-use-of-the-available-space",
    "href": "static_charts.html#making-use-of-the-available-space",
    "title": "4  Static Charts",
    "section": "",
    "text": "Tip\n\n\n\nThis can become particularly valuable when we start to explore layout options like columns later in the book.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Static Charts</span>"
    ]
  },
  {
    "objectID": "interactive_charts.html",
    "href": "interactive_charts.html",
    "title": "5  Interactive Charts",
    "section": "",
    "text": "5.1 Making use of the available space\nMany streamlit components have a parameter called use_container_width.\nWhen set to True in something like st.pyplot, it ensures the output is rescaled to use the maximum available width of the screen.\nThe parameter is set to False by default, which will result in outputs often not optimally using the available space.\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\n\npenguins = load_penguins()\n\nfig = px.scatter(penguins, x='bill_length_mm', y='bill_depth_mm', color=\"sex\",\ntitle=f\"Penguins Dataset - Bill Length (mm) vs Bill Depth (mm), coloured by Sex\")\n\nst.subheader(\"use_container_width=False\")\n\nst.plotly_chart(fig)\n\nst.subheader(\"use_container_width=True\")\n\nst.plotly_chart(fig, use_container_width = True)",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Interactive Charts</span>"
    ]
  },
  {
    "objectID": "interactive_charts.html#making-use-of-the-available-space",
    "href": "interactive_charts.html#making-use-of-the-available-space",
    "title": "5  Interactive Charts",
    "section": "",
    "text": "Tip\n\n\n\nThis can become particularly valuable when we start to explore layout options like columns later in the book.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Interactive Charts</span>"
    ]
  },
  {
    "objectID": "interactive_charts.html#reacting-to-user-inputs",
    "href": "interactive_charts.html#reacting-to-user-inputs",
    "title": "5  Interactive Charts",
    "section": "5.2 Reacting to user inputs",
    "text": "5.2 Reacting to user inputs\nWhile we haven’t gone into detail about user inputs yet, here is an example of a plotly chart updating based on the options a user is selecting.\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\nfrom io import StringIO\n\npenguins = load_penguins()\n\naxis_options = ['bill_length_mm', 'bill_depth_mm',\n       'flipper_length_mm', 'body_mass_g']\n\ncol_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\naxis_options.remove(col_1)\n\ncol_2 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\ncolor_factor = st.selectbox(\"Select the column to colour the chart by\",\n[\"species\", \"sex\", \"island\"])\n\nfig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\ntitle=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\nst.plotly_chart(fig)",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Interactive Charts</span>"
    ]
  },
  {
    "objectID": "metrics.html",
    "href": "metrics.html",
    "title": "6  Metrics and Dials",
    "section": "",
    "text": "6.1 Metrics",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Metrics and Dials</span>"
    ]
  },
  {
    "objectID": "metrics.html#metrics",
    "href": "metrics.html#metrics",
    "title": "6  Metrics and Dials",
    "section": "",
    "text": "6.1.1 Layout\nBy combining metrics with st.columns, we can make better use of the screen to start building up more of a dashboard layout.\n\nimport streamlit as st\nimport plotly.express as px\nimport pandas as pd\n\n1st.set_page_config(layout=\"wide\")\n\nst.title(\"Activity Dashboard\")\n\n2col1, col2, col3 = st.columns(3)\n\n3col1.metric(label=\"Total Number of Patients Seen this Week\", value=52)\n\ncol2.metric(label=\"Number of Patients Seen this Week - South\", value=30, delta=-5)\n\ncol2.metric(label=\"Number of Patients Seen this Week - North\", value=12, delta=-7)\n\ncol3.metric(label=\"Number of Patients Seen this Year\", value=1302)\n\n4patients_seen_df = pd.DataFrame(\n  {\n    'Week': ['2021-01-01', '2021-01-08', '2021-01-15', '2021-01-22', '2021-01-29', '2021-02-05'],\n    'Patients Seen': [24, 12, 43, 23, 32, 25]\n  }\n)\n\n5st.plotly_chart(\n  px.line(patients_seen_df, x='Week', y='Patients Seen', title=\"Total Patients Seen per Week\")\n  )\n\n\n1\n\nHere, we’ve started out by setting the page config to ‘wide’. This just means that the page will use the whole width of the viewer’s screen, rather than limiting itself to the middle third.\n\n2\n\nWe set up 3 columns using the st.columns feature, unpacking them on the left-hand side of our assign (the equals sign) into three separate variables called col1, col2, col3 for easy reference (though we could call them anything!). col1 will be the leftmost column and as we haven’t specified otherwise, they will be of equal width.\n\n3\n\nWe then create our metrics, but instead of using st.metric, we use col1.metric (and so on). This is an easy shorthand to assign the resulting metric to each of the columns we’ve just created.\n\n4\n\nNow we’re just going to quickly make a dummy dataframe so that we can see the impact of putting something underneath the column layout. We wouldn’t usually build the dataframe up like this - we’d load it in from a database or csv.\n\n5\n\nNow we’re just creating a plotly chart container and putting a plotly express line chart in it. Note how rather than being inside one of the columns, it takes up the full width of the screen. This is because we’ve gone back to using st.plotly_chart instead of col1.plotly_chart or similar.\n\n\n\n\n\n\n\n6.1.2 Styling Metric Cards\nThe Streamlit Extras package provides us with options to apply a style to our metric cards.\nYou will need to pip install streamlit-extras if it’s not already installed in your environment.\n\nimport streamlit as st\nimport plotly.express as px\nimport pandas as pd\n1from streamlit_extras.metric_cards import style_metric_cards\n\nst.set_page_config(layout=\"wide\")\n\nst.title(\"Activity Dashboard\")\n\ncol1, col2, col3 = st.columns(3)\n\ncol1.metric(label=\"Total Number of Patients\\nSeen this Week\", value=52)\n\ncol2.metric(label=\"Number of Patients\\nSeen this Week - South\", value=30, delta=-5)\n\ncol2.metric(label=\"Number of Patients\\nSeen this Week - North\", value=12, delta=-7)\n\ncol3.metric(label=\"Number of Patients Seen this Year\", value=1302)\n\n2style_metric_cards(background_color=\"#6434eb\", border_color= \"#eb9234\", border_size_px=3)\n\npatients_seen_df = pd.DataFrame(\n  {\n    'Week': ['2021-01-01', '2021-01-08', '2021-01-15', '2021-01-22', '2021-01-29', '2021-02-05'],\n    'Patients Seen': [24, 12, 43, 23, 32, 25]\n  }\n)\n\nst.plotly_chart(\n  px.line(patients_seen_df, x='Week', y='Patients Seen', title=\"Total Patients Seen per Week\")\n  )\n\n\n1\n\nWe import the function style_metric_cards from streamlit_extras.metric_cards\n\n2\n\nWe then use this function after we’ve created our metric cards, passing in the relevant arguments to change the background colour, border colour, border size and more.\n\n\n\n\nFull details of all the available parameters can be found in the streamlit extras documentation\n\n\n\n\n\n\nTip\n\n\n\nThe six-character alphanumeric codes we passed into the ‘background_color’ and ‘border_color’ arguments are called hex colours and are a common way of specifying colours on computers - particularly in web development.\nThere are lots of sites to help you look up hex colours to find the perfect one for you.\nThis page from w3 schools is a starting point.\nYou can also just go to google and seach ‘hex colour picker’ to bring up an interactive picker straight away!",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Metrics and Dials</span>"
    ]
  },
  {
    "objectID": "metrics.html#indicators",
    "href": "metrics.html#indicators",
    "title": "6  Metrics and Dials",
    "section": "6.2 Indicators",
    "text": "6.2 Indicators\nTo get other sorts of displays that we might be familiar with in other dashboarding software, we may need to instead move to plotly or another graphing library rather than using things built in to Streamlit.\n\nTake a look at this documentation from plotly to see how to enhance these charts further, such as\n\nadding a target\nadding segments/reference points to the arc\nchanging the colour of the bar\n\nThis page contains additional things you can do with the indicator graph object in Plotly, such as overlaying a metric card on a plotly chart.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Metrics and Dials</span>"
    ]
  },
  {
    "objectID": "static_maps.html",
    "href": "static_maps.html",
    "title": "7  Static Maps",
    "section": "",
    "text": "7.1 Static maps\nIn the HSMA course, we have generally used the geopandas plot method - which is using matplotlib behind the scenes - to produce static maps.\nThis means that maps are simple to display as we can just use the st.pyplot() function that we used for standard matplotlib charts.\nimport geopandas\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport streamlit as st\n\nst.title(\"Crime in Devon by Type\")\n\n#########################################################\n# Read the geopandas file and create a matplotlib figure\n#########################################################\n\nlsoa_2011_crime_figures_df = geopandas.read_file(\"https://files.catbox.moe/4o0go1.gpkg\")\n\nfig = lsoa_2011_crime_figures_df.plot(column=\"sw_5forces_street_by_lsoa_Other crime\",\n                                      legend=True)\n\nst.pyplot(fig)",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Static Maps</span>"
    ]
  },
  {
    "objectID": "interactive_maps.html",
    "href": "interactive_maps.html",
    "title": "8  Interactive Maps",
    "section": "",
    "text": "8.1 Interactive maps with Folium\nFolium is an easy way to make interactive maps.\nWhile they are not natively supported in streamlit, the st-folium component is a powerful custom component that is being actively supported and developed.\nimport geopandas\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport streamlit as st\nimport folium\nfrom streamlit_folium import st_folium\n\ngp_list_gdf_sw = geopandas.read_file(\"https://files.catbox.moe/atzk26.gpkg\")\n\n# Filter out instances with no geometry\ngp_list_gdf_sw = gp_list_gdf_sw[~gp_list_gdf_sw['geometry'].is_empty]\n\n# Create a geometry list from the GeoDataFrame\ngeo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gp_list_gdf_sw.geometry]\n\ngp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i],\n            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\nst_folium(gp_map_tooltip)",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Interactive Maps</span>"
    ]
  },
  {
    "objectID": "interactive_maps.html#interactive-maps-with-folium",
    "href": "interactive_maps.html#interactive-maps-with-folium",
    "title": "8  Interactive Maps",
    "section": "",
    "text": "8.1.1 Updating the map based on inputs\nLet’s use a simple text input to filter the dataframe we are passing to the map.\nWhat happens to the map when we do this?\n\nimport geopandas\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport streamlit as st\nimport folium\nfrom streamlit_folium import st_folium\nfrom io import StringIO\n\nsearch_string = st.text_input(\"Enter a string to search the practice name field by\")\n\ngp_list_gdf_sw = geopandas.read_file(\"https://files.catbox.moe/atzk26.gpkg\")\n\n# Filter out instances with no geometry\ngp_list_gdf_sw = gp_list_gdf_sw[~gp_list_gdf_sw['geometry'].is_empty]\n\n# Filter to just the practice of interest (if given)\nif search_string is not None:\n    gp_list_gdf_sw = gp_list_gdf_sw[gp_list_gdf_sw['name'].str.contains(search_string.upper())]\n\nst.dataframe(gp_list_gdf_sw[['name', 'address_1', 'postcode', 'Total List Size']])\n\n# Create a geometry list from the GeoDataFrame\ngeo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gp_list_gdf_sw.geometry]\n\ngp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i],\n            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\nst_folium(gp_map_tooltip)\n\n\n\n\n8.1.2 Updating the app based on the map zoom\nYou can do things like filter a dataframe down to only the subset of points that are on the screen within the Folium component.\nTo find out more about this, head to the chapter Bidirectional Inputs - Charts and Maps",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Interactive Maps</span>"
    ]
  },
  {
    "objectID": "introduction_to_inputs.html",
    "href": "introduction_to_inputs.html",
    "title": "11  Basic Inputs",
    "section": "",
    "text": "11.1 Streamlit Running Order\nA key concept of Streamlit is that each time something changes, the app reruns from top to bottom.\nThis is a good thing for simple apps - but it can become problematic as your app becomes more complex and if you have things that take longer to rerun.\nLet’s make a new app that takes some different inputs.\nHere, despite the fact that the dataframe does not change between runs\nimport streamlit as st\nimport time\nimport pandas as pd\n\nst.write(\"Loading the name popularity lookup\")\ntime.sleep(3)\nst.write(\"Still Loading...\")\ntime.sleep(3)\n\nurl = 'https://www.dropbox.com/scl/fi/yxrc1ll9o3kpg5b1ekm5b/girl_boy_names_2022.csv?rlkey=eq3uv3ms5441gqxchnnom1h6b&st=d53l3q1q&dl=1'\nname_lookup = pd.read_csv(url)\nst.write(\"Done!\")\n\ninput_name = st.text_input(\"What is your name?\")\n\nboy_name_lookup = name_lookup[name_lookup[\"Boy Name\"] == input_name]\ngirl_name_lookup = name_lookup[name_lookup[\"Girl Name\"] == input_name]\n\nif len(boy_name_lookup) &gt; 0:\n    st.write(f\"{input_name} was in popularity position {boy_name_lookup[\"Rank\"].values[0]} for boys in 2022.\")\nelse:\n    st.write(f\"{input_name} was not in the most popular 1000 names for boys in 2022.\")\n\nif len(girl_name_lookup) &gt; 0:\n    st.write(f\"{input_name} was in popularity position {girl_name_lookup[\"Rank\"].values[0]} for girls in 2022.\")\nelse:\n    st.write(f\"{input_name} was not in the most popular 1000 names for girls in 2022.\")",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Basic Inputs</span>"
    ]
  },
  {
    "objectID": "introduction_to_inputs.html#streamlit-running-order",
    "href": "introduction_to_inputs.html#streamlit-running-order",
    "title": "11  Basic Inputs",
    "section": "",
    "text": "Note\n\n\n\nHere we artifically induce a wait for the loading phase so you can more clearly see the process by which the app reruns.\nYou don’t need to do this in your own apps! They will just run as fast as the code possibly can - but that can still not be fast enough if there are lots of things that need to be recalculated.\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThere are some more advanced features of Streamlit you can call upon when you want to minimize the number of code reruns that occur unnecessarily.\nWe’ll cover these - such as caching, partial reruns, activation buttons and session state - later in the book.\nFor now, it’s just important to be aware that a Streamlit app behaves a lot like a Python script - it’s almost like a frontend that reruns a script each time an input value is changed.\nThis design decision keeps the code as simple as possible - and it’s often not a big problem for simpler apps.\nStill, you will need to keep it in mind as your apps grow in complexity.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Basic Inputs</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html",
    "href": "text_numeric_and_selection_inputs.html",
    "title": "12  An Overview of Available Input Types",
    "section": "",
    "text": "12.1 Using inputs in calculations\nIn addition to text, we often want to be able to get numeric inputs from users.\nNumber boxes and sliders are two good ways to do this.\nThe benefit of this is that the resulting output can be guaranteed to be a number - unlike using a text input, where the user could choose to enter a non-numeric value which may break later steps of your app.\nLet’s take a look at how we can use these two kinds of inputs.\nimport streamlit as st\n\nst.subheader(\"Numeric Input\")\n\nchosen_number = st.number_input(\"Pick a Number\")\n\nst.write(f\"The number you have chosen is {chosen_number}\")\n\nchosen_number_multiplied_by_5 = chosen_number * 5\n\nst.write(f\"Your number multiplied by 5 is {chosen_number_multiplied_by_5}\")\n\nst.write(f\"Your number plus 7 is {chosen_number + 7}\")\n\nst.subheader(\"Numeric Slider\")\n\nchosen_number_slider = st.slider(\"Pick a Number on the slider\")\n\nst.write(f\"The number you have chosen is {chosen_number_slider}\")\n\nchosen_number_slider_multiplied_by_8 = chosen_number * 8\n\nst.write(f\"Your number multiplied by 8 is {chosen_number_slider_multiplied_by_8}\")\n\nst.write(f\"Your number plus 3 is {chosen_number_slider + 3}\")",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#other-numeric-and-date-inputs",
    "href": "text_numeric_and_selection_inputs.html#other-numeric-and-date-inputs",
    "title": "12  An Overview of Available Input Types",
    "section": "12.2 Other numeric and date inputs",
    "text": "12.2 Other numeric and date inputs",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#other-useful-input-types",
    "href": "text_numeric_and_selection_inputs.html#other-useful-input-types",
    "title": "12  An Overview of Available Input Types",
    "section": "12.3 Other useful input types",
    "text": "12.3 Other useful input types\nLet’s have a very quick look at some of the other inputs available to us within Streamlit.\nThe desired type of the output will be inferred from the default value you pass into the slider.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#selection-inputs",
    "href": "text_numeric_and_selection_inputs.html#selection-inputs",
    "title": "12  An Overview of Available Input Types",
    "section": "12.4 Selection inputs",
    "text": "12.4 Selection inputs\nSelection inputs are a very useful class of inputs. They allow you to give users a distinct number of options to choose from.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#other-useful-inputs",
    "href": "text_numeric_and_selection_inputs.html#other-useful-inputs",
    "title": "12  An Overview of Available Input Types",
    "section": "12.5 Other useful inputs",
    "text": "12.5 Other useful inputs\nThe final inputs we’ll take a quick look at are checkbox and toggle inputs.\nThese are useful as they return boolean values - True or False.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#additional-input-types-not-covered-here",
    "href": "text_numeric_and_selection_inputs.html#additional-input-types-not-covered-here",
    "title": "12  An Overview of Available Input Types",
    "section": "12.6 Additional Input Types Not Covered Here",
    "text": "12.6 Additional Input Types Not Covered Here\nYou can always refer to the excellent Streamlit documentation to see what other input widgets are available.\nNew official ones are sometimes added, and there are additional ones made by the community that become available over time.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#next-steps-with-inputs",
    "href": "text_numeric_and_selection_inputs.html#next-steps-with-inputs",
    "title": "12  An Overview of Available Input Types",
    "section": "12.7 Next steps with inputs",
    "text": "12.7 Next steps with inputs\nIn the rest of this section, we’ll look at some of the parameters for inputs that will allow you to refine what your users will be allowed to enter, improving the usability of your app (and reducing the number of edge cases you need to account for in your programming!).",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "file_uploads.html",
    "href": "file_uploads.html",
    "title": "13  File Uploads",
    "section": "",
    "text": "13.1 A simple csv file upload\nLet’s start off by asking the user to upload any csv file of data.\nWe’ll then display some summary details about their dataframe and the first five values from each column.\nRight click on the following link and choose ‘save as’ to download a sample file you can use in the following app: file\nimport streamlit as st\nimport pandas as pd\n\nuploaded_file = st.file_uploader(\"Please upload a data file\")\n\nif uploaded_file is not None:\n    uploaded_df = pd.read_csv(uploaded_file)\n\n    st.write(f\"Your dataframe has {len(uploaded_df)} rows.\")\n\n    st.write(f\"Your dataframe has {len(uploaded_df.columns)} columns.\")\n\n    st.write(f\"The columns in your dataframe are {', '.join(uploaded_df.columns)}.\")\n\n    for col in uploaded_df.columns:\n        st.write(f\"The first 5 values in column {col} are {', '.join(uploaded_df[col].head().astype('str'))}\")",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>File Uploads</span>"
    ]
  },
  {
    "objectID": "file_uploads.html#a-simple-csv-file-upload",
    "href": "file_uploads.html#a-simple-csv-file-upload",
    "title": "13  File Uploads",
    "section": "",
    "text": "Note\n\n\n\nThe key thing to notice here is that we have two steps to getting a usable csv file for our next steps:\n\nsave the output of st.file_uploader() to a variable\nread this output using the pd.read_csv() method\n\n\n\n\n\n\n13.1.1 Limiting the file types\nBy default, we haven’t restricted the file types that can be uploaded.\nLet’s do that now!\n\nimport streamlit as st\nimport pandas as pd\n\nuploaded_file = st.file_uploader(\"Please upload a csv data file\", type=['csv'])\n\nif uploaded_file is not None:\n    uploaded_df = pd.read_csv(uploaded_file)\n\n    st.write(uploaded_df.head())\n\n\nThe app will try to prevent us from uploading the wrong type of file by only showing the correct type of file in our file explorer.\n\nIf we now try to upload a file with a different extension, we’ll receive a more user-friendly error message.\n\nIf we passed more possible extensions to the list, we would allow more extensions to be uploaded - but we’d also have to adapt our code to deal with each of the possible types that can be uploaded!",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>File Uploads</span>"
    ]
  },
  {
    "objectID": "file_uploads.html#uploading-image-files",
    "href": "file_uploads.html#uploading-image-files",
    "title": "13  File Uploads",
    "section": "13.2 Uploading image files",
    "text": "13.2 Uploading image files\nWe can easily upload image files too.\nLet’s try loading an image file and displaying it for the user.\n\nimport streamlit as st\n\nuploaded_image = st.file_uploader(\"Please upload an image file\", type=['png','jpg','jpeg','bmp', 'bitmap'])\n\nif uploaded_image is not None:\n\n    st.image(uploaded_image)\n\n\n\n13.2.1 Manipulating uploaded image files\nWe have to undertake a few extra steps to be able to manipulate image files people have uploaded.\nWe’ll be using the pillow library (referred to as PIL in code) - but it expects the image to be converted to a series of bytes first.\nOnce we’ve adjusted the image into the format pillow expects, we can use the library to run a range of edits and enhancements to our image.\n\n\n\n\n\n\nTip\n\n\n\nThe code below shows just a couple of the things pillow (PIL) can do - take a look at the documentation to find more!\n\n\nLet’s have a go at it here.\n\nimport streamlit as st\nimport io\nfrom PIL import Image, ImageEnhance\nimport PIL.ImageOps\n\nuploaded_image = st.file_uploader(\"Please upload an image file\", type=['png','jpg','jpeg','bmp', 'bitmap'])\n\nif uploaded_image is not None:\n\n    imagefile = io.BytesIO(uploaded_image.read())\n\n    im = Image.open(imagefile)\n\n    threshold = st.slider(\"Choose a threshold\", 1, 100, value=80, step=1)\n    contrast_factor = st.slider(\"Contrast Enhancement Strength\", 0.0, 2.0, value=1.0, step=0.05)\n    invert = st.checkbox(\"Invert Output Image?\")\n\n    enhancer = ImageEnhance.Contrast(im)\n    img_edited = enhancer.enhance(contrast_factor)\n\n    img_edited = img_edited.convert(\"L\").point(\n        lambda x: 255 if x &gt; threshold else 0\n    )\n\n    if invert:\n        img_edited = PIL.ImageOps.invert(img_edited)\n\n    st.write(\"Original Image\")\n    st.image(uploaded_image)\n\n    st.write(\"Edited Image\")\n    st.image(img_edited)\n\n\n\n\n\n\n\n\nBackground removal\n\n\n\nWe could take this even further with the rembg library, which removes the image’s background.\nWe can’t demonstrate this interactively on this page, but the code below would work for a standard streamlit app run or hosted locally, or on streamlit community cloud.\nIt doesn’t work with stlite/browser-based Python due to dependencies of the rembg library that are unavailable via that method.\n\nimport streamlit as st\nimport io\nfrom PIL import Image\nfrom rembg import remove\n\nuploaded_image = st.file_uploader(\"Please upload an image file\", type=['png','jpg','jpeg','bmp', 'bitmap'])\n\nif uploaded_image is not None:\n\n    imagefile = io.BytesIO(uploaded_image.read())\n\n    im = Image.open(imagefile)\n\n    img_edited = remove(im)\n\n    st.write(\"Original Image\")\n    st.image(uploaded_image)\n\n    st.write(\"Edited Image\")\n    st.image(img_edited)\n\n2024-08-20 10:18:16.707 \n  Warning: to view this Streamlit app on a browser, run it with the following\n  command:\n\n    streamlit run c:\\HSMA\\streamlit_book\\.venv\\Lib\\site-packages\\ipykernel_launcher.py [ARGUMENTS]",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>File Uploads</span>"
    ]
  },
  {
    "objectID": "bidirectional_plots_and_maps.html",
    "href": "bidirectional_plots_and_maps.html",
    "title": "15  Bidirectional Inputs - Dataframes, Charts and Maps",
    "section": "",
    "text": "15.1 Dataframes\nIn the case of dataframes, maybe we want to allow users to easily select a subset of rows to be plotted on a graph or map, or use this subset of rows to calculate some summary statistics.\nLet’s load in the penguins dataset.\nNotice that we have now saved the output of st.dataframe to a variable, and also added the parameter on_select=\"rerun\".\nBefore we start filtering by what is returned, let’s first just see what actually is returned and explore how this updates.\nWe can then use the selected row indices to restrict the rows we use for subsequent calculations.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bidirectional Inputs - Dataframes, Charts and Maps</span>"
    ]
  },
  {
    "objectID": "bidirectional_plots_and_maps.html#dataframes",
    "href": "bidirectional_plots_and_maps.html#dataframes",
    "title": "15  Bidirectional Inputs - Dataframes, Charts and Maps",
    "section": "",
    "text": "Tip\n\n\n\nNote that selecting a subset of cells like this is not sufficient.\n\nYou must select the full rows using the dataset column at the far left, to the left of the index column if displayed.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe selection_mode parameter can be passed to st.dataframe to allow selection of single or multiple rows, single or multiple columns, or some combination of the two.\nNote that enabling column selection disables column sorting.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bidirectional Inputs - Dataframes, Charts and Maps</span>"
    ]
  },
  {
    "objectID": "bidirectional_plots_and_maps.html#graphs",
    "href": "bidirectional_plots_and_maps.html#graphs",
    "title": "15  Bidirectional Inputs - Dataframes, Charts and Maps",
    "section": "15.2 Graphs",
    "text": "15.2 Graphs\nStreamlit also supports monitoring st.plotly_chart, st.altair_chart, and st.vega_lite_chart for point selections and using this as an input for further actions.\n\n\n\n\n\n\nNote\n\n\n\nIn this book we focus on the use of plotly; take a look at the Streamlit documentation to see how this could work with the Altair and Vega Lite plotting libraries instead.\n\n\nWhen hovering over the plot, users are given options such as ‘box select’ (to choose a box-shaped subset of points) or lasso select (to select an irregular set of points.)\n\nLet’s start by creating a scatterplot of the penguins dataset.\nNotice that we have now saved the output of st.plotly_chart to a variable, and also added the parameter on_select=\"rerun\".\n\nNow let’s see how we could use this to update some outputs.\n\n\n\n\n\n\n\nWarning\n\n\n\nHere, we’ve just chosen a very simple example where there is no colour applied to the points in the graph.\nIf the color parameter is passed to px.scatter then the resulting point indices are related to the rows for that colour only - e.g. if we coloured by the species, then a point_index parameter of 139 wouldn’t relate back to an index of 139 in the original dataset - it would be point 139 for that particular species.\nAlways explore and test the outputs of your filtering carefully to ensure it’s returning what you think it’s returning!\nAs of the time of writing (August 2024), this feature is quite new and there are not many examples of more advanced usage of it.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bidirectional Inputs - Dataframes, Charts and Maps</span>"
    ]
  },
  {
    "objectID": "bidirectional_plots_and_maps.html#sec-maps",
    "href": "bidirectional_plots_and_maps.html#sec-maps",
    "title": "15  Bidirectional Inputs - Dataframes, Charts and Maps",
    "section": "15.3 Maps",
    "text": "15.3 Maps\nFor maps, we need to use the external streamlit_folium library, which must be installed via pip before use - it doesn’t come bundled with Streamlit itself.\n\n15.3.1 Filtering with the bidirectional Folium Component\nWhen using this component, data is constantly being returned as the map is updated.\nLet’s take a look at what is being returned as the map is updated.\n\nimport geopandas\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport streamlit as st\nimport folium\nfrom streamlit_folium import st_folium\nfrom io import StringIO\n\ngp_list_gdf_sw = geopandas.read_file(\"https://files.catbox.moe/atzk26.gpkg\")\n\n# Filter out instances with no geometry\ngp_list_gdf_sw = gp_list_gdf_sw[~gp_list_gdf_sw['geometry'].is_empty]\n\n# Create a geometry list from the GeoDataFrame\ngeo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gp_list_gdf_sw.geometry]\n\ngp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i],\n            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\nreturned_map_data = st_folium(gp_map_tooltip)\n\nst.write(returned_map_data)\n\n\n\n15.3.1.1 Using the returned data\nLet’s get the bounds of the map to filter a dataframe to just contain the points within the area the user has zoomed to.\n\nimport geopandas\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport streamlit as st\nimport folium\nfrom streamlit_folium import st_folium\n\ngp_list_gdf_sw = geopandas.read_file(\"https://files.catbox.moe/atzk26.gpkg\")\n\n# Filter out instances with no geometry\ngp_list_gdf_sw = gp_list_gdf_sw[~gp_list_gdf_sw['geometry'].is_empty]\n\n# Create a geometry list from the GeoDataFrame\ngeo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gp_list_gdf_sw.geometry]\n\ngp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i],\n            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\nreturned_map_data = st_folium(gp_map_tooltip)\n\nxmin = returned_map_data['bounds']['_southWest']['lng']\nxmax = returned_map_data['bounds']['_northEast']['lng']\nymin = returned_map_data['bounds']['_southWest']['lat']\nymax =  returned_map_data['bounds']['_northEast']['lat']\ngp_list_gdf_filtered = gp_list_gdf_sw.cx[xmin:xmax, ymin:ymax]\n\nst.write(f\"Returning data for {len(gp_list_gdf_filtered)} practices\")\n\nst.dataframe(gp_list_gdf_filtered[['name', 'address_1', 'postcode', 'Total List Size']])",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bidirectional Inputs - Dataframes, Charts and Maps</span>"
    ]
  },
  {
    "objectID": "file_downloads_tabular.html",
    "href": "file_downloads_tabular.html",
    "title": "16  Downloading tabular files",
    "section": "",
    "text": "16.1 Saving pandas dataframes\nFor now, we’ll assume the tabular data you want to save is in a pandas dataframe.\nThis will usually be the case - or it will be data you can easily transform into a pandas dataframe, like a numpy array.\nLet’s start with an app that has some data on the popularity of names.\nThis app currently just loads in a dataset, does some simple manipulations, then returns the names that appeared most frequently in the dataset.",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Downloading tabular files</span>"
    ]
  },
  {
    "objectID": "file_downloads_tabular.html#saving-pandas-dataframes",
    "href": "file_downloads_tabular.html#saving-pandas-dataframes",
    "title": "16  Downloading tabular files",
    "section": "",
    "text": "16.1.1 Saving as csv or excel file\nIf a dataframe is displayed using the standard st.dataframe() command or the st.write() command, a csv download option will become visible when hovering over the dataframe.\n\nimport streamlit as st\nimport pandas as pd\nimport plotly.express as px\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\nname_lookup_df = pd.read_csv(url).melt(id_vars=[\"Name\", \"Gender\"]).dropna().rename(\n    columns={\"variable\": \"Year\", \"value\": \"Rank\"}\n    )\n\nnames_appearing_most_years = pd.DataFrame(name_lookup_df['Name'].value_counts())\n\nst.dataframe(names_appearing_most_years)\n\n\n\n16.1.1.1 Adding download buttons\nHowever, often we may only be displaying a graph of the data rather than displaying the data as well, or we may want to provide downloads of data files slightly different to the ones we are displaying - for example, ones with more or less columns, or providing the raw data instad of the summarised data we are displaying.\nWhen this is the case, we can instead provide download buttons to allow any python dataframe in our app’s running environment to be downloaded.\nThis is also just a bit more visible than the default .csv download button in streamlit dataframes, which is easy for your end users to miss.\n\n16.1.1.1.1 CSV files\nCSV files are relatively simple to provide a download for.\nThe key steps are\n\nuse the .to_csv() method on the dataframe without providing an output filepath\nencode this object as utf-8 using the .encode() method\npass the output of this code to the download button as the data parameter\n(OPTIONAL) provide a default file name for the resulting csv - you may want to use an f-string to intelligently provide a filename if the data is reflecting options the user has chosen\n(OPTIONAL) Specify the MIME type of the data as \"text/csv\" - an automatic value will be inferred from the data type, but it is better practice to more explicitly specify it like this\n\n\nimport streamlit as st\nimport pandas as pd\nimport plotly.express as px\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\nname_lookup_df = pd.read_csv(url)\n\nname_lookup_df = name_lookup_df.melt(id_vars=[\"Name\", \"Gender\"]).dropna().rename(\n    columns={\"variable\": \"Year\", \"value\": \"Rank\"}\n    )\n\nname_lookup_df['Year'] = name_lookup_df['Year'].astype('int64')\nname_lookup_df['Rank'] = name_lookup_df['Rank'].astype('int64')\n\ninput_name = st.text_input(\"What name would you like to lookup?\", value=\"Daniel\")\n\nindividual_df = name_lookup_df[name_lookup_df['Name'] == input_name]\n\nif input_name is not None:\n\n    st.plotly_chart(\n        px.line(individual_df,\n                y=\"Rank\", x=\"Year\", color=\"Gender\",\n                range_y=[1000, 0], range_x=[1920, 2022],\n                markers=True)\n                )\n\nst.download_button(\n   \"Click here to download the dataframe as a csv file\",\n   individual_df.to_csv(index=False).encode('utf-8'),\n   f\"{input_name}_historical_popularity.csv\",\n   \"text/csv\")\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhen using plotly, users can hover over the plot and choose ‘Download plot as a png’.\n\n\n\n\n\n16.1.1.1.2 Excel Files\nIt is slightly more complex to set up the download of a dataframe as an Excel file.\nHowever, this does have the benefit of being something your end users will be more familiar with - and with advanced usage of the xlsxwriter library that we’ll make use of, it allows us to add in multiple worksheets to a single file.\n\nimport streamlit as st\nimport pandas as pd\nimport plotly.express as px\nimport xlsxwriter\nfrom io import BytesIO\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\nname_lookup_df = pd.read_csv(url)\n\nname_lookup_df = name_lookup_df.melt(id_vars=[\"Name\", \"Gender\"]).dropna().rename(\n    columns={\"variable\": \"Year\", \"value\": \"Rank\"}\n    )\n\nname_lookup_df['Year'] = name_lookup_df['Year'].astype('int64')\nname_lookup_df['Rank'] = name_lookup_df['Rank'].astype('int64')\n\ninput_name = st.text_input(\"What name would you like to lookup?\", value=\"Daniel\")\n\nindividual_df = name_lookup_df[name_lookup_df['Name'] == input_name]\n\nif input_name is not None:\n\n    st.plotly_chart(\n        px.line(individual_df,\n                y=\"Rank\", x=\"Year\", color=\"Gender\",\n                range_y=[1000, 0], range_x=[1920, 2022],\n                markers=True)\n                )\n\noutput = BytesIO()\n\nwriter = pd.ExcelWriter(output, engine='xlsxwriter')\n\nindividual_df.to_excel(writer, sheet_name=f\"{input_name} Data\", index=False)\nname_lookup_df.to_excel(writer, sheet_name=f\"Full Data\", index=False)\n\nwriter.close()\n\nst.download_button(\n   \"Click here to download the dataframe as an Excel file\",\n   data = output.getvalue(),\n   file_name=f\"{input_name}_historical_popularity.xlsx\",\n   mime=\"application/vnd.ms-excel\"\n)",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Downloading tabular files</span>"
    ]
  },
  {
    "objectID": "file_downloads_images_charts.html",
    "href": "file_downloads_images_charts.html",
    "title": "17  Downloading Images and Charts",
    "section": "",
    "text": "17.0.1 Matplotlib\nWe can provide two possible ways of downloading the output of a matplotlib plot.\nThe first involves saving the resulting plot to a file, then serving that file to the user.\n\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom palmerpenguins import load_penguins\n\npenguins = load_penguins()\n\nfig, ax = plt.subplots(figsize=(15,10))\nplt.scatter(x=penguins[\"body_mass_g\"], y=penguins[\"bill_length_mm\"])\nplt.title(\"Penguin Body Mass (g) versus Bill Length (mm)\")\nax.set_xlabel(\"Body Mass (g)\")\nax.set_ylabel(\"Bill Length (mm)\")\n\nst.pyplot(fig)\n\nfilename = 'penguins_scatter_method_1.png'\nplt.savefig(filename)\nwith open(filename, \"rb\") as img:\n    btn = st.download_button(\n        label=\"Download image\",\n        data=img,\n        file_name=filename,\n        mime=\"image/png\"\n    )\n\n\nThe second involves saving the image to tempory memory, then serving that instead.\n\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom palmerpenguins import load_penguins\nfrom io import BytesIO\n\npenguins = load_penguins()\n\nfig, ax = plt.subplots(figsize=(15,10))\nplt.scatter(x=penguins[\"body_mass_g\"], y=penguins[\"bill_length_mm\"])\nplt.title(\"Penguin Body Mass (g) versus Bill Length (mm)\")\nax.set_xlabel(\"Body Mass (g)\")\nax.set_ylabel(\"Bill Length (mm)\")\n\nst.pyplot(fig)\n\nimg = BytesIO()\nplt.savefig(img)\n\nbtn = st.download_button(\n    label=\"Download image\",\n    data=img,\n    file_name='penguins_scatter_method_2.png',\n    mime=\"image/png\"\n)\n\n\n\n17.0.1.1 Wordcloud Example\nThe popular wordcloud package is actually using matplotlib for its plotting!\nThis means that the same approach works for saving a wordcloud.\nHere, we are just showing the approach of saving and then serving the image - both to display it in the app and to offer it up to the end user for download.\n\nimport streamlit as st\nfrom wordcloud import WordCloud, STOPWORDS\nimport string\nimport matplotlib.pyplot as plt\n\nstopwords = set(STOPWORDS)\n\ndef make_wordcloud(text_input):\n    tokens = text_input.split()\n    punctuation_mapping_table = str.maketrans('', '', string.punctuation)\n    tokens_stripped_of_punctuation = [token.translate(punctuation_mapping_table)\n                                  for token in tokens]\n    lower_tokens = [token.lower() for token in tokens_stripped_of_punctuation]\n\n    joined_string = (\" \").join(lower_tokens)\n\n    wordcloud = WordCloud(width=1800,\n                      height=1800,\n                      background_color='white',\n                      stopwords=stopwords,\n                      min_font_size=20).generate(joined_string)\n\n    plt.figure(figsize=(30,40))\n    # Turn off axes\n    plt.axis(\"off\")\n    # Then use imshow to plot an image (here, our wordcloud)\n    plt.imshow(wordcloud)\n    # The easiest way to do this today is to save the image and reload it\n    # This works during local testing but would also work if we deployed this\n    plt.savefig(\"wordcloud.png\")\n\nsample_text = \"\"\"\nPenguins are a group of aquatic flightless birds from the family Spheniscidae of the order Sphenisciformes. They live almost exclusively in the Southern Hemisphere: only one species, the Galápagos penguin, is found north of the Equator. Highly adapted for life in the ocean water, penguins have countershaded dark and white plumage and flippers for swimming. Most penguins feed on krill, fish, squid and other forms of sea life which they catch with their bills and swallow whole while swimming. A penguin has a spiny tongue and powerful jaws to grip slippery prey.\n\nThey spend about half of their lives on land and the other half in the sea. The largest living species is the emperor penguin (Aptenodytes forsteri): on average, adults are about 1.1 m (3 ft 7 in) tall and weigh 35 kg (77 lb). The smallest penguin species is the little blue penguin (Eudyptula minor), also known as the fairy penguin, which stands around 30–33 cm (12–13 in) tall and weighs 1.2–1.3 kg (2.6–2.9 lb). Today, larger penguins generally inhabit colder regions, and smaller penguins inhabit regions with temperate or tropical climates. Some prehistoric penguin species were enormous: as tall or heavy as an adult human. There was a great diversity of species in subantarctic regions, and at least one giant species in a region around 2,000 km south of the equator 35 mya, during the Late Eocene, a climate decidedly warmer than today.\n\"\"\"\n\nyour_text = st.text_area(label=\"Enter your text here\", value=sample_text)\n\nmake_wordcloud(text_input=your_text)\n\nst.image(\"wordcloud.png\")\n\nwith open(\"wordcloud.png\", \"rb\") as file:\n    btn = st.download_button(\n        label=\"Click Here to Download Your Word Cloud!\",\n        data=file,\n        file_name=\"my_wordcloud.png\",\n        mime=\"image/png\",\n    )\n\n\n\n\n\n17.0.2 Seaborn\nSaving the file and then serving this is a good way to work with seaborn as well.\n\n\n\n\n17.0.3 Plotly\nPlotly is a bit different because the plots it produces are interactive.\n\n17.0.3.1 Built-in method for downloading static plots\nWhen using plotly, users can hover over the plot and choose ‘Download plot as a png’.\n\n\n\n17.0.3.2 Downloading the interactive plots\nWe can once again use StringIO to save the chart html temporarily to memory, then write that to a html file when the user clicks on a download button.\nThe resulting file is completely self-contained and can even be used offline. The file could be emailed or placed on a shared site like sharepoint or google drive and would work - though sometimes it requires the user to download the html file to their own machine for it to display correctly rather than just previewing the underlying html data, depending on the platform.\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\nfrom io import StringIO\n\npenguins = load_penguins()\n\naxis_options = ['bill_length_mm', 'bill_depth_mm',\n       'flipper_length_mm', 'body_mass_g']\n\ncol_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\naxis_options.remove(col_1)\n\ncol_2 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\ncolor_factor = st.selectbox(\"Select the column to colour the chart by\",\n[\"species\", \"sex\", \"island\"])\n\nfig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\ntitle=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\nst.plotly_chart(fig)\n\nbuffer = StringIO()\nfig.write_html(buffer)\n\nst.download_button(\n    label='Download This Plot as an Interactive HTML file',\n    data=buffer,\n    file_name=f'{col_1}_vs_{col_2}_by_{color_factor}.html',\n    mime='text/html'\n)\n\n\n\n\n17.0.3.3 Static outputs with a download button\nWith some additional libraries, it becomes possible to output static images when using plotly, which can give you additional control over things like the filetype and filename.\nIt requires an additional library called kaleido to be installed.\nMore about the process can be found in the Plotly documentation.\nLINK\nFor our purposes, it is perhaps quicker and more efficient to use the StringIO buffer again, so we will use to_image() instead of save_image().\nOur code would look like this.\n\n\n\n\n\n\nWarning\n\n\n\nThe kaleido library is not possible to use with stlite, so we cannot provide an interactive demo here.\n\n\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\nfrom io import StringIO\n# the kaleido package must also be installed in the environment for the saving of static plots\n# to work\npenguins = load_penguins()\n\naxis_options = ['bill_length_mm', 'bill_depth_mm',\n       'flipper_length_mm', 'body_mass_g']\n\ncol_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\naxis_options.remove(col_1)\n\ncol_2 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\ncolor_factor = st.selectbox(\"Select the column to colour the chart by\",\n[\"species\", \"sex\", \"island\"])\n\nfig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\ntitle=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\nfig.write_image(\"temp.png\", engine=\"kaleido\")\nst.plotly_chart(fig)\n\nwith open(\"temp.png\", \"rb\") as img:\n    btn = st.download_button(\n        label='Download This Plot as an Static Image File',\n        data=fig.to_image(engine='kaleido'),\n        file_name=f'{col_1}_vs_{col_2}_by_{color_factor}.png',\n        mime='img/png'\n    )\n\n\n\n\n\n\n\nImportant\n\n\n\nkaleido and streamlit seem to negatively interact sometimes, with the download button generating indefinitely.\nAt present, I’m not aware of a fix for this issue!",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Downloading Images and Charts</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps_static.html",
    "href": "file_downloads_maps_static.html",
    "title": "18  Downloading Static Maps",
    "section": "",
    "text": "18.1 Maps\nWhile there are various other libraries available for displaying maps in Python and Streamlit, we are going to focus on the two we used in module 3 of the HSMA course\nFor more of a reminder on how to work with geographic data and create maps, you can refer to the HSMA geographic modelling and visualisation book.",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Downloading Static Maps</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps_static.html#maps",
    "href": "file_downloads_maps_static.html#maps",
    "title": "18  Downloading Static Maps",
    "section": "",
    "text": "matplotlib (which creates static maps)\nfolium (which creates a leaflet.js interactive map)",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Downloading Static Maps</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps_static.html#downloading-static-maps-made-with-matplotlib",
    "href": "file_downloads_maps_static.html#downloading-static-maps-made-with-matplotlib",
    "title": "18  Downloading Static Maps",
    "section": "18.2 Downloading Static Maps Made With Matplotlib",
    "text": "18.2 Downloading Static Maps Made With Matplotlib\nLet’s just start by plotting a map.\n\n\n18.2.0.1 A map with subplots\nStatic maps with subplots are much the same - you are just interested in saving the fig object to a temporary .png image file before then serving that temporary file to the user.\n\n\n\n18.2.0.2 Multiple Separate Maps\nWhat if we want to create several different maps instead of using the subplot feature?\nWe could do this and then provide a download button for each.",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Downloading Static Maps</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps_interactive.html",
    "href": "file_downloads_maps_interactive.html",
    "title": "19  Downloading Interactive Maps",
    "section": "",
    "text": "19.0.1 Folium\nInteractive maps can be created using the Folium package.\nFolium maps cannot be displayed in Streamlit by default, but can be imported using the st-folium custom component.\nOne way to provide them as downloadable objects is to save the html object temporarily, then pass this to our download button, similar to some of the other downloads we have created.\n\nimport geopandas\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport streamlit as st\nimport folium\nfrom streamlit_folium import st_folium\n\ngp_list_gdf_sw = geopandas.read_file(\"https://files.catbox.moe/atzk26.gpkg\")\n\n# Filter out instances with no geometry\ngp_list_gdf_sw = gp_list_gdf_sw[~gp_list_gdf_sw['geometry'].is_empty]\n\n# Create a geometry list from the GeoDataFrame\ngeo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gp_list_gdf_sw.geometry]\n\ngp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i],\n            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\nst_folium(gp_map_tooltip)\n\ngp_map_tooltip.save(\"gp_map_devon.html\")\n\nwith open(\"gp_map_devon.html\", \"rb\") as map_file_html:\n    st.download_button(\n        label='Download This Map as an Interactive HTML file',\n        data=map_file_html,\n        file_name=f'Devon GP Map.html',\n        mime='text/html'\n    )",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Downloading Interactive Maps</span>"
    ]
  },
  {
    "objectID": "layout_columns.html",
    "href": "layout_columns.html",
    "title": "20  Columns",
    "section": "",
    "text": "Streamlit has a very easy to use column interface for improving the layout of your apps.\n```{}",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Columns</span>"
    ]
  },
  {
    "objectID": "layout_tabs.html",
    "href": "layout_tabs.html",
    "title": "22  Tabs",
    "section": "",
    "text": "22.1 Tabs in Streamlit\nTabs are an extremely useful way to organise your page into something that is easier to navigate.\nTabs look like this in a Streamlit app.\nimport streamlit as st\n\ntab1, tab2, tab3 = st.tabs([\"This is Tab 1\", \"This is the Second Tab\", \"Tab 3 is Here!\"])\n\nwith tab1:\n  st.header(\"I'm Tab 1\")\n  st.write(\"Here's the 'Back to the Future' poster. Images, videos, data tables and more can be displayed within tabs.\")\n  st.image(\"https://upload.wikimedia.org/wikipedia/en/d/d2/Back_to_the_Future.jpg\")\n\nwith tab2:\n  st.header(\"I'm Tab 2\")\n  st.write(\"We can use inputs within tabs too.\")\n  name = st.text_input(\"What's your name?\", value=None)\n  if name is not None:\n    st.write(f\"Nice to meet you, {name}!\")\n  else:\n    st.write(\"I can't greet you until you enter your name!\")\n\nwith tab3:\n    if name is not None:\n      st.write(f\"Hello again, {name}!\")\n      st.write(\"Isn't it cool that variables persist across different tabs? This can be really handy!\")\n      st.video(\"https://youtu.be/dQw4w9WgXcQ?feature=shared\")\n    else:\n      st.write(\"I can't greet you until you enter your name! Go back to tab 2 and do that.\")",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Tabs</span>"
    ]
  },
  {
    "objectID": "layout_tabs.html#the-two-main-syntax-options-for-streamlit-tabs",
    "href": "layout_tabs.html#the-two-main-syntax-options-for-streamlit-tabs",
    "title": "22  Tabs",
    "section": "22.2 The two main syntax options for streamlit tabs",
    "text": "22.2 The two main syntax options for streamlit tabs\nThere are two main ways to put content inside of tabs.\n\nUsing a ‘with’ statement and indenting the code that should sit within the tab.\n\n\nimport streamlit as st\ntab_a, tab_b = st.tabs([\"A Tab\", \"Another Tab\"])\n\nwith tab_a:\n    st.text(\"This is some content within tab 1\")\n\nwith tab_b:\n    st.text(\"This is some content within tab 2\")\n\n\nReplacing the st in sections like st.text() with the variable name for the given tab.\n\n\nimport streamlit as st\n\ntab_a, tab_b = st.tabs([\"A Tab\", \"Another Tab\"])\n\ntab_a.text(\"This is some content within tab 1\")\n\ntab_b.text(\"This is some content within tab 2\")\n\nThe outputs of both of these bits of code are identical!\nIt’s up to you to choose which you prefer.",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Tabs</span>"
    ]
  },
  {
    "objectID": "layout_tabs.html#automatically-generating-variable-numbers-of-tabs",
    "href": "layout_tabs.html#automatically-generating-variable-numbers-of-tabs",
    "title": "22  Tabs",
    "section": "22.3 Automatically generating variable numbers of tabs",
    "text": "22.3 Automatically generating variable numbers of tabs\nIn some instances, you may wish to reactively create a different number of tabs.\nIn this example, notice what happens to the random numbers as you change the number of tabs being generated.\n\n22.3.1 Using the ‘tab.’ syntax\n\n\n\n22.3.2 Using the ‘with’ syntax\nIt’s also possible to do this using the ‘with’ syntax.\nIn this example, in every separate tab, we pull back a random wikipedia page.\n(However, due to the way this works behind the scenes, we don’t get a new page on changing the number of tabs even though the app is rerunning each time)",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Tabs</span>"
    ]
  },
  {
    "objectID": "layout_tabs.html#custom-styling-of-tabs",
    "href": "layout_tabs.html#custom-styling-of-tabs",
    "title": "22  Tabs",
    "section": "22.4 Custom Styling of Tabs",
    "text": "22.4 Custom Styling of Tabs\nHere is an example of how to change the tab formatting.\n\n\n\n\n\n\nWarning\n\n\n\nThis is not a supported part of Streamlit - the ways in which streamlit internally names these tabs may change over time, causing this code to no longer work.",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Tabs</span>"
    ]
  }
]