[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HSMA - Web Apps with Streamlit",
    "section": "",
    "text": "Preface\nWelcome to this book accompanying the Streamlit sessions of module 7 of the HSMA programme.\nIn this module we introduce the Streamlit framework for web app development.\nStreamlit is a popular Python web framework that allows powerful and professional looking data apps to be created in hours instead of weeks.\nIn this book, we will introduce some of the key features of Streamlit and how to start putting them together to make more complex apps.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#stlite",
    "href": "index.html#stlite",
    "title": "HSMA - Web Apps with Streamlit",
    "section": "stlite",
    "text": "stlite\nMany examples throughout this book use the stlite framework and the stlite-quarto extension, which allows running of streamlit apps directly on the browser of the reader rather than hosting each app remotely.\nThis does mean that the app examples within each page do take a while to load, and you may not want to read this book cover-to-cover if you are on, say, a mobile network - each example will load several megabytes of data to be able to render.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "HSMA - Web Apps with Streamlit",
    "section": "Acknowledgements",
    "text": "Acknowledgements\n\nDatasets\n\nName Popularity\nThe name popularity dataset used in several examples was created by\n\n\nPalmer Penguins\nThe palmer penguins dataset is loaded via the palmerpenguins library available here. Credit goes to Muhammad Chenariyan Nakhaee for the Python port, and Allison Horst, Alison Hill, and Kristen Gorman for the original dataset and R package.\nHorst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer Archipelago (Antarctica) penguin data. R package version 0.1.0. https://allisonhorst.github.io/palmerpenguins/. doi: 10.5281/zenodo.3960218.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "hello_world_streamlit.html",
    "href": "hello_world_streamlit.html",
    "title": "1  Hello World (Wide Web)!",
    "section": "",
    "text": "1.1 Previewing your app\nWhen you are writing streamlit apps from within your IDE - such as vscode - you will need to run some extra code to preview your app.\nFirst, you must make sure you save your app!\nLet’s save our app as main.py.\nThen we need to open a terminal.\nIn the terminal, we then run the command streamlit run main.py\nThis will spin up a temporary server to run your app from.\nYour app will then automatically open in a browser window in your default browser.\nIf we change and save our source file, like so…\nOur running app will recognise that there has been a change and give us the option to rerun to incorporate the new change without having to close and restart our temporary server.\nThis is really handy as it allows us to rapdily tweak and iterate our Streamlit apps!\nYou can also just use the refresh button in your browser if you would prefer.\nThe ‘always rerun’ option will mean that changes made to your source file will automatically trigger a rerun/refresh without you having to do it manually - it’s up to you if that’s something you’d prefer.",
    "crumbs": [
      "An Introduction to Streamlit",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Hello World (Wide Web)!</span>"
    ]
  },
  {
    "objectID": "hello_world_streamlit.html#knowledge-check",
    "href": "hello_world_streamlit.html#knowledge-check",
    "title": "1  Hello World (Wide Web)!",
    "section": "1.2 Knowledge Check!",
    "text": "1.2 Knowledge Check!\nWhat command do you use to run a streamlit file called main.py on your computer? run streamlit serverrun streamlit main.pystreamlit run main.pystreamlit activate\nWhat’s the standard import for the streamlit library? import streamlitimport streamlit as stfrom streamlit import stimport st as streamlit\nHow do you create a title in streamlit? st.title(Welcome to my app!)streamlit_title(‘Welcome to my app!’)st.title(‘Welcome to my app!’)title(‘Welcome to my app!’)",
    "crumbs": [
      "An Introduction to Streamlit",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Hello World (Wide Web)!</span>"
    ]
  },
  {
    "objectID": "loading_data.html",
    "href": "loading_data.html",
    "title": "2  Loading Data",
    "section": "",
    "text": "Streamlit apps are just like standard Python scripts in a lot of ways.\nThis means that most of the standard methods we are used to for loading in data files will work!\nAs people working with data, much of what we want to load in is likely to be is data in a tabular format, like an Excel file or Google Sheet.\nLet’s start by loading in and displaying a simple csv dataset.\n\n\n\n\n\n\nTip\n\n\n\nst.write() is a handy command.\nWhen you pass a variable to it - like some data you’ve loaded in and saved as a Python variable - it will automatically work out a good way to display it.\nOther functions that we talk about in later chapters give you more control over exactly how data or files are displayed - but st.write() can often be a useful starting point.\n\n\n\n1import pandas as pd\n2import streamlit as st\n\n3st.title(\"Loading in a data file from a publically-accessible csv\")\n\n4url = 'https://files.catbox.moe/eor4ta.csv'\n5dataframe = pd.read_csv(url)\n\n6st.write(dataframe)\n\n7st.write(\"This is some text\")\n\n8st.write(123)\n\n9st.write(\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/b6/Felis_catus-cat_on_snow.jpg/\")\n\n\n1\n\nWe are going to be loading in and displaying some tabular data that’s stored as a .csv file, so we need to load in pandas. We choose to use the standard alias ‘pd’ for it.\n\n2\n\nWe then load in streamlit. The standard alias is st - this is useful as in more complex apps we’ll refer to the streamlit library a lot of times!\n\n3\n\nNext we add a title to our app. This will appear at the top of the page in large text. We pass the title to the st.title() function as a string.\n\n4\n\nWe then pass in a url for a dataframe. Alternatively, we could point to a dataframe stored locally on our machine, just like with a normal Python script - we’ll talk more about how that would work when we deploy our app to the web in a later chapter.\n\n5\n\nWe pass the url (or the local filepath) to our pd.read_csv() function - we could specify some additional arguments here if we wanted to.\n\n6\n\nWe use the st.write() function to prompt streamlit to display the dataframe, passing the variable we stored the dataframe into to the function.\n\n7\n\nWe can also pass in a text string to st.write() to make it display in our app.\n\n8\n\nThis also works with numbers…\n\n9\n\n… and web links.\n\n\n\n\nLet’s take a look at how this app will look in the live Streamlit app below.\n\n\n\n\n\n\n\nNote\n\n\n\nIn later chapters, we will learn more about loading in data, including\n\nloading in other data types, like images and videos\nallowing users to upload their own data\n‘caching’ data to prevent it being reloaded unnecessarily\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe focus of this book is on giving you the tools to create simple Streamlit apps. For this, we will mainly focus on using csv files that are stored on the web or locally, or are uploaded by users. In other cases, we will look at data that is generated by simply running the app, as in the case of discrete event simulation apps where the act of running it produces the data for the graphs and tables that we want to analyse!\nHowever, in real-world usage, there may be some instances where connecting to a database may be required to allow automated access to data without requiring it to be passed to the app, rather than relying on intermediate exports to formats like csv from the database.\nConnecting directly to a production database is certainly possible and can be done safely and securely - but beyond the scope of the first version of the book.\nIf this is your first time working with streamlit, it is highly recommended to work through the book first to learn the core concepts of streamlit apps. Building a proof of concept version of your app with a .csv export or dummy dataset can be done before worrying about the task of connecting to a data source - and often a good proof of concept will provide the motivation within your organisation to unblock the things that may make connecting to data sources difficult!\nStreamlit does provide tools and guidance around connecting to data sources for apps that are going into production; to learn more about connecting to other data sources, like SQL databases, you can take a look at this page from the streamlit documentation.\nThis page gives an overview of how to connect to a range of different SQL database types, public and private google sheets, and more.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Loading Data</span>"
    ]
  },
  {
    "objectID": "dataframes.html",
    "href": "dataframes.html",
    "title": "4  Dataframes",
    "section": "",
    "text": "4.1 st.table()\nLet’s start with st.table.\nimport pandas as pd\nimport streamlit as st\n\nst.title(\"Most common names per year\")\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\n\n1name_lookup_df = pd.read_csv(url)\n\nname_lookup_df = (name_lookup_df\n2    .melt(id_vars=[\"Name\", \"Gender\"])\n3    .dropna()\n4    .rename(columns={\"variable\": \"Year\", \"value\": \"Rank\"})\n )\n\nname_lookup_df = (\n5    name_lookup_df[name_lookup_df[\"Rank\"] == 1]\n6    .pivot(values=\"Name\", index=\"Year\", columns=\"Gender\")\n    )\n\n7st.table(name_lookup_df)\n\n\n1\n\nAs before, we pass in the url of the dataframe to the pandas .read_csv() function.\n\n2\n\nWhile this isn’t directly related to the streamlit aspect of the display of the dataframe - you can skip to point 7 for that - it’s worth noting that you can choose to do some processing and manipulation of your data from within your Streamlit app. Here we first convert our dataframe from a ‘wide’ to a ‘long’ format with the melt function…\n\n3\n\n… then remove any rows with missing values…\n\n4\n\n… then rename the ‘variable’ column to ‘Year’ and the ‘value’ columns to ‘Rank’.\n\n5\n\nNext, we filter the dataframe to only contain rows where the ‘Rank’ is equal to 1 - i.e. we just want the top ranked name for each year.\n\n6\n\nFinally, we make our dataframe wider again, making a column for ‘M’ and a column for ‘F’, with the years forming the index of the dataframe and the most popular name in each year being the cell.\n\n7\n\nFinally, we make use of the st.table() function to display our final dataframe as a non-interactie table.\nst.table gives a basic, non-interactive table.\nThis can be useful when we don’t want users to be able to do things like sort the dataframe columns.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dataframes</span>"
    ]
  },
  {
    "objectID": "dataframes.html#st.dataframe",
    "href": "dataframes.html#st.dataframe",
    "title": "4  Dataframes",
    "section": "4.2 st.dataframe()",
    "text": "4.2 st.dataframe()\nst.dataframe gives more interactivity by default.\nThere are also more ways in st.dataframe than st.table in which we can tweak the display of the final data, which we go on to later.\n\nimport pandas as pd\nimport streamlit as st\n\nst.title(\"Most common names per year\")\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\n\nname_lookup_df = (\n    pd.read_csv(url)\n    .melt(id_vars=[\"Name\", \"Gender\"])\n    .dropna()\n    .rename(columns={\"variable\": \"Year\", \"value\": \"Rank\"})\n1)\n\n2st.dataframe(name_lookup_df)\n\n\n1\n\nOnce again, we load in data from a url, make it long, remove any missing values, and rename the columns to something more user-friendly.\n\n2\n\nNext, we pass in our dataframe.\n\n\n\n\n\nA simple search functionality is available when hovering over it, as well as the option to make the table take up the full screen.\n\n\n4.2.1 Polishing the display of different data types with the column API\nThe column configuration API is a powerful way to enhance the display of data tables in Streamlit.\nThis allows you to change the displayed column name without having to rename it via Pandas commands, but it also gives more control over how columns display.\nFor example, you can set a numeric column to include a prefix or suffix, or to add a comma to break up long numbers.\nYou can set links to be clickable, images to preview, and add things like sparklines and progress bars.\nLet’s build up a simple dataset manually so we can explore the use of some of these values.\n\nimport streamlit as st\nimport pandas as pd\n\nst.title(\"Column Configuration API Demonstration\")\n\ndata_df = pd.DataFrame(\n    {\n        \"project\": [\"Project 1\", \"Project 2\", \"Project 3\", \"Project 4\"],\n        \"project_mascot\": [\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/b6/Felis_catus-cat_on_snow.jpg/1920px-Felis_catus-cat_on_snow.jpg\", \"https://upload.wikimedia.org/wikipedia/commons/2/25/Siam_lilacpoint.jpg\",\n        \"https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/Orange_tabby_cat_sitting_on_fallen_leaves-Hisashi-01A.jpg/800px-Orange_tabby_cat_sitting_on_fallen_leaves-Hisashi-01A.jpg\", \"https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/Sheba1.JPG/800px-Sheba1.JPG\"],\n        \"progress\": [70, 40, 10, 100],\n        \"logged_minutes\": [1040, 700, 90, 830],\n        \"client_link\": [\"https://www.morgensternsnyc.com/\", \"https://www.thelittleicecreamshop.com/\",  \"https://www.fredericksicecream.co.uk/\", \"https://www.solleys.co.uk/\"]\n\n1    }\n2).set_index(\"project\")\n\n\nst.dataframe(\n3    data_df,\n4    column_config={\n5        \"progress\": st.column_config.ProgressColumn(\n6            \"Project Progress\",\n7            help=\"The % of project tasks completed\",\n8            format=\"%f%\",\n9            min_value=0,\n            max_value=100, #\n        ),\n10        \"project_mascot\": st.column_config.ImageColumn(\n            \"Mascot\",\n            help=\"The cat mascot of this project\"\n        ),\n11         \"client_link\": st.column_config.LinkColumn(\n            \"Client Website Link\",\n            help=\"Link to the website of the client\",\n12            display_text=\"Open link\"\n        ),\n13         \"logged_minutes\": st.column_config.NumberColumn(\n            \"Minutes Logged on Project\",\n            help=\"Minutes Logged for Client Billing\"\n                    )\n    }\n)\n\n\n1\n\nThis time we are building a dataframe from scratch, passing in a dictionary where the keys will form the column names and the lists associated with the keys will be the values.\n\n2\n\nWe set ‘project’ - one of the provided columns in our dictionary - to be the index of the dataframe.\n\n3\n\nAs before, we pass in the dataframe as the first argument to st.dataframe.\n\n4\n\nTo the column_config argument we pass a dictionary, where the keys again correspond to the column names but the values are a streamlit column_config type with a number of optional arguments.\n\n5\n\nThe ProgressColumn type creates a small progress bar, which can be useful for displaying progress towards a percentage of completion or a total number of values. All values in the progress column must have the same maximum.\n\n6\n\nThe first argument to a st.column_config is the column title to display to the user, allowing your columns to have polished-looking names without having to adjust the underlying dataframe, allowing you to more easily continue working with the dataframe itself in later calculations.\n\n7\n\nThe value passed to the ‘help’ argument will appear when the user hovers over the column name.\n\n8\n\nThe format argument adjusts the way in which the number displays; here, for example, %f indicates it’s should display as a float (decimal) number, with the second % sign indicating a % symbol should be displayed after the number. More details about the available formats can be found on the Streamlit website.\n\n9\n\nThe minimum and maximum values relate to the upper and lower possible values the progress could take.\n\n10\n\nThe ImageColumn will, if passed a local or web-based image path, display a small version of the image within the table instead of the text of the link.\n\n11\n\nThe LinkColumn converts any hyperlinks to a clickable link instead of just being text.\n\n12\n\nThe display_text argument can be used to display more user-friendly text instead of the full link itself.\n\n13\n\nThe NumberColumn just gives some control over the way a number is displayed; by default, a number column will include commas to make it easier to read large numbers, but this can be overriden with the format argument.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nFor editable dataframes (covered in a later chapter), checkboxes, select dropdowns, date/time pickers and more can be integrated into the table.\n\n\nThe full documentation can be found here and is well worth a read to understand the full range of powerful options available to you via the column configuration API.\n\n\n4.2.2 Pandas stylers\nPandas has a ‘styler’ API, which can be used to enhance table displays with conditional formatting and other stylistic enhancements. At present, within Streamlit, cell background colours, font colours and custom value displays are supported. Take a look at the pandas styler documentation for more information, and pass in the pandas styler object instead of the basic dataframe to st.dataframe.\n\n\n4.2.3 Other kinds of tabular data\nst.dataframe works with Pandas, PyArrow, Snowpark, pySpark, Numpy arrays, lists, sets and dictionaries.\n\n\n4.2.4 Additional arguments\nYou can find out more about the available options in the documentation.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dataframes</span>"
    ]
  },
  {
    "objectID": "static_charts.html",
    "href": "static_charts.html",
    "title": "5  Static Charts",
    "section": "",
    "text": "5.1 Making use of the available space\nMany streamlit components have a parameter called use_container_width.\nWhen set to True in something like st.pyplot, it ensures the output is rescaled to use the maximum available width of the screen.\nThe parameter is set to False by default, which will result in outputs often not optimally using the available space.\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom palmerpenguins import load_penguins\n\npenguins = load_penguins()\n\nfig, ax = plt.subplots(figsize=(15,10))\nplt.scatter(x=penguins[\"body_mass_g\"], y=penguins[\"bill_length_mm\"])\nplt.title(\"Penguin Body Mass (g) versus Bill Length (mm)\")\nax.set_xlabel(\"Body Mass (g)\")\nax.set_ylabel(\"Bill Length (mm)\")\n\n1st.subheader(\"use_container_width=False\")\n\n2st.pyplot(fig)\n\n3st.subheader(\"use_container_width=True\")\n\n4st.pyplot(fig, use_container_width=True)\n\n\n1\n\nLet’s make ourselves a subheader so we can tell the two outputted plots apart\n\n2\n\nFirst, we use st.pyplot without the use_container_width argument specified. If not specified, this defaults to False.\n\n3\n\nNow let’s add another subheader.\n\n4\n\nThis time, we pass in the same figure to st.pyplot, but this time we specify the use_container_width parameter to be True.\nTake a look at the impact this has in the live version of the app below.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Static Charts</span>"
    ]
  },
  {
    "objectID": "static_charts.html#making-use-of-the-available-space",
    "href": "static_charts.html#making-use-of-the-available-space",
    "title": "5  Static Charts",
    "section": "",
    "text": "Tip\n\n\n\nThis can become particularly valuable when we start to explore layout options like columns later in the book.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Static Charts</span>"
    ]
  },
  {
    "objectID": "interactive_charts.html",
    "href": "interactive_charts.html",
    "title": "6  Interactive Charts",
    "section": "",
    "text": "6.1 An overview of supported interactive chart types in Streamlit\nStreamlit provides support for several interactive chart libraries, including\nIt also provides its own simplified interactive chart types like st.bar_chart, which are simplified functions for plotting that use Altair behind the scenes.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interactive Charts</span>"
    ]
  },
  {
    "objectID": "interactive_charts.html#an-overview-of-supported-interactive-chart-types-in-streamlit",
    "href": "interactive_charts.html#an-overview-of-supported-interactive-chart-types-in-streamlit",
    "title": "6  Interactive Charts",
    "section": "",
    "text": "Plotly\nBokeh\nAltair\nVega-lite\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhile all of these are valid options to use in your own dashboards, we will be focussing on plotly - specifically the ‘plotly express’ module, which makes it very quick and easy to create relatively complex interactive charts.\nArguably plotly express is simpler to use than the built-in streamlit plot types! It’s also generally more customisable.\n\n\n\n\n\n\n\n\nTip\n\n\n\nEach of the plot types mentioned above require a different streamlit command to display them.\n\nPlotly - st.plotly_chart()\nBokeh - st.bokeh_chart()\nAltair - st.altair_chart()\nVega-lite - st.vega_lite_chart()\n\nThe details and specific arguments that are available for each can be found in the Streamlit documentation here.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interactive Charts</span>"
    ]
  },
  {
    "objectID": "interactive_charts.html#an-example-plotly-chart-in-streamlit",
    "href": "interactive_charts.html#an-example-plotly-chart-in-streamlit",
    "title": "6  Interactive Charts",
    "section": "6.2 An example plotly chart in Streamlit",
    "text": "6.2 An example plotly chart in Streamlit\n\nimport streamlit as st\n1from palmerpenguins import load_penguins\n2import plotly.express as px\n\n3penguins = load_penguins()\n\n4fig = px.scatter(\n5       penguins,\n6       x='bill_length_mm',\n       y='bill_depth_mm',\n7       color=\"sex\",\n8       title=f\"Penguins Dataset - Bill Length (mm) vs Bill Depth (mm), coloured by Sex\"\n       )\n\nst.plotly_chart(fig)\n\n\n1\n\nHere we load in a package that will provide access to a dataset of penguin measurements.\n\n2\n\nWe also need to load in the plotly.express module. The standard alias for this library is px.\n\n3\n\nWe use the load_penguins() function to pull in the pandas dataframe of penguin measurements, assigning it to the variable penguin.\n\n4\n\nPlotly express (px) provides access to a wide range of simple plot types. Here, px.scatter sets up the chart as a scatterplot which expects, as a minimum, two columns of numeric values to assign the x and y position of a series of points on an axis. We save the output of this function to a variable, as we’ll need to pass that variable to the relevant streamlit function later. A common variable name to use for this is fig.\n\n5\n\nWe pass in the dataframe we want to plot as the first argument.\n\n6\n\nWe specify the names of the columns we want to plot the values of on the x (horizontal) and y (vertical) axes. These can be surrounded by single ’ or double ” quotes. Note that we don’t need to respecify the dataframe name here - purely the column name as a string.\n\n7\n\nOptionally we can pass in a column containing a categorical variable (which can just be a column of strings) to use to colour the points. Here, we have a column called ‘sex’ which just contains the values ‘Male’ or ‘Female’; passing this in will mean our male penguin points will have one colour, and female another.\n\n8\n\nFinally, we pass the variable corresponding to our plotly plot object to the st.plotly_plot() function.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interactive Charts</span>"
    ]
  },
  {
    "objectID": "interactive_charts.html#making-use-of-the-available-space",
    "href": "interactive_charts.html#making-use-of-the-available-space",
    "title": "6  Interactive Charts",
    "section": "6.3 Making use of the available space",
    "text": "6.3 Making use of the available space\nMany streamlit components have a parameter called use_container_width.\nWe showed the impact of this parameter on static charts in the previous chapter.\nWhen set to True in something like st.plotly_chart, it ensures the output is rescaled to use the maximum available width of the screen.\nThe parameter is set to False by default, which will result in outputs often not optimally using the available space.\n\n\n\n\n\n\nTip\n\n\n\nThis can become particularly valuable when we start to explore layout options like columns later in the book.\n\n\n\n\n\n\n\n\nNote\n\n\n\nDepending on the width of the app window itself, the impact of this function is sometimes not very obvious; it may become more apparent in your own app compared to the example below.\n\n\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\n\npenguins = load_penguins()\n\nfig = px.scatter(\n       penguins,\n       x='bill_length_mm',\n       y='bill_depth_mm',\n       color=\"sex\",\n       title=f\"Penguins Dataset - Bill Length (mm) vs Bill Depth (mm), coloured by Sex\",\n       width=300,\n       height=400\n       )\n\nst.subheader(\"use_container_width=False\")\n\nst.plotly_chart(fig)\n\nst.subheader(\"use_container_width=True\")\n\nst.plotly_chart(fig, use_container_width = True)",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interactive Charts</span>"
    ]
  },
  {
    "objectID": "interactive_charts.html#sneak-peak-reacting-to-user-inputs",
    "href": "interactive_charts.html#sneak-peak-reacting-to-user-inputs",
    "title": "6  Interactive Charts",
    "section": "6.4 Sneak Peak: Reacting to user inputs",
    "text": "6.4 Sneak Peak: Reacting to user inputs\nWhile we haven’t gone into detail about user inputs yet, here is an example of a plotly chart updating based on the options a user is selecting.\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\n\npenguins = load_penguins()\n\naxis_options = [\n       'bill_length_mm', 'bill_depth_mm' 'flipper_length_mm'\n1       ]\n\ncol_1 = st.selectbox(\n       \"Select the column to use for the x axis\", axis_options\n2       )\n\nfig = px.scatter(\n       penguins,\n3       x=col_1,\n       y='body_mass_g',\n       color='species',\n4       title=f\"Penguins Dataset - {col_1} vs Body Mass (g), coloured by Species\"\n       )\n\nst.plotly_chart(fig)\n\n\n1\n\nIn this example, we want users to be able to choose one of three columns to use for the x axis values, with the y axis values and column used for colour being pre-set. We start by creating a list of the column names; these must exact match the way the column name is written in the dataframe, including case, spaces and any underscores.\n\n2\n\nNext, we use one of streamlit’s built-in user input gathering functions. A selectbox gives the user a drop-down list of predefined options to select from. We pass this a label (to indicate to the user what they are selecting) and the list of possible column names. We store the output of this in a variable, which we’ve called col_1 here. The contents of col_1 will be whichever of the three provided column names the user has selected. By default, the first column name in the list will be selected when the app loads.\n\n3\n\nHere, we pass in col_1 when creating our plotly plot. When the app executes, the variable col_1 will be replaced with the name of the column the user has selected, which will then be used by plotly when constructing the plot.\n\n4\n\nWe can also use this input to make the title of the plot update in response to the selected variable.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Interactive Charts</span>"
    ]
  },
  {
    "objectID": "metrics.html",
    "href": "metrics.html",
    "title": "7  Metrics and Dials",
    "section": "",
    "text": "7.1 Metrics\nimport streamlit as st\n\n1st.metric(\n2  label=\"Number of Patients Seen this Week\",\n3  value=52\n  )\n\nst.metric(\n  label=\"Number of Patients Seen this Week - South\",\n  value=30,\n4  delta=7\n  )\n\nst.metric(\n  label=\"Number of Patients Seen this Week - North\",\n  value=12,\n5  delta=-4\n  )\n\nst.metric(\n  label=\"Waiting List Length\",\n  value=147,\n  delta=-15,\n6  delta_color=\"inverse\"\n  )\n\n7st.subheader(\"A metric without its own header\")\n\nst.metric(\n8  label=\"This Won't Be Displayed\",\n  value=5,\n  delta=3,\n9  label_visibility=\"collapsed\"\n  )\n\n\n1\n\nWe are going to be using the st.metric() function.\n\n2\n\nWe pass in a string to be used as the metric card’s label.\n\n3\n\nThen we pass in a value to display on the card.\n\n4\n\nWe can also provide an optional delta parameter, which is designed to show the difference between the current metric value and a comparison figure, such as the figure in the previous time period.\n\n5\n\nThis delta value can also be negative, and this will display in a different colour.\n\n6\n\nIf an increase is actually a bad thing and a decrease is a good thing, passing the ‘inverse’ parameter will invert the colours used.\n\n7\n\nIf we wanted to make a title that stood out more, we could instead use a subheader.\n\n8\n\nNote that we are going to specify a parameter that means any label passed in here won’t actually get displayed - but you should still specify one.\n\n9\n\nFinally, we use the label_visibility parameter with the argument collapsed to hide the provided label.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Metrics and Dials</span>"
    ]
  },
  {
    "objectID": "metrics.html#metrics",
    "href": "metrics.html#metrics",
    "title": "7  Metrics and Dials",
    "section": "",
    "text": "7.1.1 Layout\nBy combining metrics with st.columns, we can make better use of the screen to start building up more of a dashboard layout. The column layout is covered in more detail in the linked chapter.\n\n\n\n\n\n\nWarning\n\n\n\nTo ensure Streamlit apps display well on all screen sizes, on narrower screens you may find that your defined columns are ignored and instead the metrics return to displaying as a single column. If you increase the width of the window, it should automatially update the layout and, if the screen is wide enough, it will respect the column assignments you have provided.\n\n\n\nimport streamlit as st\nimport plotly.express as px\nimport pandas as pd\n\n1st.set_page_config(layout=\"wide\")\n\nst.title(\"Activity Dashboard\")\n\n2col1, col2, col3 = st.columns(3)\n\n3col1.metric(label=\"Total Number of Patients Seen this Week\", value=52)\n\ncol2.metric(label=\"Number of Patients Seen this Week - South\", value=30, delta=-5)\n\ncol2.metric(label=\"Number of Patients Seen this Week - North\", value=12, delta=-7)\n\ncol3.metric(label=\"Number of Patients Seen this Year\", value=1302)\n\n4patients_seen_df = pd.DataFrame(\n  {\n    'Week': ['2021-01-01', '2021-01-08', '2021-01-15', '2021-01-22', '2021-01-29', '2021-02-05'],\n    'Patients Seen': [24, 12, 43, 23, 32, 25]\n  }\n)\n\n5st.plotly_chart(\n  px.line(patients_seen_df, x='Week', y='Patients Seen', title=\"Total Patients Seen per Week\")\n  )\n\n\n1\n\nHere, we’ve started out by setting the page config to ‘wide’. This just means that the page will use the whole width of the viewer’s screen, rather than limiting itself to the middle third.\n\n2\n\nWe set up 3 columns using the st.columns feature, unpacking them on the left-hand side of our assign (the equals sign) into three separate variables called col1, col2, col3 for easy reference (though we could call them anything!). col1 will be the leftmost column and as we haven’t specified otherwise, they will be of equal width.\n\n3\n\nWe then create our metrics, but instead of using st.metric, we use col1.metric (and so on). This is an easy shorthand to assign the resulting metric to each of the columns we’ve just created.\n\n4\n\nNow we’re just going to quickly make a dummy dataframe so that we can see the impact of putting something underneath the column layout. We wouldn’t usually build the dataframe up like this - we’d load it in from a database or csv.\n\n5\n\nNow we’re just creating a plotly chart container and putting a plotly express line chart in it. Note how rather than being inside one of the columns, it takes up the full width of the screen. This is because we’ve gone back to using st.plotly_chart instead of col1.plotly_chart or similar.\n\n\n\n\n\n\n\n7.1.2 Styling Metric Cards\nThe Streamlit Extras package provides us with options to apply a style to our metric cards.\nYou will need to pip install streamlit-extras if it’s not already installed in your environment.\n\nimport streamlit as st\nimport plotly.express as px\nimport pandas as pd\n1from streamlit_extras.metric_cards import style_metric_cards\n\nst.set_page_config(layout=\"wide\")\n\nst.title(\"Activity Dashboard\")\n\ncol1, col2, col3 = st.columns(3)\n\ncol1.metric(label=\"Total Number of Patients\\nSeen this Week\", value=52)\n\ncol2.metric(label=\"Number of Patients\\nSeen this Week - South\", value=30, delta=-5)\n\ncol2.metric(label=\"Number of Patients\\nSeen this Week - North\", value=12, delta=-7)\n\ncol3.metric(label=\"Number of Patients Seen this Year\", value=1302)\n\n2style_metric_cards(background_color=\"#6434eb\", border_color= \"#eb9234\", border_size_px=3)\n\npatients_seen_df = pd.DataFrame(\n  {\n    'Week': ['2021-01-01', '2021-01-08', '2021-01-15', '2021-01-22', '2021-01-29', '2021-02-05'],\n    'Patients Seen': [24, 12, 43, 23, 32, 25]\n  }\n)\n\nst.plotly_chart(\n  px.line(patients_seen_df, x='Week', y='Patients Seen', title=\"Total Patients Seen per Week\")\n  )\n\n\n1\n\nWe import the function style_metric_cards from streamlit_extras.metric_cards\n\n2\n\nWe then use this function after we’ve created our metric cards, passing in the relevant arguments to change the background colour, border colour, border size and more.\n\n\n\n\nFull details of all the available parameters can be found in the streamlit extras documentation\n\n\n\n\n\n\nTip\n\n\n\nThe six-character alphanumeric codes we passed into the ‘background_color’ and ‘border_color’ arguments are called hex colours and are a common way of specifying colours on computers - particularly in web development.\nThere are lots of sites to help you look up hex colours to find the perfect one for you.\nThis page from w3 schools is a starting point.\nYou can also just go to google and seach ‘hex colour picker’ to bring up an interactive picker straight away!",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Metrics and Dials</span>"
    ]
  },
  {
    "objectID": "metrics.html#indicators",
    "href": "metrics.html#indicators",
    "title": "7  Metrics and Dials",
    "section": "7.2 Indicators",
    "text": "7.2 Indicators\nTo get other sorts of displays that we might be familiar with in other dashboarding software, we may need to instead move to plotly or another graphing library rather than using things built in to Streamlit.\n\nimport streamlit as st\n1import plotly.graph_objects as go\n\n2def indicator(value, title, lower_limit=0, upper_limit=1):\n    return go.Figure(\n      go.Indicator(\n        mode = \"gauge+number\",\n        value = value,\n        title = {'text': title},\n        domain = {'x': [0, 1], 'y': [0, 1]},\n        gauge = {\n        'axis': {'range': [lower_limit, upper_limit]}\n      }\n    )\n  )\n\nst.plotly_chart(\n3  indicator(\n4    value=80,\n    title=\"Percentage of Tasks Completed\",\n    upper_limit=100\n    )\n  )\n\nst.plotly_chart(\n  indicator(\n    value=3,\n    title=\"Number of Patients Seen Today\",\n    upper_limit=10\n    )\n  )\n\n\n1\n\nInstead of importing the plotly.express module, this time we import the graph_objects module as go. This gives us finer control over plotly objects.\n\n2\n\nWe define our own custom ‘indicator’ function to make it easier. Don’t worry too much about the code in this function; you could copy it into your own Streamlit dashboards as-is.\n\n3\n\nWe can then pass the output of this ‘indicator’ function to st.plotly_chart like usual. We could save this to a fig first if we wished, before passing the fig into st.plotly_chart.\n\n4\n\nWe pass in the actual value of the metric, the title to display above the gauge and optionally the relative upper and lower limits that this value could take or should be measured relative to.\n\n\n\n\n\nTake a look at this documentation from plotly to see how to enhance these charts further, such as\n\nadding a target\nadding segments/reference points to the arc\nchanging the colour of the bar\n\nThis page contains additional things you can do with the indicator graph object in Plotly, such as overlaying a metric card on a plotly chart.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Metrics and Dials</span>"
    ]
  },
  {
    "objectID": "static_maps.html",
    "href": "static_maps.html",
    "title": "8  Static Maps",
    "section": "",
    "text": "8.1 Static maps\nIn the HSMA course, we have generally used the geopandas plot method - which is using matplotlib behind the scenes - to produce static maps.\nThis means that maps are simple to display as we can just use the st.pyplot() function that we used for standard matplotlib charts.\n1import geopandas\n2import matplotlib.pyplot as plt\nimport pandas as pd\nimport streamlit as st\n\nst.title(\"Crime in Devon by Type\")\n\n#########################################################\n# Read the geopandas file and create a matplotlib figure\n#########################################################\n\nlsoa_2011_crime_figures_df = geopandas.read_file(\n3  \"https://files.catbox.moe/4o0go1.gpkg\"\n  )\n\n4fig, ax = plt.subplots()\n\n5lsoa_2011_crime_figures_df.plot(\n6  column=\"sw_5forces_street_by_lsoa_Other crime\",\n7  legend=True,\n8  ax=ax\n  )\n\n9st.pyplot(fig)\n\n\n1\n\nWe will need to import the geopandas library to load in and plot a geographic dataset.\n\n2\n\nWe also will need to import the matplotlib.pyplot module, which we give the standard alias plt. When working with geopandas in a .py script or a jupyter notebook, this is only necessary when further modifying the plot; however, we need to structure our plot in a slightly different way to get it to display in a streamlit fileapp.\n\n3\n\nWe then import a geopackage file from a URL and save it to a variable. As it’s a geopackage rather than a csv or similar, we don’t need to define the CRS: it’s already specified as part of the geopackage file. The same would be true of a geojson.\n\n4\n\nWe use the plt.subplots() function, unpacking it to the objects fig and ax by using the syntax fig, ax on the left hand side of our = sign. By leaving this blank, we create a single axis - but the value of this step is it gives us access to these objects so we can pass it to the streamlit function for displaying this sort of plot.\n\n5\n\nWe then use the plot method on the dataframe. We don’t need to save the output of this to a variable,\n\n6\n\nWe pass in a column to colour the plot by, though this is optional; if we did not, it would just plot the points or polygons in the dataset all in the same colour.\n\n7\n\nWe also specify that we want a legend in our plot to give some indication of the range and significance of the clours in the plot.\n\n8\n\nWe tell geopandas/matplotlib to plot on the axis we just created using plt.subplots, which we do by passing in ax=ax to our .plot method.\n\n9\n\nThe output of using the .plot() method on the geopandas dataframe is a matplotlib.pyplot object. Therefore, we need to use st.pyplot() to display it.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Static Maps</span>"
    ]
  },
  {
    "objectID": "interactive_maps.html",
    "href": "interactive_maps.html",
    "title": "9  Interactive Maps",
    "section": "",
    "text": "9.1 Interactive maps with Folium\nFolium is an easy way to make interactive maps.\nWhile they are not natively supported in streamlit, the st-folium component is a powerful custom component that is being actively supported and developed.\n1import geopandas\nimport pandas as pd\nimport streamlit as st\n2import folium\n3from streamlit_folium import st_folium\n\n4gp_list_gdf_sw = geopandas.read_file(\n    \"https://files.catbox.moe/atzk26.gpkg\"\n    )\n\n# Filter out instances with no geometry\n5gp_list_gdf_sw = gp_list_gdf_sw[~gp_list_gdf_sw['geometry'].is_empty] ,\n\n# Create a geometry list from the GeoDataFrame\n6geo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gp_list_gdf_sw.geometry]\n\n7gp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\n8for i, coordinates in enumerate(geo_df_list):\n\n9    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i],\n10            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\n11st_folium(gp_map_tooltip)\n\n\n1\n\nTo work with geographic data, we need to import the geopandas library.\n\n2\n\nWe’ll also need the folium library to help set up our interactive map.\n\n3\n\nFinally we need to use the streamlit_folium library, which we have to install separately (but is included in the hsma_webdev environment if you are following the HSMA course). From that library, we import just the function st_folium().\n\n4\n\nWe load in a geopackage file. We don’t need to specify a coordinate reference system for this kind of file; it’s recorded within the file itself and geopandas will automatically read and apply this, though as Folium expects the coordinates to be in latitude and longitude (not Northings and Eastings), you may need to convert the CRS of your own data. See the HSMA geographic book for more details.\n\n5\n\nFolium does not cope well with missing data, so we filter out any rows where our ‘geometry’ column is empty.\n\n6\n\nTo set up our map of points, we will need to create a list of coordinate pairs, though Folium expects them in the order longitude, latitude, so we swap the order of the points from our geometry column when placing them in the list.\n\n7\n\nWe then create a folium map, specifying the starting zoom level and the coordinates around which it should initially be centred.\n\n8\n\nWe then iterate through the list of points we created.\n\n9\n\nIn each round of our loop we add a Folium ‘marker’ to our original map.\n\n10\n\nIn Folium, if we don’t specify an icon to use for the marker, it will choose a default. However, this doesn’t seem to reliably work in all instances of Streamlit, so you may need to specify a custom icon instead using the folium.Icon class to select an icon from a web service such as font awesome. More about this can be found in the HSMA geographic book.\n\n11\n\nFinally, we pass our map to the st_folium() function.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Interactive Maps</span>"
    ]
  },
  {
    "objectID": "interactive_maps.html#interactive-maps-with-folium",
    "href": "interactive_maps.html#interactive-maps-with-folium",
    "title": "9  Interactive Maps",
    "section": "",
    "text": "Tip\n\n\n\nTake a look at the HSMA geographic modelling and visualisation book to find out more about creating and modifying interactive maps in Python.\n\n\n\n9.1.1 Sneak Peak - Updating the map based on inputs\nLet’s use a simple text input to filter the dataframe we are passing to the map.\nWhat happens to the map when we do this?\n\nimport geopandas\nimport pandas as pd\nimport streamlit as st\nimport folium\nfrom streamlit_folium import st_folium\n\n1search_string = st.text_input(\"Enter a string to search the practice name field by\")\n\ngp_list_gdf_sw = geopandas.read_file(\"https://files.catbox.moe/atzk26.gpkg\")\n\n# Filter out instances with no geometry\ngp_list_gdf_sw = gp_list_gdf_sw[~gp_list_gdf_sw['geometry'].is_empty]\n\n# Filter to just the practice of interest (if given)\n2if search_string is not \"\":\n3    gp_list_gdf_sw = gp_list_gdf_sw[gp_list_gdf_sw['name'].str.contains(search_string.upper())]\n\n4st.dataframe(gp_list_gdf_sw[['name', 'address_1', 'postcode', 'Total List Size']])\n\n# Create a geometry list from the GeoDataFrame\n5geo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gp_list_gdf_sw.geometry]\n\ngp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i],\n            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\nst_folium(gp_map_tooltip)\n\n\n1\n\nWe create a streamlit user input that is designed to take a text string from the user. Whatever the user enters is saved to the variable search_string.\n\n2\n\nWe check whether this search string is equal to an empty string, which is \"\" or '' (but we can use either of those to check against - they are regarded as identical). If the value of search_string is \"\", we don’t undertake the indented code and jump to the next step instead - i.e. we won’t do any filtering.\n\n3\n\nIf the search_string is anything other than a blank string, we filter the name column of the dataframe (which here is the GP practice name) to only include instances where the search_string appears somewhere in the name - e.g. if our search string is “Hill” it would match “Hill Practice”, “Big Hill Surgery”, “Chilly Bend Surgery” and so on. Other methods exist if we only want to match the exact string.\n\n4\n\nHere, we add in a display of the filtered dataframe, restricting it to only the columns specified in the list.\n\n5\n\nAll of our Folium code is unchanged; we just pass the filtered (or unfiltered, if no search string is entered) dataframe instead.\n\n\n\n\n\n\n\n9.1.2 Updating the app based on the map zoom\nYou can do things like filter a dataframe down to only the subset of points that are on the screen within the Folium component.\nTo find out more about this, head to the chapter Bidirectional Inputs - Charts and Maps",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Interactive Maps</span>"
    ]
  },
  {
    "objectID": "custom_components.html",
    "href": "custom_components.html",
    "title": "10  Additional Output Components",
    "section": "",
    "text": "There are a large number of additional third-party components that have been created by the wider streamlit community, with more appearing all the time.\nYou can take a look at them here to see if what you are looking for is listed:\n\nYou may also have luck using a search engine like Google when looking for additional components to do something specific. If the result is a github repository, there will generally be details on the command to run to install it to your environment, and details on how to use it.\nJust exercise some level of caution whenever you are using a custom component - is it sending your data somewhere, for example? In addition, less popular components may eventually be abandoned by their creators,\n\n\n\n\n\n\nWarning\n\n\n\nOver time, as new features come to Streamlit, certain components may become obsolete as the feature they are adding becomes part of the core Streamlit features instead. At the time of writing, user authentication is on the horizon, session state has been integrated, and multipage apps have been around for quite some time - but components to do all of these things appear as very popular entries in the page embedded above.\nWhere a core streamlit implementation of a feature does what you need, stick with that - it will likely be better supported and more stable in the long run.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Additional Output Components</span>"
    ]
  },
  {
    "objectID": "introduction_to_inputs.html",
    "href": "introduction_to_inputs.html",
    "title": "11  Basic Inputs",
    "section": "",
    "text": "11.1 Streamlit Running Order\nA key concept of Streamlit is that each time something changes, the app reruns from top to bottom.\nThis is a good thing for simple apps - but it can become problematic as your app becomes more complex and if you have things that take longer to rerun.\nLet’s make a new app that takes some different inputs.\nHere, despite the fact that the dataframe does not change between runs\nimport streamlit as st\n1import time\nimport pandas as pd\n\nst.write(\"Loading the name popularity lookup\")\n2time.sleep(3)\nst.write(\"Still Loading...\")\ntime.sleep(4)\n\nurl = 'https://www.dropbox.com/scl/fi/yxrc1ll9o3kpg5b1ekm5b/girl_boy_names_2022.csv?rlkey=eq3uv3ms5441gqxchnnom1h6b&st=d53l3q1q&dl=1'\n3name_lookup = pd.read_csv(url)\nst.write(\"Done!\")\n\n4input_name = st.text_input(\"What is your name?\")\n\n5boy_name_lookup = name_lookup[name_lookup[\"Boy Name\"] == input_name]\ngirl_name_lookup = name_lookup[name_lookup[\"Girl Name\"] == input_name]\n\n6if len(boy_name_lookup) &gt; 0:\n7    st.write(f\"{input_name} was in popularity position {boy_name_lookup[\"Rank\"].values[0]} for boys in 2022.\")\nelse:\n8    st.write(f\"{input_name} was not in the most popular 1000 names for boys in 2022.\")\n\n9if len(girl_name_lookup) &gt; 0:\n    st.write(f\"{input_name} was in popularity position {girl_name_lookup[\"Rank\"].values[0]} for girls in 2022.\")\nelse:\n    st.write(f\"{input_name} was not in the most popular 1000 names for girls in 2022.\")\n\n\n1\n\nHere we import a module called ‘time’ just to make the loading time artifically longer (for demonstration purposes).\n\n2\n\nWe then run time.sleep(3) to make the app pause for 3 seconds at this point in the code. Each time the code reaches this step, it will pause for 3 seconds.\n\n3\n\nWe import a dataframe of the 1000 most popular boy and grl names in 2022. This has three columns - the rank, the boy name in that popularity position for 2022, and the girl name in that position in that year too.\n\n4\n\nHere, we allow users to enter a string of text and save their string as the variable input_name.\n\n5\n\nWe create two variables; we filter the dataframe to rows where the ‘Boy Name’ column is exactly equal to the input string from the user, and repeat this for the ‘Girl Name’ column to create a second variable.\n\n6\n\nIf the length of the variable boy_name_lookup is greater than 0 (i.e. after filtering the dataframe to only include rows where this name exists), this indicates that the name was in the 1000 most popular names for that year.\n\n7\n\nIf this is the case, display the name and its rank in that year.\n\n8\n\nIf not, display a different message.\n\n9\n\nRepeat this for the girl name.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Basic Inputs</span>"
    ]
  },
  {
    "objectID": "introduction_to_inputs.html#streamlit-running-order",
    "href": "introduction_to_inputs.html#streamlit-running-order",
    "title": "11  Basic Inputs",
    "section": "",
    "text": "Note\n\n\n\nHere we artifically induce a wait for the loading phase so you can more clearly see the process by which the app reruns.\nYou don’t need to do this in your own apps! They will just run as fast as the code possibly can - but that can still not be fast enough if there are lots of things that need to be recalculated.\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThere are some more advanced features of Streamlit you can call upon when you want to minimize the number of code reruns that occur unnecessarily.\nWe’ll cover these - such as caching, partial reruns, activation buttons and session state - later in the book.\nFor now, it’s just important to be aware that a Streamlit app behaves a lot like a Python script - it’s almost like a frontend that reruns a script each time an input value is changed.\nThis design decision keeps the code as simple as possible - and it’s often not a big problem for simpler apps.\nStill, you will need to keep it in mind as your apps grow in complexity.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Basic Inputs</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html",
    "href": "text_numeric_and_selection_inputs.html",
    "title": "12  An Overview of Available Input Types",
    "section": "",
    "text": "12.1 Using inputs in calculations\nIn addition to text, we often want to be able to get numeric inputs from users.\nNumber boxes and sliders are two good ways to do this.\nThe benefit of this is that the resulting output can be guaranteed to be a number - unlike using a text input, where the user could choose to enter a non-numeric value which may break later steps of your app.\nLet’s take a look at how we can use these two kinds of inputs.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#other-numeric-and-date-inputs",
    "href": "text_numeric_and_selection_inputs.html#other-numeric-and-date-inputs",
    "title": "12  An Overview of Available Input Types",
    "section": "12.2 Other numeric and date inputs",
    "text": "12.2 Other numeric and date inputs",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#other-useful-input-types",
    "href": "text_numeric_and_selection_inputs.html#other-useful-input-types",
    "title": "12  An Overview of Available Input Types",
    "section": "12.3 Other useful input types",
    "text": "12.3 Other useful input types\nLet’s have a very quick look at some of the other inputs available to us within Streamlit.\nThe desired type of the output will be inferred from the default value you pass into the slider.\n\n12.3.1 Range Slider\n\nlower_value, upper_value = st.slider(\n    \"Pick a lower and upper limit\",\n    min_value=0,\n    max_value=100,\n    value=(35, 80)\n    )\n\n\n\n12.3.2 Time Slider\n\nchosen_time = st.slider(\n    \"Select a time:\",\n    time(11, 30)\n)\n\n\n\n12.3.3 Date Slider\n\nselected_date = st.slider(\n    \"Select a date\",\n    value=datetime(2022, 1, 1),\n    format=\"DD/MM/YYYY\",\n)\n\n\n\n12.3.4 Date Range Slider\n\nstart_date, end_date = st.slider(\n    \"Select a date\",\n    value=(datetime(2022, 1, 1), datetime(2023, 6, 1)),\n    format=\"DD/MM/YYYY\"\n)\n\n\n\n12.3.5 Time Range Slider\n\nstart_time, end_time = st.slider(\n    \"Select a time:\",\n    value=(time(11, 30), time(12, 45))\n)\n\n\n\n12.3.6 Datetime Slider\n\nchosen_datetime = st.slider(\n    \"Select a date and time\",\n    value=datetime(2022, 1, 1, 12, 0),\n    format=\"DD/MM/YYYY @ hh:mm\",\n)\n\n\n\n12.3.7 Date Calendar Picker\n\nselected_date = st.date_input(\n    \"Choose a date on the calendar picker\"\n    )\n\n\n\n12.3.8 Time Calendar Picker\n\nselected_time = st.time_input(\n    \"Select a time\"\n    )\n\n\n\n12.3.9 Interactive Examples",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#selection-inputs",
    "href": "text_numeric_and_selection_inputs.html#selection-inputs",
    "title": "12  An Overview of Available Input Types",
    "section": "12.4 Selection inputs",
    "text": "12.4 Selection inputs\nSelection inputs are a very useful class of inputs. They allow you to give users a distinct number of options to choose from.\n\n\n\n\n\n\nTip\n\n\n\nAll of the input types given below can take a huge range of additional parameters to further refine their behaviour.\nFor example, you can adjust which default value is selected, have an optional tooltip that appears on hover, or change the number of allowed options in some cases.\nIt’s highly recommended that you take a look at the documentation to understand the full range of options available.\n\n\n\n12.4.1 Radio\n\nradio_colour_select = st.radio(\n    \"Which of these colours is your favourite?\",\n    options=[\"Green\", \"Blue\", \"Red\", \"Yellow\", \"Purple\"]\n    )\n\n\n\n12.4.2 Selectbox\n\nselectbox_colour_select = st.selectbox(\n    \"Which of these colours is your favourite?\",\n    options=[\"Green\", \"Blue\", \"Red\", \"Yellow\", \"Purple\"]\n    )\n\n\n\n12.4.3 Multiselect\n\nmultiselect_colour_select = st.multiselect(\n    \"Which of these colours are your favourite? You can pick more than one!\",\n    options=[\"Green\", \"Blue\", \"Red\", \"Yellow\", \"Purple\"]\n    )\n\n\n\n12.4.4 Select Slider\n\nslider_colour_select = st.select_slider(\n    \"Which of these colours is your favourite?\",\n    options=[\"Green\", \"Blue\", \"Red\", \"Yellow\", \"Purple\"]\n    )\n\n\n\n12.4.5 Interactive Examples",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#other-useful-inputs",
    "href": "text_numeric_and_selection_inputs.html#other-useful-inputs",
    "title": "12  An Overview of Available Input Types",
    "section": "12.5 Other useful inputs",
    "text": "12.5 Other useful inputs\nThe final inputs we’ll take a quick look at are checkbox and toggle inputs.\nThese are useful as they return boolean values - True or False.\n\nimport streamlit as st\n\ncheckbox_value = st.checkbox(\"Tick or untick me!\")\n\nst.write(f\"The value of the checkbox is {checkbox_value}\")\n\ntoggle_value = st.toggle(\"Tick or untick me!\")\n\nst.write(f\"The value of the toggle is {toggle_value}\")",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#additional-input-types-not-covered-here",
    "href": "text_numeric_and_selection_inputs.html#additional-input-types-not-covered-here",
    "title": "12  An Overview of Available Input Types",
    "section": "12.6 Additional Input Types Not Covered Here",
    "text": "12.6 Additional Input Types Not Covered Here\nYou can always refer to the excellent Streamlit documentation to see what other input widgets are available.\nNew official ones are sometimes added, and there are additional ones made by the community that become available over time.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#next-steps-with-inputs",
    "href": "text_numeric_and_selection_inputs.html#next-steps-with-inputs",
    "title": "12  An Overview of Available Input Types",
    "section": "12.7 Next steps with inputs",
    "text": "12.7 Next steps with inputs\nIn the rest of this section, we’ll look at some of the parameters for inputs that will allow you to refine what your users will be allowed to enter, improving the usability of your app (and reducing the number of edge cases you need to account for in your programming!).",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "file_uploads.html",
    "href": "file_uploads.html",
    "title": "13  Uploading Data Files, Images and More",
    "section": "",
    "text": "13.1 A simple csv file upload\nLet’s start off by asking the user to upload any csv file of data.\nWe’ll then display some summary details about their dataframe and the first five values from each column.\nRight click on the following link and choose ‘save as’ to download a sample file you can use in the following app: file\nimport streamlit as st\nimport pandas as pd\n\n1uploaded_file = st.file_uploader(\n    \"Please upload a data file\"\n    )\n\n2if uploaded_file is not None:\n3    uploaded_df = pd.read_csv(uploaded_file)\n\n4    st.write(f\"Your dataframe has {len(uploaded_df)} rows.\")\n\n    st.write(f\"Your dataframe has {len(uploaded_df.columns)} columns.\")\n\n    st.write(f\"The columns in your dataframe are {', '.join(uploaded_df.columns)}.\")\n\n    for col in uploaded_df.columns:\n        st.write(f\"The first 5 values in column {col} are {', '.join(uploaded_df[col].head().astype('str'))}\")\n\n\n1\n\nWe use the st.file_uploader() function and assign the output to a variable of our choice.\n\n2\n\nHere, we check whether the user has uploaded a file yet. If they have not, the value of our variable will be the special Python value None. If this is the case, we will not run the indented code. However, if they have uploaded something, we will attempt to run the indented code.\n\n3\n\nTo turn the csv the user has uploaded into something we can use, we will use the pd.read_csv() function on it - just like with a normal csv file that we are trying to load in Python. We will save this to a different variable - here we have called it uploaded_df.\n\n4\n\nNow that we have created this uploaded_df variable, it is an entirely normal pandas dataframe - and we can use any of the usual functions we would use on it.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Uploading Data Files, Images and More</span>"
    ]
  },
  {
    "objectID": "file_uploads.html#a-simple-csv-file-upload",
    "href": "file_uploads.html#a-simple-csv-file-upload",
    "title": "13  Uploading Data Files, Images and More",
    "section": "",
    "text": "Note\n\n\n\nThe key thing to notice here is that we have two steps to getting a usable csv file for our next steps:\n\nsave the output of st.file_uploader() to a variable\nread this output using the pd.read_csv() method\n\n\n\n\n\n\n13.1.1 Limiting the file types\nBy default, we haven’t restricted the file types that can be uploaded.\nLet’s do that now!\n\nimport streamlit as st\nimport pandas as pd\n\nuploaded_file = st.file_uploader(\n    \"Please upload a csv data file\",\n1    type=['csv']\n    )\n\nif uploaded_file is not None:\n    uploaded_df = pd.read_csv(uploaded_file)\n\n    st.write(uploaded_df.head())\n\n\n1\n\nWe pass in a list of acceptable file types for the upload. This will filter the files on the user’s system to the acceptable types unless they manually choose to view all file types, and if they attempt to upload the wrong file type, it will tell the user that it is not a valid file.\n\n\n\n\n\nThe app will try to prevent us from uploading the wrong type of file by only showing the correct type of file in our file explorer.\n\nIf we now try to upload a file with a different extension, we’ll receive a more user-friendly error message.\n\nIf we passed more possible extensions to the list, we would allow more extensions to be uploaded - but we’d also have to adapt our code to deal with each of the possible types that can be uploaded!",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Uploading Data Files, Images and More</span>"
    ]
  },
  {
    "objectID": "file_uploads.html#uploading-image-files",
    "href": "file_uploads.html#uploading-image-files",
    "title": "13  Uploading Data Files, Images and More",
    "section": "13.2 Uploading image files",
    "text": "13.2 Uploading image files\nWe can easily upload image files too.\nLet’s try loading an image file and displaying it for the user.\n\nimport streamlit as st\n\n1uploaded_image = st.file_uploader(\n    \"Please upload an image file\",\n2    type=['png', 'jpg', 'jpeg', 'bmp', 'bitmap']\n    )\n\n3if uploaded_image is not None:\n\n4    st.image(uploaded_image)\n\n\n1\n\nWe use the same st.file_uploader() function and save the output to a variable with a name of our choosing.\n\n2\n\nThis time, we specify a list of several different acceptable image types. These are a good starting point if you want to restrict a user to uploading images.\n\n3\n\nWe check whether the user has uploaded something - if they have not, this value will be the special Python value ‘None’ and the indented code will not run.\n\n4\n\nWe do not have to do any additional processing to use the uploaded image file. In this case, we go ahead and use it in st.image() to display the image the user has uploaded.\n\n\n\n\n\n\n13.2.1 Advanced: Manipulating uploaded image files\nWe have to undertake a few extra steps to be able to manipulate image files people have uploaded.\nWe’ll be using the pillow library (referred to as PIL in code) - but it expects the image to be converted to a series of bytes first.\nOnce we’ve adjusted the image into the format pillow expects, we can use the library to run a range of edits and enhancements to our image.\n\n\n\n\n\n\nTip\n\n\n\nThe code below shows just a couple of the things pillow (PIL) can do - take a look at the documentation to find more!\n\n\nLet’s have a go at it here.\n\nimport streamlit as st\nimport io\nfrom PIL import Image, ImageEnhance\nimport PIL.ImageOps\n\nuploaded_image = st.file_uploader(\"Please upload an image file\", type=['png','jpg','jpeg','bmp', 'bitmap'])\n\nif uploaded_image is not None:\n\n    imagefile = io.BytesIO(uploaded_image.read())\n\n    im = Image.open(imagefile)\n\n    threshold = st.slider(\"Choose a threshold\", 1, 100, value=80, step=1)\n    contrast_factor = st.slider(\"Contrast Enhancement Strength\", 0.0, 2.0, value=1.0, step=0.05)\n    invert = st.checkbox(\"Invert Output Image?\")\n\n    enhancer = ImageEnhance.Contrast(im)\n    img_edited = enhancer.enhance(contrast_factor)\n\n    img_edited = img_edited.convert(\"L\").point(\n        lambda x: 255 if x &gt; threshold else 0\n    )\n\n    if invert:\n        img_edited = PIL.ImageOps.invert(img_edited)\n\n    st.write(\"Original Image\")\n    st.image(uploaded_image)\n\n    st.write(\"Edited Image\")\n    st.image(img_edited)\n\n\n\n\n\n\n\n\nExtra Advanced: Background removal\n\n\n\nWe could take this even further with the rembg library, which removes the image’s background.\nWe can’t demonstrate this interactively on this page, but the code below would work for a standard streamlit app run or hosted locally, or on streamlit community cloud.\nThis doesn’t work with stlite/browser-based Python due to dependencies of the rembg library that are unavailable via that method.\n\nimport streamlit as st\nimport io\nfrom PIL import Image\nfrom rembg import remove\n\nuploaded_image = st.file_uploader(\"Please upload an image file\", type=['png','jpg','jpeg','bmp', 'bitmap'])\n\nif uploaded_image is not None:\n\n    imagefile = io.BytesIO(uploaded_image.read())\n\n    im = Image.open(imagefile)\n\n    img_edited = remove(im)\n\n    st.write(\"Original Image\")\n    st.image(uploaded_image)\n\n    st.write(\"Edited Image\")\n    st.image(img_edited)",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Uploading Data Files, Images and More</span>"
    ]
  },
  {
    "objectID": "bidirectional_plots_and_maps.html",
    "href": "bidirectional_plots_and_maps.html",
    "title": "15  Bidirectional Inputs - Dataframes, Charts and Maps",
    "section": "",
    "text": "15.1 Dataframes\nIn the case of dataframes, maybe we want to allow users to easily select a subset of rows to be plotted on a graph or map, or use this subset of rows to calculate some summary statistics.\nLet’s load in the penguins dataset.\nNotice that we have now saved the output of st.dataframe to a variable, and also added the parameter on_select=\"rerun\".\nBefore we start filtering by what is returned, let’s first just see what actually is returned and explore how this updates.\nWe can then use the selected row indices to restrict the rows we use for subsequent calculations.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bidirectional Inputs - Dataframes, Charts and Maps</span>"
    ]
  },
  {
    "objectID": "bidirectional_plots_and_maps.html#dataframes",
    "href": "bidirectional_plots_and_maps.html#dataframes",
    "title": "15  Bidirectional Inputs - Dataframes, Charts and Maps",
    "section": "",
    "text": "Tip\n\n\n\nNote that selecting a subset of cells like this is not sufficient.\n\nYou must select the full rows using the dataset column at the far left, to the left of the index column if displayed.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe selection_mode parameter can be passed to st.dataframe to allow selection of single or multiple rows, single or multiple columns, or some combination of the two.\nNote that enabling column selection disables column sorting.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bidirectional Inputs - Dataframes, Charts and Maps</span>"
    ]
  },
  {
    "objectID": "bidirectional_plots_and_maps.html#graphs",
    "href": "bidirectional_plots_and_maps.html#graphs",
    "title": "15  Bidirectional Inputs - Dataframes, Charts and Maps",
    "section": "15.2 Graphs",
    "text": "15.2 Graphs\nStreamlit also supports monitoring st.plotly_chart, st.altair_chart, and st.vega_lite_chart for point selections and using this as an input for further actions.\n\n\n\n\n\n\nNote\n\n\n\nIn this book we focus on the use of plotly; take a look at the Streamlit documentation to see how this could work with the Altair and Vega Lite plotting libraries instead.\n\n\nWhen hovering over the plot, users are given options such as ‘box select’ (to choose a box-shaped subset of points) or lasso select (to select an irregular set of points.)\n\nLet’s start by creating a scatterplot of the penguins dataset.\nNotice that we have now saved the output of st.plotly_chart to a variable, and also added the parameter on_select=\"rerun\".\n\nNow let’s see how we could use this to update some outputs.\n\n\n\n\n\n\n\nWarning\n\n\n\nHere, we’ve just chosen a very simple example where there is no colour applied to the points in the graph.\nIf the color parameter is passed to px.scatter then the resulting point indices are related to the rows for that colour only - e.g. if we coloured by the species, then a point_index parameter of 139 wouldn’t relate back to an index of 139 in the original dataset - it would be point 139 for that particular species.\nAlways explore and test the outputs of your filtering carefully to ensure it’s returning what you think it’s returning!\nAs of the time of writing (August 2024), this feature is quite new and there are not many examples of more advanced usage of it.",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bidirectional Inputs - Dataframes, Charts and Maps</span>"
    ]
  },
  {
    "objectID": "bidirectional_plots_and_maps.html#sec-maps",
    "href": "bidirectional_plots_and_maps.html#sec-maps",
    "title": "15  Bidirectional Inputs - Dataframes, Charts and Maps",
    "section": "15.3 Maps",
    "text": "15.3 Maps\nFor maps, we need to use the external streamlit_folium library, which must be installed via pip before use - it doesn’t come bundled with Streamlit itself.\n\n15.3.1 Filtering with the bidirectional Folium Component\nWhen using this component, data is constantly being returned as the map is updated.\nLet’s take a look at what is being returned as the map is updated.\n\nimport geopandas\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport streamlit as st\nimport folium\nfrom streamlit_folium import st_folium\nfrom io import StringIO\n\ngp_list_gdf_sw = geopandas.read_file(\"https://files.catbox.moe/atzk26.gpkg\")\n\n# Filter out instances with no geometry\ngp_list_gdf_sw = gp_list_gdf_sw[~gp_list_gdf_sw['geometry'].is_empty]\n\n# Create a geometry list from the GeoDataFrame\ngeo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gp_list_gdf_sw.geometry]\n\ngp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i],\n            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\nreturned_map_data = st_folium(gp_map_tooltip)\n\nst.write(returned_map_data)\n\n\n\n15.3.1.1 Using the returned data\nLet’s get the bounds of the map to filter a dataframe to just contain the points within the area the user has zoomed to.\n\nimport geopandas\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport streamlit as st\nimport folium\nfrom streamlit_folium import st_folium\n\ngp_list_gdf_sw = geopandas.read_file(\"https://files.catbox.moe/atzk26.gpkg\")\n\n# Filter out instances with no geometry\ngp_list_gdf_sw = gp_list_gdf_sw[~gp_list_gdf_sw['geometry'].is_empty]\n\n# Create a geometry list from the GeoDataFrame\ngeo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gp_list_gdf_sw.geometry]\n\ngp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i],\n            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\nreturned_map_data = st_folium(gp_map_tooltip)\n\nxmin = returned_map_data['bounds']['_southWest']['lng']\nxmax = returned_map_data['bounds']['_northEast']['lng']\nymin = returned_map_data['bounds']['_southWest']['lat']\nymax =  returned_map_data['bounds']['_northEast']['lat']\ngp_list_gdf_filtered = gp_list_gdf_sw.cx[xmin:xmax, ymin:ymax]\n\nst.write(f\"Returning data for {len(gp_list_gdf_filtered)} practices\")\n\nst.dataframe(gp_list_gdf_filtered[['name', 'address_1', 'postcode', 'Total List Size']])",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bidirectional Inputs - Dataframes, Charts and Maps</span>"
    ]
  },
  {
    "objectID": "file_downloads_tabular.html",
    "href": "file_downloads_tabular.html",
    "title": "16  Downloading tabular files",
    "section": "",
    "text": "16.1 Saving pandas dataframes\nFor now, we’ll assume the tabular data you want to save is in a pandas dataframe.\nThis will usually be the case - or it will be data you can easily transform into a pandas dataframe, like a numpy array.\nLet’s start with an app that has some data on the popularity of names.\nThis app currently just loads in a dataset, does some simple manipulations, then returns the names that appeared most frequently in the dataset.",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Downloading tabular files</span>"
    ]
  },
  {
    "objectID": "file_downloads_tabular.html#saving-pandas-dataframes",
    "href": "file_downloads_tabular.html#saving-pandas-dataframes",
    "title": "16  Downloading tabular files",
    "section": "",
    "text": "16.1.1 Saving as csv or excel file\nIf a dataframe is displayed using the standard st.dataframe() command or the st.write() command, a csv download option will become visible when hovering over the dataframe.\n\nimport streamlit as st\nimport pandas as pd\nimport plotly.express as px\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\nname_lookup_df = pd.read_csv(url).melt(id_vars=[\"Name\", \"Gender\"]).dropna().rename(\n    columns={\"variable\": \"Year\", \"value\": \"Rank\"}\n    )\n\nnames_appearing_most_years = pd.DataFrame(name_lookup_df['Name'].value_counts())\n\nst.dataframe(names_appearing_most_years)\n\n\n\n16.1.1.1 Adding download buttons\nHowever, often we may only be displaying a graph of the data rather than displaying the data as well, or we may want to provide downloads of data files slightly different to the ones we are displaying - for example, ones with more or less columns, or providing the raw data instad of the summarised data we are displaying.\nWhen this is the case, we can instead provide download buttons to allow any python dataframe in our app’s running environment to be downloaded.\nThis is also just a bit more visible than the default .csv download button in streamlit dataframes, which is easy for your end users to miss.\n\n16.1.1.1.1 CSV files\nCSV files are relatively simple to provide a download for.\nThe key steps are\n\nuse the .to_csv() method on the dataframe without providing an output filepath\nencode this object as utf-8 using the .encode() method\npass the output of this code to the download button as the data parameter\n(OPTIONAL) provide a default file name for the resulting csv - you may want to use an f-string to intelligently provide a filename if the data is reflecting options the user has chosen\n(OPTIONAL) Specify the MIME type of the data as \"text/csv\" - an automatic value will be inferred from the data type, but it is better practice to more explicitly specify it like this\n\n\nimport streamlit as st\nimport pandas as pd\nimport plotly.express as px\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\nname_lookup_df = pd.read_csv(url)\n\nname_lookup_df = name_lookup_df.melt(id_vars=[\"Name\", \"Gender\"]).dropna().rename(\n    columns={\"variable\": \"Year\", \"value\": \"Rank\"}\n    )\n\nname_lookup_df['Year'] = name_lookup_df['Year'].astype('int64')\nname_lookup_df['Rank'] = name_lookup_df['Rank'].astype('int64')\n\ninput_name = st.text_input(\"What name would you like to lookup?\", value=\"Daniel\")\n\nindividual_df = name_lookup_df[name_lookup_df['Name'] == input_name]\n\nif input_name is not None:\n\n    st.plotly_chart(\n        px.line(individual_df,\n                y=\"Rank\", x=\"Year\", color=\"Gender\",\n                range_y=[1000, 0], range_x=[1920, 2022],\n                markers=True)\n                )\n\nst.download_button(\n   \"Click here to download the dataframe as a csv file\",\n   individual_df.to_csv(index=False).encode('utf-8'),\n   f\"{input_name}_historical_popularity.csv\",\n   \"text/csv\")\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhen using plotly, users can hover over the plot and choose ‘Download plot as a png’.\n\n\n\n\n\n16.1.1.1.2 Excel Files\nIt is slightly more complex to set up the download of a dataframe as an Excel file.\nHowever, this does have the benefit of being something your end users will be more familiar with - and with advanced usage of the xlsxwriter library that we’ll make use of, it allows us to add in multiple worksheets to a single file.\n\nimport streamlit as st\nimport pandas as pd\nimport plotly.express as px\nimport xlsxwriter\nfrom io import BytesIO\n\nurl = 'https://files.catbox.moe/eor4ta.csv'\nname_lookup_df = pd.read_csv(url)\n\nname_lookup_df = name_lookup_df.melt(id_vars=[\"Name\", \"Gender\"]).dropna().rename(\n    columns={\"variable\": \"Year\", \"value\": \"Rank\"}\n    )\n\nname_lookup_df['Year'] = name_lookup_df['Year'].astype('int64')\nname_lookup_df['Rank'] = name_lookup_df['Rank'].astype('int64')\n\ninput_name = st.text_input(\"What name would you like to lookup?\", value=\"Daniel\")\n\nindividual_df = name_lookup_df[name_lookup_df['Name'] == input_name]\n\nif input_name is not None:\n\n    st.plotly_chart(\n        px.line(individual_df,\n                y=\"Rank\", x=\"Year\", color=\"Gender\",\n                range_y=[1000, 0], range_x=[1920, 2022],\n                markers=True)\n                )\n\noutput = BytesIO()\n\nwriter = pd.ExcelWriter(output, engine='xlsxwriter')\n\nindividual_df.to_excel(writer, sheet_name=f\"{input_name} Data\", index=False)\nname_lookup_df.to_excel(writer, sheet_name=f\"Full Data\", index=False)\n\nwriter.close()\n\nst.download_button(\n   \"Click here to download the dataframe as an Excel file\",\n   data = output.getvalue(),\n   file_name=f\"{input_name}_historical_popularity.xlsx\",\n   mime=\"application/vnd.ms-excel\"\n)",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Downloading tabular files</span>"
    ]
  },
  {
    "objectID": "file_downloads_images_charts.html",
    "href": "file_downloads_images_charts.html",
    "title": "17  Downloading Images and Charts",
    "section": "",
    "text": "17.0.1 Matplotlib\nWe can provide two possible ways of downloading the output of a matplotlib plot.\nThe first involves saving the resulting plot to a file, then serving that file to the user.\n\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom palmerpenguins import load_penguins\n\npenguins = load_penguins()\n\nfig, ax = plt.subplots(figsize=(15,10))\nplt.scatter(x=penguins[\"body_mass_g\"], y=penguins[\"bill_length_mm\"])\nplt.title(\"Penguin Body Mass (g) versus Bill Length (mm)\")\nax.set_xlabel(\"Body Mass (g)\")\nax.set_ylabel(\"Bill Length (mm)\")\n\nst.pyplot(fig)\n\nfilename = 'penguins_scatter_method_1.png'\nplt.savefig(filename)\nwith open(filename, \"rb\") as img:\n    btn = st.download_button(\n        label=\"Download image\",\n        data=img,\n        file_name=filename,\n        mime=\"image/png\"\n    )\n\n\nThe second involves saving the image to tempory memory, then serving that instead.\n\nimport streamlit as st\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom palmerpenguins import load_penguins\nfrom io import BytesIO\n\npenguins = load_penguins()\n\nfig, ax = plt.subplots(figsize=(15,10))\nplt.scatter(x=penguins[\"body_mass_g\"], y=penguins[\"bill_length_mm\"])\nplt.title(\"Penguin Body Mass (g) versus Bill Length (mm)\")\nax.set_xlabel(\"Body Mass (g)\")\nax.set_ylabel(\"Bill Length (mm)\")\n\nst.pyplot(fig)\n\nimg = BytesIO()\nplt.savefig(img)\n\nbtn = st.download_button(\n    label=\"Download image\",\n    data=img,\n    file_name='penguins_scatter_method_2.png',\n    mime=\"image/png\"\n)\n\n\n\n17.0.1.1 Wordcloud Example\nThe popular wordcloud package is actually using matplotlib for its plotting!\nThis means that the same approach works for saving a wordcloud.\nHere, we are just showing the approach of saving and then serving the image - both to display it in the app and to offer it up to the end user for download.\n\nimport streamlit as st\nfrom wordcloud import WordCloud, STOPWORDS\nimport string\nimport matplotlib.pyplot as plt\n\nstopwords = set(STOPWORDS)\n\ndef make_wordcloud(text_input):\n    tokens = text_input.split()\n    punctuation_mapping_table = str.maketrans('', '', string.punctuation)\n    tokens_stripped_of_punctuation = [token.translate(punctuation_mapping_table)\n                                  for token in tokens]\n    lower_tokens = [token.lower() for token in tokens_stripped_of_punctuation]\n\n    joined_string = (\" \").join(lower_tokens)\n\n    wordcloud = WordCloud(width=1800,\n                      height=1800,\n                      background_color='white',\n                      stopwords=stopwords,\n                      min_font_size=20).generate(joined_string)\n\n    plt.figure(figsize=(30,40))\n    # Turn off axes\n    plt.axis(\"off\")\n    # Then use imshow to plot an image (here, our wordcloud)\n    plt.imshow(wordcloud)\n    # The easiest way to do this today is to save the image and reload it\n    # This works during local testing but would also work if we deployed this\n    plt.savefig(\"wordcloud.png\")\n\nsample_text = \"\"\"\nPenguins are a group of aquatic flightless birds from the family Spheniscidae of the order Sphenisciformes. They live almost exclusively in the Southern Hemisphere: only one species, the Galápagos penguin, is found north of the Equator. Highly adapted for life in the ocean water, penguins have countershaded dark and white plumage and flippers for swimming. Most penguins feed on krill, fish, squid and other forms of sea life which they catch with their bills and swallow whole while swimming. A penguin has a spiny tongue and powerful jaws to grip slippery prey.\n\nThey spend about half of their lives on land and the other half in the sea. The largest living species is the emperor penguin (Aptenodytes forsteri): on average, adults are about 1.1 m (3 ft 7 in) tall and weigh 35 kg (77 lb). The smallest penguin species is the little blue penguin (Eudyptula minor), also known as the fairy penguin, which stands around 30–33 cm (12–13 in) tall and weighs 1.2–1.3 kg (2.6–2.9 lb). Today, larger penguins generally inhabit colder regions, and smaller penguins inhabit regions with temperate or tropical climates. Some prehistoric penguin species were enormous: as tall or heavy as an adult human. There was a great diversity of species in subantarctic regions, and at least one giant species in a region around 2,000 km south of the equator 35 mya, during the Late Eocene, a climate decidedly warmer than today.\n\"\"\"\n\nyour_text = st.text_area(label=\"Enter your text here\", value=sample_text)\n\nmake_wordcloud(text_input=your_text)\n\nst.image(\"wordcloud.png\")\n\nwith open(\"wordcloud.png\", \"rb\") as file:\n    btn = st.download_button(\n        label=\"Click Here to Download Your Word Cloud!\",\n        data=file,\n        file_name=\"my_wordcloud.png\",\n        mime=\"image/png\",\n    )\n\n\n\n\n\n17.0.2 Seaborn\nSaving the file and then serving this is a good way to work with seaborn as well.\n\n\n\n\n17.0.3 Plotly\nPlotly is a bit different because the plots it produces are interactive.\n\n17.0.3.1 Built-in method for downloading static plots\nWhen using plotly, users can hover over the plot and choose ‘Download plot as a png’.\n\n\n\n17.0.3.2 Downloading the interactive plots\nWe can once again use StringIO to save the chart html temporarily to memory, then write that to a html file when the user clicks on a download button.\nThe resulting file is completely self-contained and can even be used offline. The file could be emailed or placed on a shared site like sharepoint or google drive and would work - though sometimes it requires the user to download the html file to their own machine for it to display correctly rather than just previewing the underlying html data, depending on the platform.\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\nfrom io import StringIO\n\npenguins = load_penguins()\n\naxis_options = ['bill_length_mm', 'bill_depth_mm',\n       'flipper_length_mm', 'body_mass_g']\n\ncol_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\naxis_options.remove(col_1)\n\ncol_2 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\ncolor_factor = st.selectbox(\"Select the column to colour the chart by\",\n[\"species\", \"sex\", \"island\"])\n\nfig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\ntitle=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\nst.plotly_chart(fig)\n\nbuffer = StringIO()\nfig.write_html(buffer)\n\nst.download_button(\n    label='Download This Plot as an Interactive HTML file',\n    data=buffer,\n    file_name=f'{col_1}_vs_{col_2}_by_{color_factor}.html',\n    mime='text/html'\n)\n\n\n\n\n17.0.3.3 Static outputs with a download button\nWith some additional libraries, it becomes possible to output static images when using plotly, which can give you additional control over things like the filetype and filename.\nIt requires an additional library called kaleido to be installed.\nMore about the process can be found in the Plotly documentation.\nLINK\nFor our purposes, it is perhaps quicker and more efficient to use the StringIO buffer again, so we will use to_image() instead of save_image().\nOur code would look like this.\n\n\n\n\n\n\nWarning\n\n\n\nThe kaleido library is not possible to use with stlite, so we cannot provide an interactive demo here.\n\n\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\nfrom io import StringIO\n# the kaleido package must also be installed in the environment for the saving of static plots\n# to work\npenguins = load_penguins()\n\naxis_options = ['bill_length_mm', 'bill_depth_mm',\n       'flipper_length_mm', 'body_mass_g']\n\ncol_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\naxis_options.remove(col_1)\n\ncol_2 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\ncolor_factor = st.selectbox(\"Select the column to colour the chart by\",\n[\"species\", \"sex\", \"island\"])\n\nfig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\ntitle=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\nfig.write_image(\"temp.png\", engine=\"kaleido\")\nst.plotly_chart(fig)\n\nwith open(\"temp.png\", \"rb\") as img:\n    btn = st.download_button(\n        label='Download This Plot as an Static Image File',\n        data=fig.to_image(engine='kaleido'),\n        file_name=f'{col_1}_vs_{col_2}_by_{color_factor}.png',\n        mime='img/png'\n    )\n\n\n\n\n\n\n\nImportant\n\n\n\nkaleido and streamlit seem to negatively interact sometimes, with the download button generating indefinitely.\nAt present, I’m not aware of a fix for this issue!",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Downloading Images and Charts</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps_static.html",
    "href": "file_downloads_maps_static.html",
    "title": "18  Downloading Static Maps",
    "section": "",
    "text": "18.1 Maps\nWhile there are various other libraries available for displaying maps in Python and Streamlit, we are going to focus on the two we used in module 3 of the HSMA course\nFor more of a reminder on how to work with geographic data and create maps, you can refer to the HSMA geographic modelling and visualisation book.",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Downloading Static Maps</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps_static.html#maps",
    "href": "file_downloads_maps_static.html#maps",
    "title": "18  Downloading Static Maps",
    "section": "",
    "text": "matplotlib (which creates static maps)\nfolium (which creates a leaflet.js interactive map)",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Downloading Static Maps</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps_static.html#downloading-static-maps-made-with-matplotlib",
    "href": "file_downloads_maps_static.html#downloading-static-maps-made-with-matplotlib",
    "title": "18  Downloading Static Maps",
    "section": "18.2 Downloading Static Maps Made With Matplotlib",
    "text": "18.2 Downloading Static Maps Made With Matplotlib\nLet’s just start by plotting a map.\n\n\n18.2.0.1 A map with subplots\nStatic maps with subplots are much the same - you are just interested in saving the fig object to a temporary .png image file before then serving that temporary file to the user.\n\n\n\n18.2.0.2 Multiple Separate Maps\nWhat if we want to create several different maps instead of using the subplot feature?\nWe could do this and then provide a download button for each.",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Downloading Static Maps</span>"
    ]
  },
  {
    "objectID": "file_downloads_maps_interactive.html",
    "href": "file_downloads_maps_interactive.html",
    "title": "19  Downloading Interactive Maps",
    "section": "",
    "text": "19.0.1 Folium\nInteractive maps can be created using the Folium package.\nFolium maps cannot be displayed in Streamlit by default, but can be imported using the st-folium custom component.\nOne way to provide them as downloadable objects is to save the html object temporarily, then pass this to our download button, similar to some of the other downloads we have created.\n\nimport geopandas\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport streamlit as st\nimport folium\nfrom streamlit_folium import st_folium\n\ngp_list_gdf_sw = geopandas.read_file(\"https://files.catbox.moe/atzk26.gpkg\")\n\n# Filter out instances with no geometry\ngp_list_gdf_sw = gp_list_gdf_sw[~gp_list_gdf_sw['geometry'].is_empty]\n\n# Create a geometry list from the GeoDataFrame\ngeo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gp_list_gdf_sw.geometry]\n\ngp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i],\n            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\nst_folium(gp_map_tooltip)\n\ngp_map_tooltip.save(\"gp_map_devon.html\")\n\nwith open(\"gp_map_devon.html\", \"rb\") as map_file_html:\n    st.download_button(\n        label='Download This Map as an Interactive HTML file',\n        data=map_file_html,\n        file_name=f'Devon GP Map.html',\n        mime='text/html'\n    )",
    "crumbs": [
      "Downloading Outputs",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Downloading Interactive Maps</span>"
    ]
  },
  {
    "objectID": "layout_columns.html",
    "href": "layout_columns.html",
    "title": "21  Columns",
    "section": "",
    "text": "21.1 Creating Columns in Streamlit\nStreamlit has a very easy to use column interface for improving the layout of your apps.\nColumns look like this in a Streamlit app.\nimport streamlit as st\n\n1col1, col2, col3 = st.columns(3)\n\n2with col1:\n3  st.header(\"I'm Column 1\")\n  st.write(\"Here's the 'Back to the Future' poster. Images, videos, data tables and more can be displayed within columns.\")\n  st.image(\"https://upload.wikimedia.org/wikipedia/en/d/d2/Back_to_the_Future.jpg\")\n\n4with col2:\n  st.header(\"I'm Column 2\")\n  st.write(\"We can use inputs within columns too.\")\n  name = st.text_input(\"What's your name?\", value=None)\n  if name is not None:\n    st.write(f\"Nice to meet you, {name}!\")\n  else:\n    st.write(\"I can't greet you until you enter your name!\")\n\nwith col3:\n    if name is not None:\n      st.write(f\"Hello again, {name}!\")\n      st.write(\"Isn't it cool that variables persist across different columns? This can be really handy!\")\n      st.video(\"https://youtu.be/dQw4w9WgXcQ?feature=shared\")\n    else:\n      st.write(\"I can't greet you until you enter your name! Go back to column 2 and do that.\")\n\n\n1\n\nFirst, we pass the number of columns we want to create to the st.columns() function. We can then unpack the output of this to a number of variables separated by commas. For example, st.columns(2) produces two variables, while st.columns(4) would produce 4.\n\n2\n\nWe can then use the with statement and refer to the first column of interest. Columns work from left to right; in this case, that means the variable col1 will be the leftmost column, and as we didn’t specify the width of the columns, they will automatically take up a third of the screen in this case. With 2 columns each would take up half, and with 4 each would take up a quarter.\n\n3\n\nNote that everything we want to appear within the column, we indent.\n\n4\n\nWe can then move on to specifying what we want to appear in the next column, using the same structure of with, the variable relating to the column of interested, and an indented block of code.",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Columns</span>"
    ]
  },
  {
    "objectID": "layout_columns.html#the-two-main-syntax-options-for-streamlit-columns",
    "href": "layout_columns.html#the-two-main-syntax-options-for-streamlit-columns",
    "title": "21  Columns",
    "section": "21.2 The two main syntax options for Streamlit columns",
    "text": "21.2 The two main syntax options for Streamlit columns\nThere are two main ways to put content inside of columns.\n\nUsing a ‘with’ statement and indenting the code that should sit within the column, as we did above.\n\n\nimport streamlit as st\ncol_a, col_b = st.columns(2)\n\nwith col_a:\n    st.text(\"This is some content within column 1\")\n\nwith col_b:\n    st.text(\"This is some content within column 2\")\n\n\nReplacing the st in sections like st.text() with the variable name for the given column.\n\n\nimport streamlit as st\n\ncol_a, col_b = st.columns(2)\n\ncol_a.text(\"This is some content within column 1\")\n\ncol_b.text(\"This is some content within column 2\")\n\nThe outputs of both of these bits of code are identical!",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Columns</span>"
    ]
  },
  {
    "objectID": "layout_columns.html#adjusting-column-width",
    "href": "layout_columns.html#adjusting-column-width",
    "title": "21  Columns",
    "section": "21.3 Adjusting Column Width",
    "text": "21.3 Adjusting Column Width\nColumn width can be controlled by",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Columns</span>"
    ]
  },
  {
    "objectID": "layout_columns.html#advanced-column-layouts",
    "href": "layout_columns.html#advanced-column-layouts",
    "title": "21  Columns",
    "section": "21.4 Advanced Column Layouts",
    "text": "21.4 Advanced Column Layouts\nThe great thing about columns is that we can have multiple sets of columns, allowing you to build up fairly complex grid-like layouts.\nHere, we have an example of a top section with three equal-width columns, a central section that uses the full width of the screen, and a final section with two unequal-width columns.\nIt also demonstrates how you can mix and match the use of the with syntax and the col.command syntax within a single Streamlit app.\n\nimport streamlit as st\nimport micropip\nawait micropip.install(\"plotly\")\nawait micropip.install(\"streamlit-extras\")\nimport plotly.express as px\nimport pandas as pd\nfrom streamlit_extras.metric_cards import style_metric_cards\n\nst.set_page_config(layout=\"wide\")\n\nst.title(\"Activity Dashboard\")\n\ncol1, col2, col3 = st.columns(3)\n\ncol1.metric(label=\"Total Number of Patients Seen this Week\", value=52)\n\ncol2.metric(label=\"Number of Patients Seen this Week - South\", value=30, delta=-5)\n\ncol2.metric(label=\"Number of Patients Seen this Week - North\", value=12, delta=-7)\n\ncol3.metric(label=\"Number of Patients Seen this Year\", value=1302)\n\nstyle_metric_cards(background_color=\"#6434eb\", border_color= \"#eb9234\", border_size_px=3)\n\npatients_seen_df = pd.DataFrame(\n  {\n    'Week': ['2021-01-01', '2021-01-08', '2021-01-15', '2021-01-22', '2021-01-29', '2021-02-05'],\n    'Patients Seen': [24, 12, 43, 23, 32, 25]\n  }\n)\n\nst.plotly_chart(\n  px.line(patients_seen_df, x='Week', y='Patients Seen', title=\"Total Patients Seen per Week\"),\n  use_container_width=True\n  )\n\ncol4, col5 = st.columns([0.3, 0.7])\n\nwith col4:\n    st.write(\"Here's some text in this extra column. It's not a very wide column!\")\n\nwith col5:\n    st.video(\"https://youtu.be/dQw4w9WgXcQ?feature=shared\")",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Columns</span>"
    ]
  },
  {
    "objectID": "layout_sidebar.html",
    "href": "layout_sidebar.html",
    "title": "22  Sidebar",
    "section": "",
    "text": "22.1 Collapsible Sidebars\nThe Streamlit sidebar gives us a distinct area on the left-hand side of the screen to use.\nimport streamlit as st\n\n1with st.sidebar:\n2  st.header(\"I'm a sidebar\")\n  st.write(\"We can use inputs our sidebar too.\")\n  name = st.text_input(\"What's your name?\", value=None)\n\nst.title(\"Greeting App!\")\n\n3if name is not None:\n  st.write(f\"Nice to meet you, {name}!\")\nelse:\n  st.write(\"I can't greet you until you enter your name!\")\n\n\n1\n\nWe can use the with notation along with st.sidebar to create the sidebar\n\n2\n\nWe indent the code we want to exist within the sidebar\n\n3\n\nOnce we write a line of code that is not indented, this signals the beginning of code that will just appear in the main area of the streamlit app.",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Sidebar</span>"
    ]
  },
  {
    "objectID": "layout_sidebar.html#collapsible-sidebars",
    "href": "layout_sidebar.html#collapsible-sidebars",
    "title": "22  Sidebar",
    "section": "",
    "text": "22.1.1 Collapsing, expanding and resizing the sidebar\nWhen hovering over the sidebar, we can see this arrow appear.\n\nClicking on this collapses the sidebar, making the main body of the app take up the full width.\n\nThis can be very handy - but be aware that it may make for a non-intuitive experience for your end users.\nHovering over the point where the sidebar ends and the main part of the app begins, our cursor will change to indicate that the sidebar can be resized. Clicking and dragging will allow us to make the sidebar narrower and wider, within some predefined limits.",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Sidebar</span>"
    ]
  },
  {
    "objectID": "layout_sidebar.html#alternative-sidebar-syntax",
    "href": "layout_sidebar.html#alternative-sidebar-syntax",
    "title": "22  Sidebar",
    "section": "22.2 Alternative sidebar syntax",
    "text": "22.2 Alternative sidebar syntax\nLike a lot of other layout elements, such as columns and tabs, there are multiple ways to refer to the sidebar, and which is best may depend on precisely what you are trying to do with your app.\n\nUse the with notation, as above.\n\n\nimport streamlit as st\n\nwith st.sidebar:\n2  st.header(\"I'm a sidebar\")\n  st.write(\"We can use inputs our sidebar too.\")\n  name = st.text_input(\"What's your name?\", value=None)\n\nst.title(\"Greeting App!\")\n\nif name is not None:\n  st.write(f\"Nice to meet you, {name}!\")\nelse:\n  st.write(\"I can't greet you until you enter your name!\")\n\n\n2\n\nWherever you would use a component that begins with st. (e.g. st.text(), st.number_input()), replace this with st.sidebar() (e.g. st.sidebar.text(), st.sidebar.number_input())\n\n\n\n\nThe code below is completely equivalent to the code above.\n\nimport streamlit as st\n\nst.sidebar.header(\"I'm a sidebar\")\nst.sidebar.write(\"We can use inputs our sidebar too.\")\nname = st.sidebar.text_input(\"What's your name?\", value=None)\n\nst.title(\"Greeting App!\")\n\nif name is not None:\n  st.write(f\"Nice to meet you, {name}!\")\nelse:\n  st.write(\"I can't greet you until you enter your name!\")\n\n\n\n\n\n\n\nNote\n\n\n\nYou can often mix and match the approaches within an app too - though picking one approach may be easier for the next person who interacts with your code to follow. If it’s a good way of achieving what you need to, though, then you can go ahead and do this!",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Sidebar</span>"
    ]
  },
  {
    "objectID": "layout_sidebar.html#initial-sidebar-state",
    "href": "layout_sidebar.html#initial-sidebar-state",
    "title": "22  Sidebar",
    "section": "22.3 Initial sidebar state",
    "text": "22.3 Initial sidebar state\nWhile there are not many ways to customise your sidebar from within streamlit, you can adjust whether it displays as being visible or not by default using st.set_page_config().\n\n\n\n\n\n\nTip\n\n\n\nst.set_page_config() has to be the first streamlit command you run after importing streamlit.\nYou can run other general python commands between the import and setting the page config - but you cannot, for example, use st.header() before calling st.set_page_config().\n\n\n\nimport streamlit as st\n\nst.set_page_config(initial_sidebar_state='collapsed')\n\nwith st.sidebar:\n  st.header(\"I'm a sidebar\")\n\nst.title(\"Collapsed Sidebar Demo!\")\n\nst.write(\"The sidebar in this app is closed by default. Click on the arrow in the top left of the screen to open it.\")",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Sidebar</span>"
    ]
  },
  {
    "objectID": "layout_sidebar.html#multipage-app-navigation",
    "href": "layout_sidebar.html#multipage-app-navigation",
    "title": "22  Sidebar",
    "section": "22.4 Multipage app navigation",
    "text": "22.4 Multipage app navigation\nLater in the book we discuss multipage apps, which use the sidebar by default for page navigation.\nAny things you add to your app’s sidebar will just appear below the list of pages.",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Sidebar</span>"
    ]
  },
  {
    "objectID": "layout_sidebar.html#sidebar-styling",
    "href": "layout_sidebar.html#sidebar-styling",
    "title": "22  Sidebar",
    "section": "22.5 Sidebar styling",
    "text": "22.5 Sidebar styling\n\n22.5.1 Sidebar Colour\nThe sidebar colour can be updated using Streamlit’s theming feature.\nThe colour that needs changing is the secondaryBackgroundColor in the config.toml file.\nMore detail about theming with config.toml can be found in a later chapter.\n\n\n22.5.2 Making the sidebar expander more obvious\nWith custom CSS, we can make the sidebar expander button more obvious.\n\n\n\n22.5.3 Sidebar Font colour and size\nIf using multipage apps, you may need some futher customisations to make the sidebar look good with the colour changes you make. However, more advanced customisations require using CSS.\nHere is an example where we change the default font colour of the auto-generated navigation items.\n\n\n\n\n\n\nWarning\n\n\n\nAs the streamlit library evolves, the names of various elements on the page may change, meaning that these may not remain consistent over time.\n\n\n\n# Credit to Amy H in the PenCHORD team for this!\n# https://github.com/kailo-beewell/kailo_beewell_dashboard_package/blob/be249c515d5cfd7d168abf14f03927322b72322b/kailo_beewell_dashboard/css/style.css#L2\n\nst.markdown(\n  \"\"\"\n&lt;style&gt;\n/* Sidebar font color as default is to set non-selected to more transparent */\n[data-testid=stSidebarNavItems] &gt; li &gt; div &gt; a &gt; span\n{\n    color: #05291F;\n}\n\n/* Sidebar font size */\n    [data-testid=stSidebarNavItems]\n    {\n        font-size: 25px;\n    }\n\n&lt;/style&gt;\n  \"\"\",\n  unsafe_allow_html=True\n)",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Sidebar</span>"
    ]
  },
  {
    "objectID": "layout_tabs.html",
    "href": "layout_tabs.html",
    "title": "23  Tabs",
    "section": "",
    "text": "23.1 Tabs in Streamlit\nTabs are an extremely useful way to organise your page into something that is easier to navigate.\nTabs look like this in a Streamlit app.\nimport streamlit as st\n\ntab1, tab2, tab3 = st.tabs([\"This is Tab 1\", \"This is the Second Tab\", \"Tab 3 is Here!\"])\n\nwith tab1:\n  st.header(\"I'm Tab 1\")\n  st.write(\"Here's the 'Back to the Future' poster. Images, videos, data tables and more can be displayed within tabs.\")\n  st.image(\"https://upload.wikimedia.org/wikipedia/en/d/d2/Back_to_the_Future.jpg\")\n\nwith tab2:\n  st.header(\"I'm Tab 2\")\n  st.write(\"We can use inputs within tabs too.\")\n  name = st.text_input(\"What's your name?\", value=None)\n  if name is not None:\n    st.write(f\"Nice to meet you, {name}!\")\n  else:\n    st.write(\"I can't greet you until you enter your name!\")\n\nwith tab3:\n    if name is not None:\n      st.write(f\"Hello again, {name}!\")\n      st.write(\"Isn't it cool that variables persist across different tabs? This can be really handy!\")\n      st.video(\"https://youtu.be/dQw4w9WgXcQ?feature=shared\")\n    else:\n      st.write(\"I can't greet you until you enter your name! Go back to tab 2 and do that.\")",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Tabs</span>"
    ]
  },
  {
    "objectID": "layout_tabs.html#the-two-main-syntax-options-for-streamlit-tabs",
    "href": "layout_tabs.html#the-two-main-syntax-options-for-streamlit-tabs",
    "title": "23  Tabs",
    "section": "23.2 The two main syntax options for streamlit tabs",
    "text": "23.2 The two main syntax options for streamlit tabs\nThere are two main ways to put content inside of tabs.\n\nUsing a ‘with’ statement and indenting the code that should sit within the tab.\n\n\nimport streamlit as st\ntab_a, tab_b = st.tabs([\"A Tab\", \"Another Tab\"])\n\nwith tab_a:\n    st.text(\"This is some content within tab 1\")\n\nwith tab_b:\n    st.text(\"This is some content within tab 2\")\n\n\nReplacing the st in sections like st.text() with the variable name for the given tab.\n\n\nimport streamlit as st\n\ntab_a, tab_b = st.tabs([\"A Tab\", \"Another Tab\"])\n\ntab_a.text(\"This is some content within tab 1\")\n\ntab_b.text(\"This is some content within tab 2\")\n\nThe outputs of both of these bits of code are identical!\nIt’s up to you to choose which you prefer.",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Tabs</span>"
    ]
  },
  {
    "objectID": "layout_tabs.html#automatically-generating-variable-numbers-of-tabs",
    "href": "layout_tabs.html#automatically-generating-variable-numbers-of-tabs",
    "title": "23  Tabs",
    "section": "23.3 Automatically generating variable numbers of tabs",
    "text": "23.3 Automatically generating variable numbers of tabs\nIn some instances, you may wish to reactively create a different number of tabs.\nIn this example, notice what happens to the random numbers as you change the number of tabs being generated.\n\n23.3.1 Using the ‘tab.’ syntax\n\nimport streamlit as st\nimport random\n\nnumber_of_tabs_to_create = st.number_input(\"Enter the number of tabs you want to create\", 2, 5, 3)\n\ntab_list =  st.tabs([f\"Tab {i+1}\" for i in range(number_of_tabs_to_create)])\n\nfor idx, tab in enumerate(tab_list):\n  tab.header(f\"This is tab {idx+1}\")\n  tab.write(f\"Your random number for this tab is {random.randint(0, 10)}\")\n\n\n\n\n23.3.2 Using the ‘with’ syntax\nIt’s also possible to do this using the ‘with’ syntax.\nIn this example, in every separate tab, we pull back a random wikipedia page.\n(However, due to the way this works behind the scenes, we don’t get a new page on changing the number of tabs even though the app is rerunning each time)\n\nimport streamlit as st\nimport streamlit.components.v1 as components\n\nnumber_of_tabs_to_create = st.number_input(\"Enter the number of tabs you want to create\", 2, 5, 3)\n\ntab_list =  st.tabs([f\"Tab {i+1}\" for i in range(number_of_tabs_to_create)])\n\nfor idx, tab in enumerate(tab_list):\n  with tab:\n    st.header(f\"This is tab {idx+1}\")\n    components.iframe(\"https://commons.wikimedia.org/wiki/Special:Random/File\", height=500)",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Tabs</span>"
    ]
  },
  {
    "objectID": "layout_tabs.html#custom-styling-of-tabs",
    "href": "layout_tabs.html#custom-styling-of-tabs",
    "title": "23  Tabs",
    "section": "23.4 Custom Styling of Tabs",
    "text": "23.4 Custom Styling of Tabs\nHere is an example of how to change the tab formatting.\n\n\n\n\n\n\nWarning\n\n\n\nThis is not a supported part of Streamlit - the ways in which streamlit internally names these tabs may change over time, causing this code to no longer work.\n\n\n\n# Credit to user 'Dallas on https://discuss.streamlit.io/t/customizing-the-appearance-of-tabs/48913\n\nimport streamlit as st\n\ncustom_css = \"\"\"\n&lt;style&gt;\n    .stTabs [data-baseweb=\"tab-list\"] {\n        gap: 2px;\n    }\n\n    .stTabs [data-baseweb=\"tab\"] {\n        height: 50px;\n        white-space: pre-wrap;\n        background-color: #32a852;\n        border-radius: 4px 4px 0px 0px;\n        gap: 1px;\n        padding-top: 10px;\n        padding-bottom: 10px;\n    }\n\n    .stTabs [aria-selected=\"true\"] {\n        background-color: #912a90;\n    }\n\n&lt;/style&gt;\n\"\"\"\n\nst.markdown(custom_css, unsafe_allow_html=True)\n\ntab_a, tab_b = st.tabs([\"A Tab\", \"Another Tab\"])\n\nwith tab_a:\n    st.text(\"This is some content within tab 1\")\n\nwith tab_b:\n    st.text(\"This is some content within tab 2\")",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Tabs</span>"
    ]
  },
  {
    "objectID": "layout_expander.html",
    "href": "layout_expander.html",
    "title": "24  Expanders",
    "section": "",
    "text": "24.1 Nesting expanders in other layout elements\nExpanders can sit within other layout elements.\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\n\ntab1, tab2 = st.tabs([\"Penguin Graphs\", \"Penguin Facts\"])\n\npenguins = load_penguins()\n\nwith tab1:\n\n    col1, col2 = st.columns(2)\n\n    with col1:\n        fig = px.scatter(penguins, x='bill_length_mm', y='bill_depth_mm', color=\"sex\",\n        title=f\"Penguins Dataset - Bill Length (mm) vs Bill Depth (mm), coloured by Sex\")\n\n        st.plotly_chart(fig)\n\n        with st.expander(\"Click here to see the code for the graph\"):\n            st.code(\n              \"\"\"\n              fig = px.scatter(penguins, x='bill_length_mm', y='bill_depth_mm', color=\"sex\",\n                    title=f\"Penguins Dataset - Bill Length (mm) vs Bill Depth (mm), coloured by Sex\")\n              \"\"\"\n            )\n\n    with col2:\n        fig = px.scatter(penguins, x='flipper_length_mm', y='body_mass_g', color=\"species\",\n                    title=f\"Penguins Dataset - Flipper Length (mm) vs Body Weight(g), coloured by Species\")\n\n        st.plotly_chart(fig)\n\n        with st.expander(\"Click here to see the code for the graph\"):\n            st.code(\n              \"\"\"\n              fig = px.scatter(penguins, x='flipper_length_mm', y='body_mass_g', color=\"species\",\n                    title=f\"Penguins Dataset - Flipper Length (mm) vs Body Weight(g), coloured by Species\")\n              \"\"\"\n            )\n\n    with st.expander(\"Click here to see the underlying data\"):\n        st.dataframe(penguins)\n\nwith tab2:\n    st.header(\"Penguin Facts\")\n    st.subheader(\"Gentoo Penguins\")\n\n    st.write(\n      \"\"\"\n      The gentoo penguin (JEN-too) (Pygoscelis papua) is a penguin species (or possibly a species complex) in the genus Pygoscelis, most closely related to the Adélie penguin (P. adeliae) and the chinstrap penguin (P. antarcticus). The earliest scientific description was made in 1781 by Johann Reinhold Forster with a type locality in the Falkland Islands. The species calls in a variety of ways, but the most frequently heard is a loud trumpeting, which the bird emits with its head thrown back.\n      \"\"\"\n    )\n\n    expander_video = st.expander(\"Click here to watch a penguin video\")\n    expander_video.video(\"https://www.youtube.com/watch?v=nFAK8Vj62WM\")",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Expanders</span>"
    ]
  },
  {
    "objectID": "multipage.html",
    "href": "multipage.html",
    "title": "25  Multipage Apps",
    "section": "",
    "text": "25.1 Method 1: ‘st.Page’ and ‘st.navigation’\nLet’s first take a look at the multipage app itself and explore how a multipage app behaves.\nThe recommended method for multipage apps in Streamlit is to\nIn this example, we have a folder that looks like this\nWhen starting up the app, we will simply be running streamlit run app.py from within the\nLet’s take a look at the contents of app.py\nLet’s now look at the code for one of the other pages: Interactive_Data_Explorer.py, which appears as “Interactive Data Explorer” in the sidebar of the app.\nNote that it looks like a completely standard streamlit app - in fact, this particular page could run completely fine by itself!",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Multipage Apps</span>"
    ]
  },
  {
    "objectID": "multipage.html#method-1-st.page-and-st.navigation",
    "href": "multipage.html#method-1-st.page-and-st.navigation",
    "title": "25  Multipage Apps",
    "section": "",
    "text": "Tip\n\n\n\nThe key things to take away are that\n\nvariables are not shared across different app pages\nmoving to a different page will reset the value of any inputs\n\n\n\n\n\ncreate a page that is responsible for routing users to different pages\n\nin this file, we can do additional things like set up the displayed names of each page and add icons before the page names\n\ncreate your actual pages\n\n\n\n\n\nimport streamlit as st\n\npg = st.navigation(\n    [st.Page(\"Homepage.py\", title=\"Welcome!\", icon=\":material/add_circle:\"),\n     st.Page(\"Penguin_Information.py\"),\n     st.Page(\"Penguin_Trends.py\"),\n     st.Page(\"Interactive_Data_Explorer.py\"),\n     st.Page(\"Sidebar_Theming.py\"),\n     ]\n     )\n\npg.run()\n\n\n\n\n\n\n\n\nNote\n\n\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\n\nst.title(\"Interactive Data Explorer\")\n\nst.write(\"Here, let's explore what happens to values we've input when moving to a different page.\")\n\nst.write(\"If you enter your name on this page, the rest of the page will load.\")\n\nst.write(\"Try then moving to a different page using the navigation sidebar before returning to this page.\")\n\nst.write(\"What do you notice?\")\n\nuser_name = st.text_input(\"Enter Your Name\", None)\n\nif user_name is None:\n    st.write(f\"Please enter your name to load the rest of the page\")\nelse:\n    st.write(f\"Welcome to the interactive penguin data explorer, {user_name}!\")\n\n    penguins = load_penguins()\n\n    axis_options = ['bill_length_mm', 'bill_depth_mm',\n        'flipper_length_mm', 'body_mass_g']\n\n    col_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\n    axis_options.remove(col_1)\n\n    col_2 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\n    color_factor = st.selectbox(\"Select the column to colour the chart by\",\n    [\"species\", \"sex\", \"island\"])\n\n    fig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\n    title=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\n    st.plotly_chart(fig)\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe .streamlit folder contains config.toml, which is used to set the colourscheme of the app\nThe requirements.txt file contains the required packages for the app, which will then be installed automatically when we deploy the app to the streamlit community cloud.\n\n\n\n25.1.1 Nested Sidebars\nBy modifying our main page’s code, we can create subsections within our navigation bars, which can be very helpful for more complex apps.\nimport streamlit as st\n\n1homepage = st.Page(\"Homepage.py\", title=\"Welcome!\", icon=\":material/add_circle:\")\ninfo_page = st.Page(\"Penguin_Information.py\")\ntrends_page = st.Page(\"Penguin_Trends.py\")\nexplorer_page = st.Page(\"Interactive_Data_Explorer.py\")\ntheming_page = st.Page(\"Sidebar_Theming.py\")\n\n2pg = st.navigation(\n    {\n        \"Section 1\": [homepage],\n        \"Section 2\": [info_page, trends_page],\n        \"Section 3\": [explorer_page, theming_page]\n    }\n     )\n\npg.run()\n\n1\n\nInstead of passing the st.Page calls directly into st.navigation we have created a variable per page. This isn’t strictly necessary, but makes it a lot easier to keep track of what’s going on in our use of st.navigation.\n\n2\n\nWe can",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Multipage Apps</span>"
    ]
  },
  {
    "objectID": "multipage.html#method-2-pages-subfolder",
    "href": "multipage.html#method-2-pages-subfolder",
    "title": "25  Multipage Apps",
    "section": "25.2 Method 2: ‘pages’ subfolder",
    "text": "25.2 Method 2: ‘pages’ subfolder\nOne other common way to deal with multipage apps is to have a .py file that is designed to be your main homepage, with all other pages being stored within a ‘pages’ subfolder.\nAt the time of writing, this is still used in some examples in the Streamlit documentation, so it is useful to be aware of, and it does have the benefit of being an automated way\n\n\n\n\n\n\nWarning\n\n\n\nThe subfolder has to be called pages to be picked up! You cannot rename it to something else.\n\n\nWe would start this app by running streamlit run Homepage.py when we have navigated to the same folder level as Homepage.py in our terminal.\nLet’s look at an example multipage app with 5 pages.\n\nThe structure of our app in our filesystem looks like this; in Windows explorer, this is how the files and folders appear.\n\nThe ‘pages’ folder\n\nThe numbers at the beginning of the filenames indicate the order these will appear in the sidebar.\n\n\n\n\n\n\nClick here for the code for the homepage\n\n\n\n\n\nimport streamlit as st\n\nst.set_page_config(layout=\"wide\", page_title=\"Homepage\")\n\nst.title(\"Welcome to the penguin app!\")\n\nspecies_options = [\"Gentoo\", \"Chinstrap\", \"Adelie\"]\n\nchosen_species = st.selectbox(\"Which penguin species are you interested in finding out more about?\", species_options)\n\nif chosen_species == \"Gentoo\":\n    st.write(\n        \"\"\"\n        The gentoo penguin (JEN-too) (Pygoscelis papua) is a penguin species (or possibly a species complex) in the genus Pygoscelis, most closely related to the Adélie penguin (P. adeliae) and the chinstrap penguin (P. antarcticus). The earliest scientific description was made in 1781 by Johann Reinhold Forster with a type locality in the Falkland Islands. The species calls in a variety of ways, but the most frequently heard is a loud trumpeting, which the bird emits with its head thrown back.\n        \"\"\"\n    )\nelif chosen_species == \"Chinstrap\":\n    st.write(\n        \"\"\"\nThe chinstrap penguin (Pygoscelis antarcticus) is a species of penguin that inhabits a variety of islands and shores in the Southern Pacific and the Antarctic Oceans. Its name stems from the narrow black band under its head, which makes it appear as if it were wearing a black helmet, making it easy to identify.[2] Other common names include ringed penguin, bearded penguin, and stonecracker penguin, due to its loud, harsh call.[3]\n        \"\"\"\n    )\n\nelif chosen_species == \"Adelie\":\n    st.write(\n        \"\"\"\n        The Adélie penguin (Pygoscelis adeliae) is a species of penguin common along the entire coast of the Antarctic continent, which is the only place where it is found. It is the most widespread penguin species, and, along with the emperor penguin, is the most southerly distributed of all penguins. It is named after Adélie Land, in turn, named for Adèle Dumont d'Urville, who was married to French explorer Jules Dumont d'Urville, who first discovered this penguin in 1840. Adélie penguins obtain their food by both predation and foraging, with a diet of mainly krill and fish.\n        \"\"\"\n    )\n\nst.markdown(\"*All information from wikipedia*\")\n\n\n\n\n\n\n\n\n\nClick here for the code for the second page\n\n\n\n\n\nimport streamlit as st\n\nst.write(\"Let's try loading in a variable from the previous page.\")\n\nwith st.expander(\"Click here to see the code that made the homepage\"):\n    st.code(\"\"\"\n            import streamlit as st\n\nst.set_page_config(layout=\"wide\", page_title=\"Homepage\")\n\nst.title(\"Welcome to the penguin app!\")\n\nspecies_options = [\"Gentoo\", \"Chinstrap\", \"Adelie\"]\n\nchosen_species = st.selectbox(\"Which penguin species are you interested in finding out more about?\", species_options)\n\nif chosen_species == \"Gentoo\":\n    st.write(\n        '''\n        The gentoo penguin (JEN-too) (Pygoscelis papua) is a penguin species (or possibly a species complex) in the genus Pygoscelis, most closely related to the Adélie penguin (P. adeliae) and the chinstrap penguin (P. antarcticus). The earliest scientific description was made in 1781 by Johann Reinhold Forster with a type locality in the Falkland Islands. The species calls in a variety of ways, but the most frequently heard is a loud trumpeting, which the bird emits with its head thrown back.\n        '''\n    )\nelif chosen_species == \"Chinstrap\":\n    st.write(\n        '''\nThe chinstrap penguin (Pygoscelis antarcticus) is a species of penguin that inhabits a variety of islands and shores in the Southern Pacific and the Antarctic Oceans. Its name stems from the narrow black band under its head, which makes it appear as if it were wearing a black helmet, making it easy to identify.[2] Other common names include ringed penguin, bearded penguin, and stonecracker penguin, due to its loud, harsh call.[3]\n        '''\n    )\n\nelif chosen_species == \"Adelie\":\n    st.write(\n        '''\n        The Adélie penguin (Pygoscelis adeliae) is a species of penguin common along the entire coast of the Antarctic continent, which is the only place where it is found. It is the most widespread penguin species, and, along with the emperor penguin, is the most southerly distributed of all penguins. It is named after Adélie Land, in turn, named for Adèle Dumont d'Urville, who was married to French explorer Jules Dumont d'Urville, who first discovered this penguin in 1840. Adélie penguins obtain their food by both predation and foraging, with a diet of mainly krill and fish.\n        '''\n    )\n\nst.markdown(\"*All information from wikipedia*\")\n\"\"\")\n\nst.write(\"We're going to try loading the `species_options` list in, which just contains the strings 'Gentoo', 'Adelie' and 'Chinstrap'.\")\n\nst.write(\"What we'll see is that it doesn't work and instead returns an error. This is because the variables on the other pages are completely separate and can't be accessed on this page.\")\n\nst.write(\"This is a key thing to be aware of within multipage apps. Without using things like session state, we can't use information from other pages on this page, and vice-versa\")\n\nchosen_species = st.selectbox(\"Which penguin species are you interested in finding out more about?\", species_options)\n\n\n\n\n\n\n\n\n\nClick here for the code for the third page\n\n\n\n\n\nimport streamlit as st\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\n\nst.write(\"All of the things we've learned about so far can be used within a multipage app!\")\n\nst.write(\"Just remember that each page is effectively a self-contained app - without using things like session state, we can't use information from other pages on this page, and vice-versa.\")\n\ntab1, tab2 = st.tabs([\"Penguin Graphs\", \"Video\"])\n\npenguins = load_penguins()\n\nwith tab1:\n\n    col1, col2 = st.columns(2)\n\n    with col1:\n        fig = px.scatter(penguins, x='bill_length_mm', y='bill_depth_mm', color=\"sex\",\n        title=f\"Penguins Dataset - Bill Length (mm) vs Bill Depth (mm), coloured by Sex\")\n\n        st.plotly_chart(fig)\n\n        with st.expander(\"Click here to see the code for the graph\"):\n            st.code(\n              \"\"\"\n              fig = px.scatter(penguins, x='bill_length_mm', y='bill_depth_mm', color=\"sex\",\n                    title=f\"Penguins Dataset - Bill Length (mm) vs Bill Depth (mm), coloured by Sex\")\n              \"\"\"\n            )\n\n    with col2:\n        fig = px.scatter(penguins, x='flipper_length_mm', y='body_mass_g', color=\"species\",\n                    title=f\"Penguins Dataset - Flipper Length (mm) vs Body Weight(g), coloured by Species\")\n\n        st.plotly_chart(fig)\n\n        with st.expander(\"Click here to see the code for the graph\"):\n            st.code(\n              \"\"\"\n              fig = px.scatter(penguins, x='flipper_length_mm', y='body_mass_g', color=\"species\",\n                    title=f\"Penguins Dataset - Flipper Length (mm) vs Body Weight(g), coloured by Species\")\n              \"\"\"\n            )\n\n    with st.expander(\"Click here to see the underlying data\"):\n        st.dataframe(penguins)\n\nwith tab2:\n    st.header(\"Penguin Video\")\n\n    expander_video = st.expander(\"Click here to watch a penguin video\")\n    expander_video.video(\"https://www.youtube.com/watch?v=nFAK8Vj62WM\")\n\n\n\n\n\n\n\n\n\nClick here for the code for the fourth page\n\n\n\n\n\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\n\nst.title(\"Interactive Data Explorer\")\n\nst.write(\"Here, let's explore what happens to values we've input when moving to a different page.\")\n\nst.write(\"If you enter your name on this page, the rest of the page will load.\")\n\nst.write(\"Try then moving to a different page using the navigation sidebar before returning to this page.\")\n\nst.write(\"What do you notice?\")\n\nuser_name = st.text_input(\"Enter Your Name\", None)\n\nif user_name is None:\n    st.write(f\"Please enter your name to load the rest of the page\")\nelse:\n    st.write(f\"Welcome to the interactive penguin data explorer, {user_name}!\")\n\n    penguins = load_penguins()\n\n    axis_options = ['bill_length_mm', 'bill_depth_mm',\n        'flipper_length_mm', 'body_mass_g']\n\n    col_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\n    axis_options.remove(col_1)\n\n    col_2 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n\n    color_factor = st.selectbox(\"Select the column to colour the chart by\",\n    [\"species\", \"sex\", \"island\"])\n\n    fig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\n    title=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\n    st.plotly_chart(fig)\n\n\n\n\n\n\n\n\n\nClick here for the code for the fifth page\n\n\n\n\n\nimport streamlit as st\nimport plotly.express as px\n\nst.markdown(\n  \"\"\"\n&lt;style&gt;\n/* Sidebar font color as default is to set non-selected to more transparent */\n[data-testid=stSidebarNavItems] &gt; li &gt; div &gt; a &gt; span\n{\n    color: #05291F;\n}\n\n/* Sidebar font size */\n    [data-testid=stSidebarNavItems]\n    {\n        font-size: 20px;\n    }\n\n&lt;/style&gt;\n  \"\"\",\n  unsafe_allow_html=True\n)\n\n\nst.title(\"Sidebar Theming and Additions\")\n\nst.write(\"Finally, let's look at the impact of some custom CSS on the sidebar.\")\n\nst.write(\"We've embedded some code when the page first loads that should increase the size of the page names in the sidebar, and also make the page names in the sidebar darker.\")\n\nwith st.expander(\"Click here to view the code\"):\n    st.code(\n    '''\n&lt;style&gt;\n/* Sidebar font color as default is to set non-selected to more transparent */\n[data-testid=stSidebarNavItems] &gt; li &gt; div &gt; a &gt; span\n{\n    color: #05291F;\n}\n\n/* Sidebar font size */\n    [data-testid=stSidebarNavItems]\n    {\n        font-size: 20px;\n    }\n\n&lt;/style&gt;\n    '''\n    )\n\n\nwith st.sidebar:\n    st.write(\"Let's also explore what happens when we add additional things to the sidebar\")\n\n    st.write(\"It looks like it automatically appears below the navigation\")\n\n    num_repeats = st.slider(\"Pick a number\", 1, 50, 2)\n\n    text_repeats = st.text_input(\"Enter some text\", None)\n\n\nif text_repeats is None:\n    st.write(\"Enter some text in the box in the sidebar\")\nelse:\n    st.write(\"Here is your text repeated that many times!\")\n\n    st.write(text_repeats * num_repeats)",
    "crumbs": [
      "Layout",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Multipage Apps</span>"
    ]
  },
  {
    "objectID": "app_colours.html",
    "href": "app_colours.html",
    "title": "26  App Colours",
    "section": "",
    "text": "There are a few parts of Streamlit’s theming that we can officially change using a configuration file.\nThis file needs to be called config.toml and lives inside a subfolder called .streamlit\n\nThe config.toml file contains a variable number of parameters.\nIt can determine whether the default colourscheme is light or dark, and whether the default streamlit colours are overridden.\nYou can create a template config.toml from within streamlit, then paste the output into a config.toml file you create yourself.\n\nLet’s look at an example app.\n\n26.0.1 config.toml\n[theme]\nbase=\"light\"\nprimaryColor=\"#005EB8\"\nsecondaryBackgroundColor=\"#00e0ff\"\n\n\n26.0.2 app.py\n\nimport streamlit as st\n\nst.title('Simple Calculator App')\n\nnum_1 = st.number_input(label=\"First Number\")\n\nnum_2 = st.number_input(label=\"Second Number\")\n\noperator = st.selectbox(label=\"Operation\", options=[\"Add\", \"Subtract\", \"Multiply\", \"Divide\"])\n\nif operator == \"Add\":\n    output = num_1 + num_2\nelif operator == \"Subtract\":\n    output = num_1 - num_2\nelif operator == \"Multiply\":\n    output = num_1 * num_2\nelif operator == \"Divide\":\n    output = num_1 / num_2\n\nst.text(f\"The answer is {output}\")",
    "crumbs": [
      "Styling",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>App Colours</span>"
    ]
  },
  {
    "objectID": "logos.html",
    "href": "logos.html",
    "title": "27  Logos",
    "section": "",
    "text": "27.1 Larger logos\nIt is possible to include larger logos through more advanced tricks, but they are fragile and prone to breaking as changes are made to the Streamlit library.\nThe approach requires using some markdown to inject some custom CSS (see the fonts chapter for more details on CSS).\nHere is a reusable function you could adapt to your own use:\ndef add_logo():\n    '''\n    Add a logo at the top of the page navigation sidebar\n\n    Approach written by blackary on\n    https://discuss.streamlit.io/t/put-logo-and-title-above-on-top-of-page-navigation-in-sidebar-of-multipage-app/28213/5\n\n    '''\n    st.markdown(\n        \"\"\"\n        &lt;style&gt;\n            [data-testid=\"stSidebarNav\"] {\n                background-image: url(https://raw.githubusercontent.com/hsma-programme/Teaching_DES_Concepts_Streamlit/main/resources/hsma_logo_transparent_background_small.png);\n                background-repeat: no-repeat;\n                padding-top: 175px;\n                background-position: 40px 30px;\n            }\n            [data-testid=\"stSidebarNav\"]::before {\n                content: \"The DES Playground\";\n                padding-left: 20px;\n                margin-top: 50px;\n                font-size: 30px;\n                position: relative;\n                top: 100px;\n            }\n\n        &lt;/style&gt;\n        \"\"\",\n        unsafe_allow_html=True,\n    )\nimport streamlit as st\n\ndef add_logo():\n    '''\n    Add a logo at the top of the page navigation sidebar\n\n    Approach written by blackary on\n    https://discuss.streamlit.io/t/put-logo-and-title-above-on-top-of-page-navigation-in-sidebar-of-multipage-app/28213/5\n\n    '''\n    st.markdown(\n        \"\"\"\n        &lt;style&gt;\n            [data-testid=\"stSidebarNav\"] {\n                background-image: url(https://raw.githubusercontent.com/hsma-programme/Teaching_DES_Concepts_Streamlit/main/resources/hsma_logo_transparent_background_small.png);\n                background-repeat: no-repeat;\n                padding-top: 175px;\n                background-position: 40px 30px;\n            }\n            [data-testid=\"stSidebarNav\"]::before {\n                content: \"The DES Playground\";\n                padding-left: 20px;\n                margin-top: 50px;\n                font-size: 30px;\n                position: relative;\n                top: 100px;\n            }\n\n        &lt;/style&gt;\n        \"\"\",\n        unsafe_allow_html=True,\n    )\n\nadd_logo()\n\nst.title('Simple Calculator App')\n\nwith st.sidebar:\n  num_1 = st.number_input(label=\"First Number\")\n\n  num_2 = st.number_input(label=\"Second Number\")\n\n  operator = st.selectbox(label=\"Operation\", options=[\"Add\", \"Subtract\", \"Multiply\", \"Divide\"])\n\nif operator == \"Add\":\n    output = num_1 + num_2\nelif operator == \"Subtract\":\n    output = num_1 - num_2\nelif operator == \"Multiply\":\n    output = num_1 * num_2\nelif operator == \"Divide\":\n    output = num_1 / num_2\n\nst.text(f\"The answer is {output}\")",
    "crumbs": [
      "Styling",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Logos</span>"
    ]
  },
  {
    "objectID": "fonts.html",
    "href": "fonts.html",
    "title": "28  Fonts",
    "section": "",
    "text": "To customise the look of your app much more than this, we need to turn to custom css.\nCSS stands for ‘cascading style sheets’ and is a language used for theming much of the web!\nWe can create our own .css file and force Streamlit to load it in.\n\nTo load the file into the app, we need to include the following command:\n\nwith open(\"style.css\") as css:\n    st.markdown(f'&lt;style&gt;{css.read()}&lt;/style&gt;', unsafe_allow_html=True)\n\nThis points towards the css file and wrapss it in some HTML tags that will ensure the css is recognised by the web browser.\nThe css file can contain any valid css, but we are interested in this chapter in targeting fonts specifically.\nTo begin with, we load in a font from the Google font families.\nWe then choose some areas of this app to apply it to.\nh1, h2, h3, h4, p will target all headers and the main body text in the app.\nMore advanced or Streamlit-specific elements may be harder to target.\n@import url('https://fonts.googleapis.com/css2?family=Lexend:wght@200&display=swap');\n\nhtml, body, st-emotion-cache [class*=\"css\"] {\n    font-family: 'Lexend', sans-serif;\n    font-size: 18px;\n    font-weight: 200;\n    color: #091747;\n}\n\nh1, h2, h3, h4, p {\n    font-family: \"Lexend\", sans-serif;\n}\n\n\n\n\n\n\nTip\n\n\n\nYou can right click when running your app and choose ‘inspect’ to get an idea of the possible tags to target with your custom CSS.\nThe streamlit forums and StackOverflow are also good ways to find examples of people applying custom theming to similar things to what you are looking to do.\n\n\nHere is an example of a Streamlit title with and without the custom theming applied.\n\n\n\n\n\n\n\nTip\n\n\n\nGoogle fonts provide a good option that is easy to load in via the method above.\nYou can explore the wide range of fonts offered here:\nhttps://fonts.google.com/\nIstok Web is often cited as being the closest Google Font equivalent to the standard NHS font Frutiger.\nTo apply this, you would use\n@import url('https://fonts.googleapis.com/css2?family=Istok+Web:wght@200&display=swap');\n\nhtml, body, st-emotion-cache [class*=\"css\"] {\n    font-family: 'Istok Web', sans-serif;\n    font-size: 18px;\n    font-weight: 200;\n    color: #091747;\n}\n\nh1, h2, h3, h4, p {\n    font-family: \"Istok Web\", sans-serif;\n}",
    "crumbs": [
      "Styling",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Fonts</span>"
    ]
  },
  {
    "objectID": "forms_and_run_buttons.html",
    "href": "forms_and_run_buttons.html",
    "title": "29  Adding a ‘Run’ Button",
    "section": "",
    "text": "29.1 Streamlit forms\nAn alternative to this is to use the official Streamlit forms component.\nhttps://docs.streamlit.io/develop/api-reference/execution-flow/st.form",
    "crumbs": [
      "Controlling Application Flow",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Adding a 'Run' Button</span>"
    ]
  },
  {
    "objectID": "partial_reruns.html",
    "href": "partial_reruns.html",
    "title": "30  Partial Reruns",
    "section": "",
    "text": "30.1 The Partial Rerun Decorator\nNow let’s rewrite this using the fragment code.\nimport streamlit as st\nfrom palmerpenguins import load_penguins\nimport plotly.express as px\nimport time\n\npenguins = load_penguins()\n\napp_column_1, app_column_2 = st.columns(2)\n\naxis_options = ['bill_length_mm', 'bill_depth_mm',\n       'flipper_length_mm', 'body_mass_g']\n\n1@st.fragment()\n2def penguin_barchart():\n    time.sleep(3)\n    species = st.selectbox(\"Select a penguin species to filter by\", [\"Adelie\", \"Gentoo\", \"Chinstrap\"])\n    filtered_df_species = penguins[penguins['species'] == species]\n    st.plotly_chart(px.bar(filtered_df_species['sex'].value_counts(), y='count'))\n\n\n3@st.fragment()\ndef penguin_scatterplot():\n    time.sleep(3)\n    col_1 = st.selectbox(\"Select the column to use for the x axis\", axis_options)\n    axis_options.remove(col_1)\n    col_2 = st.selectbox(\"Select the column to use for the y axis\", axis_options)\n\n    color_factor = st.selectbox(\"Select the column to colour the chart by\",\n    [\"species\", \"sex\", \"island\"])\n\n    fig = px.scatter(penguins, x=col_1, y=col_2, color=color_factor,\n    title=f\"Penguins Dataset - {col_1} vs {col_2}, coloured by {color_factor}\")\n\n    st.plotly_chart(fig)\n\n\nwith app_column_1:\n4   penguin_barchart()\n\nwith app_column_2:\n5   penguin_scatterplot()\n\n\n1\n\nWe use the @st.fragment() decorator on its own line\n\n2\n\nInstead of just creating the inputs and outputs straight in the app, we need to wrap them in a function. This function doesn’t need to return anything, and we can call it whatever we like. Note that there is no blank line between the @st.fragment() decorator and the function definition. Here, we’ve counted the select dropdown for species, the pandas dataframe filter action, and the creation of the barplot figure as being a single thing we want to rerun when any element within those three changes in a way that would trigger a rerun usually.\n\n3\n\nWe then repeat this for our next function.\n\n4\n\nUsing the with notation with the first column we created, we then call our first function.\n\n5\n\nWe then repeat this for the second column and second function.\nNotice that now when we change the parameters in the drop-down select boxes, only half of the app fades out - indicating that only half of the app is updating at a time; each half of the page can now act independently of the other.",
    "crumbs": [
      "Controlling Application Flow",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Partial Reruns</span>"
    ]
  },
  {
    "objectID": "partial_reruns.html#the-partial-rerun-decorator",
    "href": "partial_reruns.html#the-partial-rerun-decorator",
    "title": "30  Partial Reruns",
    "section": "",
    "text": "Note\n\n\n\nAs the fragments feature is so new as of writing this book, it has not yet been integrated into the library we use for displaying the example apps.\nInstead, you can view the output of this code in the embedded webpage below.",
    "crumbs": [
      "Controlling Application Flow",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Partial Reruns</span>"
    ]
  },
  {
    "objectID": "caching.html",
    "href": "caching.html",
    "title": "32  (Coming Soon!) Caching",
    "section": "",
    "text": "32.1 Caching functions with parameters\nWhile using caching for the initial load of a dataframe, it can also make sense to use it for other long-running functions.\nLike normal functions, functions for caching can accept parameters.\nStreamlit will be able to look at the parameters passed in and tell whether it should\nuse a cached version of the data (because the parameters are the same as a previous instance that’s already in its cache)\nrun the function (because it’s a new set of parameters that it doesn’t already have a saved output for in its cache)",
    "crumbs": [
      "Advanced Concepts",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>(Coming Soon!) Caching</span>"
    ]
  },
  {
    "objectID": "caching.html#caching-functions-with-parameters",
    "href": "caching.html#caching-functions-with-parameters",
    "title": "32  (Coming Soon!) Caching",
    "section": "",
    "text": "There are a few complexities around parameters that you may want to look into if using this in your own app: https://docs.streamlit.io/develop/concepts/architecture/caching#excluding-input-parameters",
    "crumbs": [
      "Advanced Concepts",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>(Coming Soon!) Caching</span>"
    ]
  },
  {
    "objectID": "session_state.html",
    "href": "session_state.html",
    "title": "33  Persisting Data Across Pages and Runs with Session State",
    "section": "",
    "text": "33.1 Initialising session state keys\nFirst, we need to initialise the session state key with a default value if it doesn’t already exist.\nif 'your_number' not in st.session_state:\n    st.session_state.your_number = None",
    "crumbs": [
      "Advanced Concepts",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Persisting Data Across Pages and Runs with Session State</span>"
    ]
  },
  {
    "objectID": "session_state.html#initialising-session-state-keys",
    "href": "session_state.html#initialising-session-state-keys",
    "title": "33  Persisting Data Across Pages and Runs with Session State",
    "section": "",
    "text": "This can be anything, and doesn’t strictly have to be the same type of data as the final value will be - though it’s usually good practice to keep it fairly consistent throughout its lifecycle!\n\n\n\n\n\n\n\nTip\n\n\n\nYou need to do this on every page of your app where you will do either of the following:\n\nUpdate the value\nDisplay the value",
    "crumbs": [
      "Advanced Concepts",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Persisting Data Across Pages and Runs with Session State</span>"
    ]
  },
  {
    "objectID": "session_state.html#assigning-to-session-state-keys",
    "href": "session_state.html#assigning-to-session-state-keys",
    "title": "33  Persisting Data Across Pages and Runs with Session State",
    "section": "33.2 Assigning to session state keys",
    "text": "33.2 Assigning to session state keys\nSession state can be used to store a range of things.\nIt can store the input given in a user input widget:\n\nst.session_state.your_number = st.number_input(\n    \"Pick a number between 1 and 100\",\n    min_value=1, max_value=100, value=None\n    )\n\n\n\n\n\n\n\nA note about assigning inputs to session state like this\n\n\n\n\n\nThis is the simplest way to assign a user’s input to the session state to pass it around between pages or something along those lines.\nHowever - you will need to be mindful of what default value you initialise the input with using the value parameter. It will automatically overwrite the session state key as soon as the page containing the input widget is opened.\nLater, we cover the concept of callbacks; the on_change parameter that is available for most streamlit inputs will allow you to use a callback function to update the session state only after the first time the user interacts with the widget, which can be better depending on your app.\n\n\n\nOr the result of a calculation (whether that’s a number, a dataframe, a graph, or something else)\n\nst.session_state.the_final_answer = result * 42\n\nThe thing you’re saving to the state could itself optionally use something stored in the session state!\n\nst.session_state.the_final_answer = st.session_state.your_number * 42",
    "crumbs": [
      "Advanced Concepts",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Persisting Data Across Pages and Runs with Session State</span>"
    ]
  },
  {
    "objectID": "session_state.html#using-the-session-state",
    "href": "session_state.html#using-the-session-state",
    "title": "33  Persisting Data Across Pages and Runs with Session State",
    "section": "33.3 Using the session state",
    "text": "33.3 Using the session state\nYou can then access the session state key regardless of the page you are using it on!\nJust remember - you need to check for whether the key exists in the session state anywhere you are setting or using the key, and set a default value for it if it doesn’t already exist.\nWhen your app is deployed, a user could open the app on a page that means they are trying to view the stored session state key before they’ve had a chance to actually input a value - so think about how you could use conditional logic (if/elif/else) to handle this gracefully.",
    "crumbs": [
      "Advanced Concepts",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Persisting Data Across Pages and Runs with Session State</span>"
    ]
  },
  {
    "objectID": "session_state.html#a-more-complex-multipage-example",
    "href": "session_state.html#a-more-complex-multipage-example",
    "title": "33  Persisting Data Across Pages and Runs with Session State",
    "section": "33.4 A more complex multipage example",
    "text": "33.4 A more complex multipage example\nLet’s now take a look at a full example across several pages that makes use of session state.\nHere, we’ll have a numeric input that makes use of session state.\nWe’ll have a text input for the user’s name which doesn’t make use of session state.\nTry comparing the behaviour when moving between the different pages of the app.\n\n33.4.1 app.py\n\nimport streamlit as st\n\npg = st.navigation([\n        st.Page(\"page_1.py\", title=\"Start here!\"),\n        st.Page(\"page_2.py\", title=\"Now go here\")\n     ])\n\npg.run()\n\n\n\n33.4.2 page_1.py\n\nimport streamlit as st\n\nif 'your_number' not in st.session_state:\n    st.session_state.your_number = None\nif 'the_final_answer' not in st.session_state:\n    st.session_state.the_final_answer = None\n\nst.title(\"Session State Example\")\n\nst.session_state.your_number = st.number_input(\n    \"Pick a number between 1 and 100\",\n    min_value=1, max_value=100, value=None\n    )\n\nif st.session_state.the_final_answer is None:\n    \"Enter a number and then go to the next page to calculate the final answer\"\nelse:\n    f\"Your answer is {st.session_state.the_final_answer} - but what was the question?\"\n\nst.divider()\n\nname_input = st.text_input(\"Enter Your Name\")\n\n\n\n33.4.3 page_2.py\n\nimport streamlit as st\n\nif 'your_number' not in st.session_state:\n    st.session_state.your_number = None\nif 'the_final_answer' not in st.session_state:\n    st.session_state.the_final_answer = None\n\nif st.session_state.your_number is None:\n    st.write(\"Go back to the previous page and enter a number!\")\nelse:\n    st.write(f\"I remember your number! It's {st.session_state.your_number}\")\n\n    st.session_state.the_final_answer = st.session_state.your_number * 42\n    st.write(\"I've calculated the final answer and put it back on the first page...\")\n\nst.divider()\n\nst.write(\"Your name? Let me look up what your name is.\")\n\ntry:\n    st.write(name_input)\nexcept:\n    st.write(\"I don't seem to remember your name...\")\n\n\n\n\n\n\n\nNote\n\n\n\nThe sample app linked below also uses a concept known as callbacks, which is often used with session state, to make the button increment work. Head to the callbacks chapter to find out more!\n\n\n{=html} &lt;iframe width=\"780\" height=\"800\" src=\"https://session-state-callbacks-examples-hsma.streamlit.app/\" title=\"Session State example\"&gt;&lt;/iframe&gt;",
    "crumbs": [
      "Advanced Concepts",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Persisting Data Across Pages and Runs with Session State</span>"
    ]
  },
  {
    "objectID": "cheat_sheet.html",
    "href": "cheat_sheet.html",
    "title": "47  Streamlit Cheat Sheet",
    "section": "",
    "text": "The fantastic Streamlit Cheat Sheet is well worth bookmarking!\nhttps://cheat-sheet.streamlit.app/",
    "crumbs": [
      "Additional Resources",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Streamlit Cheat Sheet</span>"
    ]
  },
  {
    "objectID": "static_maps.html#static-maps",
    "href": "static_maps.html#static-maps",
    "title": "8  Static Maps",
    "section": "",
    "text": "Tip\n\n\n\nTake a look at the HSMA geographic modelling and visualisation book to find out more about creating and modifying static maps in python with geopandas and matplotlib.\nNote that you will need to adapt the code in those examples slightly to use the same layout as the code above: the main difference is using fig, ax = plt.subplots() and the argument ax=ax in our plot function, but most other aspects will be unchanged.",
    "crumbs": [
      "Outputs",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Static Maps</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#other-numeric-date-and-time-inputs",
    "href": "text_numeric_and_selection_inputs.html#other-numeric-date-and-time-inputs",
    "title": "12  An Overview of Available Input Types",
    "section": "12.2 Other numeric, date and time inputs",
    "text": "12.2 Other numeric, date and time inputs\nLet’s have a very quick look at some of the other inputs available to us within Streamlit.\nThe desired type of the output will be inferred from the default value you pass into the slider.\n\n\n\n\n\n\nTip\n\n\n\nAll of the input types given below can take a huge range of additional parameters to further refine their behaviour.\nFor example, many can take default values, have an optional tooltip that appears on hover, or have the way in which their values appear adjusted.\nThe maximum and minimum allowed values for numeric, date and time sliders can be set, and the input can be disabled (e.g. in response to another input).\nIt’s highly recommended that you take a look at the documentation to understand the full range of options available.\n\n\n\n12.2.1 Range Slider\n\nlower_value, upper_value = st.slider(\n    \"Pick a lower and upper limit\",\n    min_value=0,\n    max_value=100,\n    value=(35, 80)\n    )\n\n\n\n12.2.2 Time Slider\n\nchosen_time = st.slider(\n    \"Select a time:\",\n    time(11, 30)\n)\n\n\n\n12.2.3 Date Slider\n\nselected_date = st.slider(\n    \"Select a date\",\n    value=datetime(2022, 1, 1),\n    format=\"DD/MM/YYYY\",\n)\n\n\n\n12.2.4 Date Range Slider\n\nstart_date, end_date = st.slider(\n    \"Select a date\",\n    value=(datetime(2022, 1, 1), datetime(2023, 6, 1)),\n    format=\"DD/MM/YYYY\"\n)\n\n\n\n12.2.5 Time Range Slider\n\nstart_time, end_time = st.slider(\n    \"Select a time:\",\n    value=(time(11, 30), time(12, 45))\n)\n\n\n\n12.2.6 Datetime Slider\n\nchosen_datetime = st.slider(\n    \"Select a date and time\",\n    value=datetime(2022, 1, 1, 12, 0),\n    format=\"DD/MM/YYYY @ hh:mm\",\n)\n\n\n\n12.2.7 Date Calendar Picker\n\nselected_date = st.date_input(\n    \"Choose a date on the calendar picker\"\n    )\n\n\n\n12.2.8 Time Calendar Picker\n\nselected_time = st.time_input(\n    \"Select a time\"\n    )\n\n\n\n12.2.9 Interactive Examples",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#text-inputs",
    "href": "text_numeric_and_selection_inputs.html#text-inputs",
    "title": "12  An Overview of Available Input Types",
    "section": "12.3 Text Inputs",
    "text": "12.3 Text Inputs\n\n\n\n\n\n\nTip\n\n\n\nAll of the input types given below can take a huge range of additional parameters to further refine their behaviour.\nFor example, many can take default values, have an optional tooltip that appears on hover, have a placeholder appear to further guide the user’s input, or have a maximum length set.\nIt’s highly recommended that you take a look at the documentation to understand the full range of options available.\n\n\n\n12.3.1 Long text\n\nlonger_text_input = st.text_area(\n    \"Use this input to enter a larger piece of text\"\n    )\n\n\n\n12.3.2 Short text\n\nshorter_text_input = st.text_input(\n    \"We saw this before - this is an input for a short bit of text\"\n    )\n\n\n\n12.3.3 Interactive Examples",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#other-useful-inputs---boolean-truefalse-flags",
    "href": "text_numeric_and_selection_inputs.html#other-useful-inputs---boolean-truefalse-flags",
    "title": "12  An Overview of Available Input Types",
    "section": "12.5 Other useful inputs - Boolean (True/False) Flags",
    "text": "12.5 Other useful inputs - Boolean (True/False) Flags\nThe final inputs we’ll take a quick look at are checkbox and toggle inputs.\nThese are useful as they return boolean values - True or False.\n\n\n\n\n\n\nTip\n\n\n\nWhile the input types below don’t have quite as many additional parameters as some of the others, it’s highly recommended that you take a look at the documentation to understand the full range of options available.\n\n\n\n12.5.1 Checkbox\n\ncheckbox_value = st.checkbox(\"Tick or untick me!\")\n\n\n\n12.5.2 Toggle\n\ntoggle_value = st.toggle(\"Tick or untick me!\")\n\n\n\n12.5.3 Interactive Examples",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  },
  {
    "objectID": "text_numeric_and_selection_inputs.html#using-inputs-in-calculations",
    "href": "text_numeric_and_selection_inputs.html#using-inputs-in-calculations",
    "title": "12  An Overview of Available Input Types",
    "section": "",
    "text": "Tip\n\n\n\nAll of the input types given below can take a huge range of additional parameters to further refine their behaviour.\nFor example, many can take default values, have an optional tooltip that appears on hover, or have the way in which their values appear adjusted.\nThe maximum and minimum allowed values can be set, and the input can be disabled (e.g. in response to another input).\nIt’s highly recommended that you take a look at the documentation to understand the full range of options available.\n\n\n\n12.1.1 Numeric Input\n\nimport streamlit as st\n\nst.subheader(\"Numeric Input\")\n\nchosen_number = st.number_input(\n    \"Pick a Number\"\n    )\n\nst.write(f\"The number you have chosen is {chosen_number}\")\n\nchosen_number_multiplied_by_5 = chosen_number * 5\n\nst.write(f\"Your number multiplied by 5 is {chosen_number_multiplied_by_5}\")\n\nst.write(f\"Your number plus 7 is {chosen_number + 7}\")\n\n\n\n12.1.2 Numeric Slider\n\nst.subheader(\"Numeric Slider\")\n\nchosen_number_slider = st.slider(\n    \"Pick a Number on the slider\",\n    min_value=0,\n    max_value=250,\n    value=50\n    )\n\nst.write(f\"The number you have chosen is {chosen_number_slider}\")\n\nchosen_number_slider_multiplied_by_8 = chosen_number * 8\n\nst.write(f\"Your number multiplied by 8 is {chosen_number_slider_multiplied_by_8}\")\n\nst.write(f\"Your number plus 3 is {chosen_number_slider + 3}\")\n\n\n\n12.1.3 Interactive Example",
    "crumbs": [
      "User Inputs",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>An Overview of Available Input Types</span>"
    ]
  }
]